<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="操作系统的能力现代操作系统，内核⼀般会提供 4 个基本能⼒：进程调度：决定哪个进程、线程使⽤ CPU，也就是进程调度的能⼒；内存管理：决定内存的分配和回收，也就是内存管理的能⼒；设管理备：为进程与硬件设备之间提供通信能⼒，也就是硬件通信能⼒；系统调⽤：如果应⽤程序要运⾏更⾼权限运⾏的服务，那么就需要有系统调⽤，它是⽤户程序与操作系统之间的接⼝。 伟大的原理：局部性原理程序在执行时呈现出局部性规律，">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="依只若只的博客">
<meta property="og:description" content="操作系统的能力现代操作系统，内核⼀般会提供 4 个基本能⼒：进程调度：决定哪个进程、线程使⽤ CPU，也就是进程调度的能⼒；内存管理：决定内存的分配和回收，也就是内存管理的能⼒；设管理备：为进程与硬件设备之间提供通信能⼒，也就是硬件通信能⼒；系统调⽤：如果应⽤程序要运⾏更⾼权限运⾏的服务，那么就需要有系统调⽤，它是⽤户程序与操作系统之间的接⼝。 伟大的原理：局部性原理程序在执行时呈现出局部性规律，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/63874010246117.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/487145910246742.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/519060711266908.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/475621011259577.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/227005311256132.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/562890211252452.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5213036139083.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1622019696606.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/701232485698.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/592690815251886.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7861115269766.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4368924759853.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2931454446495.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/40059992973.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/576865409267371.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5586609807317.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1173435696621.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/107475909264873.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/416540910246114.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/510461310268554.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/598501410263690.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/354790711257236.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/107475909264873.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/321104711250370.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/439454711240900.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/200245111243404.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/26395211252351.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/223035114245236.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/507125114245845.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/431122815272800.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/424744115244311.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/295374815240562.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/547263518240701.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/95371510264876.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/416540910246114.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/468791310252792.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/114001410257831.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/254071810259126.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2429254083522.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/312724210260128.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/206554310260305.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/345674310245857.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/291044710262136.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/98108102469.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4064114819868.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/595705014240451.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/290185114258877.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4171516095354.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2239037095963.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/283411416246744.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4947119118995.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5290937106862.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1128100686625.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5742525189098.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1333708746621.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5363799515717.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3568121535713.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/503013809240452.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/104654809258878.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/280175009246745.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/552165409256135.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/437125409259580.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/60975509251889.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/144745809269769.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/527295909267373.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/145370110264875.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/594342710246116.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/301453410268556.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/366183610263692.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/234184310240902.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/422510511240452.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/253940811258878.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/375061511246745.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/421221711266911.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4626434545792.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5077935819947.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/106675315259580.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3320624841468.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/324970016256135.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/165871416251889.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/515381916269769.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3305717821354.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/118080312240551.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2535111169068.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3580711156935.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2882998769758.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/583932456400.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4893934002878.png">
<meta property="og:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/84610117267373.png">
<meta property="article:published_time" content="2024-05-17T07:44:23.221Z">
<meta property="article:modified_time" content="2024-05-17T07:22:39.966Z">
<meta property="article:author" content="徐川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/63874010246117.png">

<link rel="canonical" href="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | 依只若只的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">依只若只的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员技术栈</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="徐川">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="依只若只的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-17 15:44:23 / 修改时间：15:22:39" itemprop="dateCreated datePublished" datetime="2024-05-17T15:44:23+08:00">2024-05-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="操作系统的能力"><a href="#操作系统的能力" class="headerlink" title="操作系统的能力"></a>操作系统的能力</h1><p>现代操作系统，内核⼀般会提供 4 个基本能⼒：<br>进程调度：决定哪个进程、线程使⽤ CPU，也就是进程调度的能⼒；<br>内存管理：决定内存的分配和回收，也就是内存管理的能⼒；<br>设管理备：为进程与硬件设备之间提供通信能⼒，也就是硬件通信能⼒；<br>系统调⽤：如果应⽤程序要运⾏更⾼权限运⾏的服务，那么就需要有系统调⽤，它是⽤户程序与操作系统之间的接⼝。</p>
<h1 id="伟大的原理：局部性原理"><a href="#伟大的原理：局部性原理" class="headerlink" title="伟大的原理：局部性原理"></a>伟大的原理：局部性原理</h1><p><strong>程序在执行时呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分；相应的它所访问的空间也局限于某个区域</strong><br>时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。<br>空间局部性：在最近的将来将用到的信息很可能与正在使用的信息在空间地址上是临近的。<br>顺序局部性：在典型程序中，除转移类指令外，大部分指令是顺序进行的。</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="CPU三级缓存"><a href="#CPU三级缓存" class="headerlink" title="CPU三级缓存"></a>CPU三级缓存</h2><p>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cache&#x2F;index3&#x2F;size</p>
<h2 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h2><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/63874010246117.png"></p>
<h2 id="CPU读取数据方式"><a href="#CPU读取数据方式" class="headerlink" title="CPU读取数据方式"></a>CPU读取数据方式</h2><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/487145910246742.png"></p>
<h2 id="CPU的缓存写入"><a href="#CPU的缓存写入" class="headerlink" title="CPU的缓存写入"></a>CPU的缓存写入</h2><p>在什么时机才把 Cache 中的数据写回到内存？<br><strong>写直达：</strong><br>把数据同时写入内存和 Cache 中</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/519060711266908.png"></p>
<p><strong>写回</strong><br>写错时获取策略 ：当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中，减少了数据写回内存的频率</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/475621011259577.png"></p>
<p>内存读取？<br>保持独占机制</p>
<h2 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h2><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/227005311256132.png"></p>
<p>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播</strong>；<br>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化</strong>。</p>
<p><strong>解决方式</strong><br>写失效：当一个CPU修改了数据，如果其他CPU有该数据，则通知其为无效；<br>写更新：当一个CPU修改了数据，如果其他CPU有该数据，则通知其更新新数据，（写更新会导致大量的更新操作）。</p>
<h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><p><strong>属于写更新</strong><br>当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的<strong>广播事件</strong>，并检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache</p>
<h3 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h3><p><strong>属于写失效，写回</strong></p>
<ul>
<li>Modified，已修改<br>缓存行是脏的（dirty），与内存的值不同。如果别的CPU内核要读内存这块数据，该缓存行必须回写到内存，状态变为共享(S).</li>
<li>Exclusive，独占<br>缓存行只在当前缓存中，但是干净的——缓存数据相同于内存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。</li>
<li>Shared，共享<br>缓存行也存在于其它缓存中且是未修改的。缓存行可以在任意时刻抛弃。</li>
<li>Invalidated，已失效<br>缓存行是无效的</li>
</ul>
<p>当块标记为M（已修改）时，其他高速缓存中块的副本必须标记为I（无效）。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/562890211252452.png"></p>
<ol>
<li>当一个处理器需要访问某个内存数据时，它首先会检查自己的缓存中是否有该数据的副本。如果缓存中没有该数据的副本，则会发出一个缓存不命中<strong>（miss）</strong>请求，从主内存中获取该数据的副本，并将该数据的副本存储到自己的缓存中。</li>
<li><strong>当一个处理器发出miss请求时</strong>，如果该数据的副本已经存在于另一个处理器或核心的缓存中（即处于共享状态），则该处理器可以<strong>从另一个处理器的缓存中复制该数据的副本</strong>。这个过程称为缓存到缓存复制（cache-to-cache transfer）。</li>
<li>如果两个缓存都处于修改状态，那么必须先将其中一个缓存的数据写回到主内存，然后才能进行缓存到缓存复制。</li>
</ol>
<h2 id="CPU软中断"><a href="#CPU软中断" class="headerlink" title="CPU软中断"></a>CPU软中断</h2><p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p>
<p>上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。<br>下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。</p>
<h1 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h1><p>对于内核的架构一般有这三种类型：</p>
<ul>
<li>宏内核，包含多个模块，一个完整的可执行程序，且拥有最高的权限；内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</li>
<li>微内核，有一个最小版本的内核，一些模块和服务则由用户态管理；最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信</li>
<li>混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li>
</ul>
<p><strong>Window 的内核设计是混合型内核</strong></p>
<p><strong>Linux 的内核是宏内核</strong></p>
<h2 id="用户态-内核态的方式"><a href="#用户态-内核态的方式" class="headerlink" title="用户态-&gt;内核态的方式"></a><font color="red">用户态-&gt;内核态的方式</font></h2><ol>
<li>系统调用<br>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现</li>
<li>异常<br>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。  </li>
<li>外围设备的中断<br>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
</ol>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h2><p>局部性原理<br>单片机的 CPU 是直接操作内存的「物理地址」，要想在内存中同时运行两个程序是不可能的。如果第一个程序在某个位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容</p>
<p>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5213036139083.png"></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1622019696606.png"></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>存在内存碎⽚的问题<br>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开⼀个200MB 的程序。</li>
</ol>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/701232485698.png"></p>
<p>解决外部内存碎⽚的问题就是内存交换。这个内存交换空间，在 Linux 系统⾥，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，⽤于内存与硬盘的空间交换。<br>2. 可能内存交换的效率低的问题<br>如果内存交换的时候，交换的是⼀个占内存空间很⼤的程序，这样整个机器都会显得卡顿。</p>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，叫页。在 Linux 下，每一页的大小为 4KB。</p>
<p>虚拟地址与物理地址之间通过页表来映射，如下图：</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/592690815251886.png"></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7861115269766.png"></p>
<p><strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4368924759853.png"></p>
<p>详细转换如下图：</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2931454446495.png"></p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>内存碎片：<br>当进程访问的虚拟地址在⻚表中查不到时，系统会产⽣⼀个<strong>缺⻚异常</strong>，进⼊系统内核空间分配物理内存、更新进程⻚表，最后再返回⽤户空间，恢复进程的运⾏采⽤了分⻚，那么释放的内存都是以⻚为单位释放的，也就不会产⽣⽆法给进程使⽤的⼩内存。<br>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对内存分页机制会有<strong>内部内存碎片</strong>的现象。</p>
<p>空间上的缺陷：<br>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），一个进程的页表需要装下 100 多万个「页表项」（2^20） ，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。</p>
<p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。那么，100 个进程的话，就需要 400MB 的内存来存储页表</p>
<h3 id="多级分页"><a href="#多级分页" class="headerlink" title="多级分页"></a>多级分页</h3><p>将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示：</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/40059992973.png"></p>
<p><strong>映射 4GB 地址空间需要 4KB（一级页表）+ 4MB（二级页表）的内存，更大的空间？（局部性原理的充分应用）</strong><br><strong>局部性原理：</strong><br>每个进程都有 4GB 的虚拟地址空间，对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，<br>对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p>
<p><strong>用时分配：</strong><br>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。</strong><br>例如：假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）&#x3D; 0.804MB &lt; 4MB</p>
<p>总结：<br>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p>
<h4 id="TLB技术"><a href="#TLB技术" class="headerlink" title="TLB技术"></a>TLB技术</h4><p><strong>局部性原理的充分应用</strong><br>所以，把最常访问的几个页表项存储到访问速度更快的硬件，在CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB ，通常称为页表缓存、转址旁路缓存、快表等</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/576865409267371.png"></p>
<p>在CPU 中，封装了内存管理单元芯片，它用来完成地址转换和 TLB 的访问与交互。有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。<strong>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</strong></p>
<h3 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h3><p><strong>Linux内核的内存管理方式</strong></p>
<p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5586609807317.png"></p>
<p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分</p>
<p>每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>
<h3 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a><font color="red">伙伴算法</font></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> __init <span class="title">free_all_bootmem</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> __init <span class="title">free_all_bootmem_core</span><span class="params">(<span class="type">bootmem_data_t</span> *bdata)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>内部碎片是已经被分配出去的（能明确指出属于哪个进程）内存空间大于请求所需的内存空间，不能被利用的空间就是内部碎片。</li>
<li>外部碎片是指还没分配出去（不属于任何进程），但是由于大小无法分配给申请内存空间的新进程的内存空闲块。</li>
</ul>
<p>伙伴系统算法来解决<mark>内存外部碎片</mark>的问题。<mark>swap分区也为一种方法</mark>，把所有的空闲页框分组为 11 块链表，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。<br>假设系统中有 1MB 大小的内存需要动态管理，按照伙伴算法的要求：需要将这1M大小的内存进行划分。这里，我们将这1M的内存分为 64K、64K、128K、256K、和512K 共五个部分，如下图a所示</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1173435696621.png"></p>
<ol>
<li>此时，如果有一个程序A想要申请一块45K大小的内存，则系统会将第一块64K的内存块分配给该程序（产生内部碎片为代价），如图b所示；</li>
<li>然后程序B向系统申请一块68K大小的内存，系统会将128K内存分配给该程序，如图c所示；</li>
<li>接下来，程序C要申请一块大小为35K的内存。系统将空闲的64K内存分配给该程序，如图d所示；</li>
<li>之后程序D需要一块大小为90K的内存。当程序提出申请时，系统本该分配给程序D一块128K大小的内存，但此时内存中已经没有空闲的128K内存块了，于是根据伙伴算法的原理，系统会将256K大小的内存块平分，将其中一块分配给程序D，另一块作为空闲内存块保留，等待以后使用，如图e所示；</li>
<li>紧接着，程序C释放了它申请的64K内存。在内存释放的同时，系统还负责检查与之相邻并且同样大小的内存是否也空闲，由于此时程序A并没有释放它的内存，所以系统只会将程序C的64K内存回收，如图f所示；</li>
<li>然后程序A也释放掉由它申请的64K内存，系统随机发现与之相邻且大小相同的一段内存块恰好也处于空闲状态。于是，将两者合并成128K内存，如图g所示；</li>
<li>之后程序B释放掉它的128k，系统也将这块内存与相邻的128K内存合并成256K的空闲内存，如图h所示；</li>
<li>最后程序D也释放掉它的内存，经过三次合并后，系统得到了一块1024K的完整内存，如图i所示。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，<strong>因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性</strong>，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。<br>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题。</strong><br>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</p>
<h2 id="内存进阶"><a href="#内存进阶" class="headerlink" title="内存进阶"></a>内存进阶</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux的用户空间和内核空间内存大小</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/107475909264873.png"></p>
<p>用户空间内存从低到高分别是 6 种不同的内存段：代表了不同的含义</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/416540910246114.png"></p>
<ul>
<li>代码段，包括<strong>二进制可执行代码</strong>；</li>
<li>数据段，包括<strong>已初始化的静态常量和全局变量</strong>；</li>
<li>BSS 段，包括<strong>未初始化的静态变量和全局变量</strong>；</li>
<li>堆段，包括动态分配的内存，<strong>从低地址开始向上增长</strong>；</li>
<li>文件映射段，包括动态库、共享内存等，<strong>从低地址开始向上增长</strong>（跟硬件和内核版本有关 (opens new window)）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。<strong>从低地址开始向下增长</strong>，栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><h4 id="malloc-是如何分配内存的？"><a href="#malloc-是如何分配内存的？" class="headerlink" title="malloc 是如何分配内存的？"></a>malloc 是如何分配内存的？</h4><ul>
<li>方式一：通过 brk() 系统调用从堆分配内存</li>
</ul>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/510461310268554.png"></p>
<ul>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存；也就是从文件映射区“偷”了一块内存</li>
</ul>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/598501410263690.png"></p>
<p>malloc() 源码里默认定义了一个阈值：</p>
<p>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；<br>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i &quot;DEFAULT_MMAP_THRESHOLD_MIN&quot; malloc/malloc.c</span><br></pre></td></tr></table></figure>


<h4 id="malloc-1-会分配多大的虚拟内存？"><a href="#malloc-1-会分配多大的虚拟内存？" class="headerlink" title="malloc(1) 会分配多大的虚拟内存？"></a>malloc(1) 会分配多大的虚拟内存？</h4><p>132K</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用cat /proc/%d/maps查看内存分配\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请1字节的内存</span></span><br><span class="line">    <span class="type">void</span> *addr = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此1字节的内存起始地址：%x\n&quot;</span>, addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用cat /proc/%d/maps查看内存分配\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将程序阻塞，当输入任意字符时才往下执行</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放了1字节的内存，但heap堆并不会释放\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；<br>malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//申请1字节的内存</span></span><br><span class="line">  <span class="type">void</span> *addr = <span class="built_in">malloc</span>(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此128KB字节的内存起始地址：%x\n&quot;</span>, addr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用cat /proc/%d/maps查看内存分配\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将程序阻塞，当输入任意字符时才往下执行</span></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放内存</span></span><br><span class="line">  <span class="built_in">free</span>(addr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放了128KB字节的内存，内存也归还给了操作系统\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么不全部使用-mmap-来分配内存？"><a href="#为什么不全部使用-mmap-来分配内存？" class="headerlink" title="为什么不全部使用 mmap 来分配内存？"></a>为什么不全部使用 mmap 来分配内存？</h4><p>申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。<br>另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。</p>
<h4 id="为什么不全部使用-brk-来分配？"><a href="#为什么不全部使用-brk-来分配？" class="headerlink" title="为什么不全部使用 brk 来分配？"></a>为什么不全部使用 brk 来分配？</h4><p>随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片,<strong>导致“内存泄露”</strong></p>
<h4 id="free-函数只传入一个内存地址，为什么能知道要释放多大的内存？"><a href="#free-函数只传入一个内存地址，为什么能知道要释放多大的内存？" class="headerlink" title="free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？"></a>free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</h4><p>运行上述脚本代码可发现：打印的地址比实际程序地址多出来 0x10 （16字节）<br>多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/354790711257236.png"></p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>操作系统在数据读取的时候，其实并不是一字节一字节进行读取的，而是一段一段进行读取</li>
<li>我们假如是4bytes。假如我们要读取一个int，如果不对齐，这个int占用第1块的后3位和第2块的第1位，需要两次读取，将两次的数据组合起来。这样CPU将做出“多余操作”，严重影响处理速度。</li>
<li>因此需要进行内存对齐，从而提高CPU处理速率，而这项任务就交给编译器进行相应的地址分配和优化，编译器会根据提供参数或者目标环境进行相应的内存对齐。</li>
</ul>
<h4 id="结构体内存对齐的规则（未指定-pragma-pack时）"><a href="#结构体内存对齐的规则（未指定-pragma-pack时）" class="headerlink" title="结构体内存对齐的规则（未指定#pragma pack时）"></a>结构体内存对齐的规则（未指定#pragma pack时）</h4><ol>
<li>第一个成员起始于0偏移处；</li>
<li>每个成员按其类型大小和指定对齐参数n中较小的一个进行对齐；</li>
<li>结构体总长度必须为所有对齐参数的整数倍；</li>
<li>对于数组，可以拆开看做n个数组元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
sizeof(A) &#x3D; 8;sizeof(B) &#x3D; 12。</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A的内存布局：</td>
<td align="center">1111</td>
<td align="center">1*</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">B的内存布局：</td>
<td align="center">1***</td>
<td align="center">1111</td>
<td align="center">11**</td>
</tr>
<tr>
<td align="center">其中星号*表示填充的字节。A中，b后面为何要补充一个字节？因为c为short，其起始位置要为2的倍数，就是原则1。c的后面没有补充，因为b和c正好占用4个字节，整个A占用空间为4的倍数，也就是最大成员int类型的倍数，所以不用补充。B中，b是char为1，b后面补充了3个字节，因为a是int为4，根据原则1，起始位置要为4的倍数，所以b后面要补充3个字节。c后面补充两个字节，根据原则3，整个B占用空间要为4的倍数，c后面不补充，整个B的空间为10，不符，所以要补充2个字节。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> e[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> f;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">short</span> h;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">A</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sizeof(A) &#x3D; 24; 这个比较好理解，int为4，double为8，float为4，总长为8的倍数，补齐，所以整个A为24。<br>sizeof(B) &#x3D; 48; 看看B的内存布局。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">e</th>
<th align="center">f</th>
<th align="center">g</th>
<th align="center">h</th>
<th align="center">i</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B的内存布局</td>
<td align="center">11**</td>
<td align="center">1111</td>
<td align="center">11111111</td>
<td align="center">11 * * * * * *</td>
<td align="center">1111****, 11111111, 1111****</td>
</tr>
<tr>
<td align="center">i其实就是A的内存布局。i的起始位置要为24的倍数，所以h后面要补齐。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h3><ul>
<li>大端存储是指低字节存储在高地址</li>
<li>小端存储是指低字节存储在低地址<br>根据联合体来判断该系统是大端还是小端。<mark>因为联合体变量总是从低地址存储</mark><br>判断大小端的代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">test</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;;</span><br><span class="line">    test t;</span><br><span class="line">    t.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.c == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><ol>
<li>后台内存回收：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li>直接内存回收：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
<li>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。</li>
</ol>
<p>OOM Killer 机制：<br>会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<h3 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h3><ul>
<li><p>文件页：<strong>内核缓存的磁盘数据</strong>（Buffer）和<strong>内核缓存的文件数据</strong>（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</p>
</li>
<li><p>匿名页：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的<strong>Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后”释放”这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p>
</li>
</ul>
<p>Linux 提供了一个 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness 选项，用来调整文件页和匿名页的回收倾向。数值越大，越积极使用 Swap</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/vm/swappiness</span><br></pre></td></tr></table></figure>


<h3 id="基于LRU算法"><a href="#基于LRU算法" class="headerlink" title="基于LRU算法"></a>基于LRU算法</h3><p>维护着 active 和 inactive 两个双向链表，其中：<br>active_list 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；<br>inactive_list 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo | grep -i active | sort</span><br></pre></td></tr></table></figure>


<h3 id="如何保护一个进程不被-OOM-杀掉呢？"><a href="#如何保护一个进程不被-OOM-杀掉呢？" class="headerlink" title="如何保护一个进程不被 OOM 杀掉呢？"></a>如何保护一个进程不被 OOM 杀掉呢？</h3><p>Linux 内核里有一个 oom_badness() 函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// points 代表打分的结果</span></span><br><span class="line"><span class="comment">// process_pages 代表进程已经使用的物理内存页面数</span></span><br><span class="line"><span class="comment">// oom_score_adj 代表 OOM 校准值</span></span><br><span class="line"><span class="comment">// totalpages 代表系统总的可用页面数</span></span><br><span class="line">points = process_pages + oom_score_adj*totalpages/<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p> oom_score_adj。它是可以通过 &#x2F;proc&#x2F;[pid]&#x2F;oom_score_adj 来配置的，设置 -1000 到 1000 之间的任意一个数值，-1000不会被杀死</p>
<h3 id="swap机制的作用"><a href="#swap机制的作用" class="headerlink" title="swap机制的作用"></a>swap机制的作用</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/107475909264873.png"></p>
<p>在 32 位&#x2F;64 位操作系统环境下，申请的虚拟内存超过物理内存后会怎么样？</p>
<p>在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。<br>在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。<br>程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的。<strong>当访问这块虚拟内存后，操作系统才会进行物理内存分配。</strong></p>
<p>如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：<br>如果没有开启 Swap 机制，程序就会直接 OOM；<br>如果有开启 Swap 机制，程序可以正常运行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free -m    #linux</span><br><span class="line">dir /A     #windows</span><br></pre></td></tr></table></figure>

<h2 id="内存的预读失效和缓存污染"><a href="#内存的预读失效和缓存污染" class="headerlink" title="内存的预读失效和缓存污染"></a>内存的预读失效和缓存污染</h2><p>预读失效：读磁盘多读了一些，但是没有用到<strong>（局部性原理的充分应用）</strong><br>缓存污染：批量读，把热点数据挤出去</p>
<p><strong>以上问题十分常见，包括操作系统，redis，mysql等</strong><br>Redis实现 LFU 算法，MySQL 和 Linux 操作系统是改进 LRU 算法<br>LRU算法是基于最近使用时间，其核心思想是<strong>淘汰最长时间未被使用的数据</strong>，这适用于访问模式具有时间局部性的场景；<br>LFU算法是基于访问频率，其核心思想是<strong>淘汰访问频率最低的数据</strong>，这适用于访问模式具有频率局部性的场景。</p>
<h3 id="Linux-的-Page-Cache-和-MySQL-的-Buffer-Pool"><a href="#Linux-的-Page-Cache-和-MySQL-的-Buffer-Pool" class="headerlink" title="Linux 的 Page Cache 和 MySQL 的 Buffer Pool"></a>Linux 的 Page Cache 和 MySQL 的 Buffer Pool</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/321104711250370.png">                                    <img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/439454711240900.png"></p>
<h3 id="解决预读失效"><a href="#解决预读失效" class="headerlink" title=" 解决预读失效"></a><font color="red"> 解决预读失效</font></h3><p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）；<br>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/200245111243404.png"></p>
<p>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：young 区域 和 old 区域。<br>预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/26395211252351.png"></p>
<h3 id="解决缓存污染"><a href="#解决缓存污染" class="headerlink" title="解决缓存污染"></a><font color="red">解决缓存污染</font></h3><p>Linux 操作系统：在内存页<strong>被访问第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。<br>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要<strong>进行停留在 old 区域的时间判断</strong></p>
<p>如果第二次的访问时间与第一次访问的时间在 1 秒内（默认值），那么该页就不会被从 old 区域升级到 young 区域；<br>如果第二次的访问时间与第一次访问的时间超过 1 秒，那么该页就会从 old 区域升级到 young 区域；</p>
<h2 id="深入内存"><a href="#深入内存" class="headerlink" title="深入内存"></a>深入内存</h2><p>32位系统，用户态空间划分为3g大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/arch/x86/include/<span class="keyword">asm</span>/page_32_types.h        PAGE_OFFSET</span><br></pre></td></tr></table></figure>


<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/223035114245236.png"><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/507125114245845.png"></p>
<p>进程在内核中的描述符task_struct 结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;</span><br><span class="line">        <span class="comment">// 进程id</span></span><br><span class="line">	    <span class="type">pid_t</span>				pid;</span><br><span class="line">        <span class="comment">// 用于标识线程所属的进程 pid</span></span><br><span class="line">	    <span class="type">pid_t</span>				tgid;</span><br><span class="line">        <span class="comment">// 进程打开的文件信息</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">files_struct</span>		*files;</span><br><span class="line">        <span class="comment">// 内存描述符表示进程虚拟地址空间</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">mm_struct</span>		*mm;</span><br><span class="line"></span><br><span class="line">        .......... 省略 .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进程描述符 task_struct 结构中，有一个专门描述进程虚拟地址空间的内存描述符 mm_struct 结构，这个结构体中包含了进程虚拟内存空间的全部信息。</p>
<p>当我们调用 fork() 函数创建进程的时候，表示进程地址空间的 mm_struct 结构会随着进程描述符 task_struct 的创建而创建</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">do_fork</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title">copy_process</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">struct</span> pid *pid,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">int</span> trace)</span></span></span><br><span class="line"><span class="function">					</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span></span><br></pre></td></tr></table></figure>

<p>通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。<br>通过 vfork() 函数创建出的子进程，首先会设置 CLONE_VM 标识，这样来到 copy_mm 函数中就会进入 if (clone_flags &amp; CLONE_VM) 条件中，在这个分支中会将父进程的虚拟内存空间以及相关页表直接赋值给子进程。这样一来父进程和子进程的虚拟内存空间就变成共享的了。也就是说父子进程之间使用的虚拟内存空间是一样的，并不是一份拷贝。<br>vfork() ：进程-&gt;线程，Linux 内核并不区别对待</p>
<h3 id="内核如何布局进程虚拟内存空间"><a href="#内核如何布局进程虚拟内存空间" class="headerlink" title="内核如何布局进程虚拟内存空间"></a>内核如何布局进程虚拟内存空间</h3><p>在mm_struct中，定义了各个数据域的长度</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/431122815272800.png"></p>
<h3 id="内核如何管理虚拟内存区域"><a href="#内核如何管理虚拟内存区域" class="headerlink" title="内核如何管理虚拟内存区域"></a>内核如何管理虚拟内存区域</h3><p>新的结构体 vm_area_struct，正是这个结构体<strong>描述了</strong>这些虚拟内存区域</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/424744115244311.png"></p>
<p>include&#x2F;linux&#x2F;mm.h：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vm_flags	访问权限</span><br><span class="line">VM_READ	可读</span><br><span class="line">VM_WRITE	可写</span><br><span class="line">VM_EXEC	可执行</span><br><span class="line">VM_SHARD	可多进程之间共享</span><br><span class="line">VM_IO	可映射至设备 IO 空间</span><br><span class="line">VM_RESERVED	内存区域不可被换出</span><br><span class="line">VM_SEQ_READ	内存区域可能被顺序访问</span><br><span class="line">VM_RAND_READ	内存区域可能被随机访问</span><br></pre></td></tr></table></figure>

<h3 id="虚拟内存区域在内核中是如何被组织的"><a href="#虚拟内存区域在内核中是如何被组织的" class="headerlink" title="虚拟内存区域在内核中是如何被组织的"></a>虚拟内存区域在内核中是如何被组织的</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/295374815240562.png"></p>
<p>在进程虚拟内存空间中包含的内存区域 VMA 比较多的情况下，使用红黑树查找特定虚拟内存区域的时间复杂度是 O( logN ) ，可以显著减少查找所需的时间。<br>所以在内核中，同样的内存区域 vm_area_struct 会有两种组织形式，<strong>一种是双向链表用于高效的遍历，另一种就是红黑树用于高效的查找</strong>，每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。</p>
<p>总结：mm_struct中的mmap为vm_area_struct类型，指向了每个域的开始和结束，并且同时以双向链表和红黑树存在，而mm_struct定义的start和end，标示了每个域的结束位置</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h2 id="Linux的进程"><a href="#Linux的进程" class="headerlink" title="Linux的进程"></a>Linux的进程</h2><h3 id="0号进程"><a href="#0号进程" class="headerlink" title="0号进程"></a>0号进程</h3><p>0号进程称为 idle 进程，其 pid 等于0。</p>
<p>每个进程都有struct task_struct。idle进程对应的PCB是 struct task_struct init_task。<br>idle进程是唯一一个没有通过fork或者kernel_thread产生的进程，因为 init_task 是静态变量（初始化了的全局变量），其他进程的PCB都是fork或者kernel_thread动态申请内存创建的。<br>每个进程都有对应的一个函数，idle进程的函数是 start_kernel()，start_kernel() 最后会调用 cpu_startup_entry() ，其内部是 while(1) {}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="type">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1号进程"><a href="#1号进程" class="headerlink" title="1号进程"></a>1号进程</h3><p>1号进程称为 init 进程，其 pid 等于1。</p>
<p>1号进程是0号进程通过调用 kernel_thread() 创建的，在运行 schedule_preempt_disabled() 内的 schedule() 后，就启动调度器进行进程切换，kernel_init() 也就得以运行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kernel_thread</span>(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br></pre></td></tr></table></figure>
<p>kernel_init() 最后会启动用户态的处于根文件系统存储的 init 进程，从而实现 init 内核态到 init 用户态的转化。<br>init进程完成系统的初始化，是系统中所有其它用户进程的祖先进程。</p>
<h3 id="2号进程"><a href="#2号进程" class="headerlink" title="2号进程"></a>2号进程</h3><p>2号进程称为 kthreadd 进程，其 pid 等于2。<br>kthreadd进程由idle进程通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的创建。</p>
<p>kthreadd利用for(;;)一直驻留在内存中运行：主要过程如下：<br>检查kthread_create_list为空时，kthreadd让出cpu的执行权<br>kthread_create_list不为空时，利用while循环遍历kthread_create_list链表<br>每取下一个链表节点后调用create_kthread，创建内核线程</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/547263518240701.png"></p>
<p>kernel_thread()函数<strong>是通过调用do_fork()函数创建的线程，而do_fork()则是在应用层fork(), vfork()和clone()函数的系统调用</strong>；此外还需要在其执行函数里调用daemonize()进行资源的释放；该线程挂接在init进程下。<br>kthread_create()函数是通过工作队列workqueue创建的线程，此线程挂在kthreadd线程下。<br>kthread_run()函数本质上是调用了kthread_create()和wake_up_process(), 就是除了挂在工作队列上后，便唤醒进行工作。<br>kthread_create()是比较推崇的创建内核线程的方式。</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a><font color="red">写时复制</font></h3><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是<strong>只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong><br>该技术是依赖硬件MMU的，没有MMU，就不支持 fork，只支持vfork。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARCH_WANT_SYS_FORK</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE0</span>(fork)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">do_fork</span>(SIGCHLD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/* can not support in nommu mode */</span></span><br><span class="line">	<span class="keyword">return</span> -EINVAL;                    <span class="comment">//返回这个错误码需要被上层捕捉</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARCH_WANT_SYS_VFORK</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE0</span>(vfork)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">do_fork</span>(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>,</span><br><span class="line">			<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写时复制COW体现在这个函数中: copy_mm-&gt;dup_mm-&gt;dup_mmap-&gt;.......-&gt;copy_one_pte</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span></span></span><br><span class="line"><span class="function"><span class="title">copy_one_pte</span><span class="params">(<span class="keyword">struct</span> mm_struct *dst_mm, <span class="keyword">struct</span> mm_struct *src_mm,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">pte_t</span> *dst_pte, <span class="type">pte_t</span> *src_pte, <span class="keyword">struct</span> vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">int</span> *rss)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/95371510264876.png"></p>
<p><strong>exec函数(#include &lt;unistd.h&gt;)：</strong><br>装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务。exec系列函数在执行时会直接替换掉当前进程的地址空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char*)NULL*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char*)NULL*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char*)NULL, char *const envp[]*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间</li>
<li>如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</li>
<li>如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。</li>
</ul>
<p><strong>写时复制的应用</strong></p>
<ol>
<li><p>虚拟内存管理中的写时复制<br>一般把这种被共享访问的页面标记为只读。当一个task试图向内存中写入数据时，内存管理单元（MMU）抛出一个异常，内核处理该异常时为该task分配一份物理内存并复制数据到此内存，重新向MMU发出执行该task的写操作。</p>
</li>
<li><p>Linux的文件管理系统使用了写时复制策略。</p>
</li>
<li><p>[数据库]服务器也一般采用了写时复制策略，为用户提供一份snapshot。</p>
</li>
<li><p>软件应用中的写时复制<br>[C++标准程序库]中的[std::string]类，在C++98&#x2F;C++03标准中是允许写时复制策略。但在[C++11]标准中为了提高并行性取消了这一策略。 GCC从版本5开始，std::string不再采用COW策略。</p>
</li>
</ol>
<h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作，所以孤儿进程并不会有什么危害。</p>
<p>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<ul>
<li>父进程只管生成新的子进程，对子进程退出之后的事情，则一概不闻不问，系统运行一段时间后，系统中就会存在很多的僵死进程，用ps命令查看的话，就会看到很多状态为Z的进程。</li>
<li>僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的父进程。答案就是把产生大量僵死进程的那个元凶枪毙掉<mark>（通过kill发送SIGTERM或者SIGKILL信号）</mark></li>
<li>枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程（daemon）是后台运行的、系统启动是就存在的、不与任何终端关联的，用于处理一些系统级别任务的特殊进程。</p>
<h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ol>
<li>fork()创建子进程，父进程exit()退出；</li>
</ol>
<ul>
<li>由于守护进程是脱离控制终端的，完成这一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。</li>
<li>由于父进程先于子进程退出，子进程就变为孤儿进程，并由 init 进程作为其父进程收养。</li>
</ul>
<ol start="2">
<li>在子进程调用setsid()创建新会话；<br>在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变。这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来，摆脱其他进程的控制。</li>
</ol>
<p>setsid()创建一个新会话，调用进程担任新会话的首进程，其作用有：</p>
<ul>
<li>使当前进程脱离原会话的控制</li>
<li>使当前进程脱离原进程组的控制</li>
<li>使当前进程脱离原控制终端的控制</li>
</ul>
<ol start="3">
<li><p>在子进程中调用chdir()改变当前目录为根目录；<br>使用fork创建的子进程继承了父进程的当前工作目录。由于守护进程在后台运行，开始于系统开启，终止于系统关闭，所以要将其目录改为系统的根目录下。进程在执行时，其文件系统不能被卸下。</p>
</li>
<li><p>在子进程中调用umask()重设文件权限掩码为0；</p>
</li>
</ol>
<ul>
<li>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限</li>
<li>由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此把文件权限掩码重设为0即清除掩码（权限为777），这样可以大大增强该守护进程的灵活性。通常的使用方法为umask(0)。</li>
</ul>
<ol start="5">
<li>在子进程中close()不需要的文件描述符；</li>
</ol>
<ul>
<li>子进程从父进程那里继承了打开文件描述符。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。</li>
<li>在第二步之后，守护进程已经与控制终端失去了联系，终端输入的字符不可能达到守护进程，守护进程中用常规方法输出的字符也不可能在终端显示出来。所以，文件描述符为0、1和2 的3个文件（输入、输出和报错）已经失去了存在的价值，也应被关闭。</li>
</ul>
<ol start="6">
<li>守护进程退出处理<br>当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。</li>
</ol>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p><strong>程序段：</strong> 存放程序代码；<br><strong>数据段：</strong> 存放程序运行时使用、产生的运算数据，如全局变量、局部变量、宏定义的常量；<br><strong>PCB（task_struct）：</strong> 存放操作系统对程序进行管理所需的各种信息，如进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息。</p>
<h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h4><p>详细信息如下图：</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/416540910246114.png"></p>
<ul>
<li>代码段，包括<strong>二进制可执行代码</strong>；</li>
<li>数据段，包括<strong>已初始化的静态常量和全局变量</strong>；</li>
<li>BSS 段，包括<strong>未初始化的静态变量和全局变量</strong>；</li>
<li>堆段，包括动态分配的内存，<strong>从低地址开始向上增长</strong>；</li>
<li>文件映射段，包括动态库、共享内存等，<strong>从低地址开始向上增长</strong>（跟硬件和内核版本有关 (opens new window)）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。<strong>从低地址开始向下增长</strong>，栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/468791310252792.png"></p>
<p>虽然单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是并发。</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/114001410257831.png"></p>
<ul>
<li>创建状态（new）：进程正在被创建时的状态；</li>
<li>结束状态（Exit）：进程正在从系统中消失时的状态；</li>
<li>运行状态（Running）：该时刻进程占用 CPU；</li>
<li>就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行；</li>
<li>阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li>
</ul>
<h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p><strong>线程是进程当中的一条执行流程</strong>****</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/254071810259126.png"></p>
<ul>
<li>同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，</li>
<li>但每个线程各自都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的</li>
</ul>
<h4 id="线程共享的环境"><a href="#线程共享的环境" class="headerlink" title="线程共享的环境"></a>线程共享的环境</h4><p>包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<h4 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h4><ul>
<li>一个进程中可以同时存在多个线程；</li>
<li>各个线程之间可以并发执行；</li>
<li>各个线程之间可以共享地址空间和文件等资源；</li>
</ul>
<h4 id="线程的缺点"><a href="#线程的缺点" class="headerlink" title="线程的缺点"></a>线程的缺点</h4><p>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C&#x2F;C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）。<br>举个例子，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。</p>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；<br>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</p>
<h4 id="三种线程的实现⽅式"><a href="#三种线程的实现⽅式" class="headerlink" title="三种线程的实现⽅式"></a>三种线程的实现⽅式</h4><ul>
<li>⽤户线程（User Thread）：在⽤户空间实现的线程，不是由内核管理的线程，是由⽤户态的线程库来完成线程的管理；</li>
<li>内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；</li>
<li>轻量级进程（LightWeight Process）：在内核中来⽀持⽤户线程；</li>
</ul>
<h5 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h5><p>用户线程的整个线程管理和调度，操作系统是不直接参与的，⽽是由⽤户级线程库函数来完成线程的管理，包括线程的创建、终⽌、同步和调度等。</p>
<p>⽤户线程的优点：</p>
<ul>
<li>每个进程都需要有它私有的线程控制块（TCB）列表，⽤来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由⽤户级线程库函数来维护，可⽤于不⽀持线程技术的操作系统</li>
<li>⽤户线程的切换也是由线程库函数来完成的，⽆需⽤户态与内核态的切换，所以速度特别快；</li>
</ul>
<p>⽤户线程的缺点：</p>
<ul>
<li>由于操作系统不参与线程的调度，如果⼀个线程发起了系统调⽤⽽阻塞，那进程所包含的⽤户线程都不能执⾏了。</li>
<li>当⼀个线程开始运⾏后，除⾮它主动地交出 CPU 的使⽤权，否则它所在的进程当中的其他线程⽆法运⾏，因为⽤户态的线程没法打断当前运⾏中的线程，它没有这个特权，只有操作系统才有，但是⽤户线程不是由操作系统管理的。</li>
<li>由于时间⽚分配给进程，故与其他进程⽐，在多线程执⾏时，每个线程得到的时间⽚较少，执⾏会⽐较慢；</li>
</ul>
<h5 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h5><p>内核线程是由操作系统管理的，线程对应的 TCB ⾃然是放在操作系统⾥的，这样线程的创建、终⽌和管理都是由操作系统负责。</p>
<p>内核线程的优点：</p>
<ul>
<li>在⼀个进程当中，如果某个内核线程发起系统调⽤⽽被阻塞，并不会影响其他内核线程的运⾏；</li>
<li>分配给线程，多线程的进程获得更多的 CPU 运⾏时间；</li>
</ul>
<p>内核线程的缺点：</p>
<ul>
<li>在⽀持内核线程的操作系统中，由内核来维护进程和线程的上下⽂信息，如 PCB 和TCB；</li>
<li>线程的创建、终⽌和切换都是通过系统调⽤的⽅式来进⾏，因此对于系统来说，系统开销⽐较⼤；</li>
</ul>
<h5 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h5><p>轻量级进程（LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。<br>轻量级进程通常共享相同的地址空间，但具有独立的堆栈和寄存器状态，从而实现了类似进程的隔离和并发执行。<br>LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息</p>
<h3 id="线程与进程的⽐较"><a href="#线程与进程的⽐较" class="headerlink" title="线程与进程的⽐较"></a>线程与进程的⽐较</h3><ol>
<li>进程是资源（包括内存、打开的⽂件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执⾏的时间和空间开销；</li>
</ol>
<h3 id="线程相⽐进程能减少开销"><a href="#线程相⽐进程能减少开销" class="headerlink" title="线程相⽐进程能减少开销"></a>线程相⽐进程能减少开销</h3><ul>
<li>线程的创建时间⽐进程快，因为进程在创建的过程中，还需要资源管理信息，⽐如内存管理信息、⽂件管理信息，⽽线程在创建的过程中，不会涉及这些资源管理信息，⽽是共享它们；</li>
<li>线程的终⽌时间⽐进程快，因为线程释放的资源相⽐进程少很多；</li>
<li>同⼀个进程内的线程切换⽐进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同⼀个进程的线程都具有同⼀个⻚表，在切换的时候不需要切换⻚表。⽽进程之间切换的时候要把⻚表给切换掉，⻚表的切换过程开销是⽐较⼤的；</li>
<li>由于同⼀进程的各线程间共享内存和⽂件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更⾼了；</li>
</ul>
<h3 id="多线程和多进程的比较"><a href="#多线程和多进程的比较" class="headerlink" title="多线程和多进程的比较"></a>多线程和多进程的比较</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2429254083522.png"></p>
<ol>
<li>需要频繁创建销毁的优先用线程。<br>实例：web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。</li>
<li>需要进行大量计算的优先使用线程。<br>所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的。实例：图像处理、算法处理</li>
<li>强相关的处理用线程，若相关的处理用进程。<br>一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。</li>
<li>可能扩展到多机分布的用进程，多核分布的用线程。</li>
</ol>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程可以理解为用户态的轻量级的非抢占式的线程。可以在程序的某个点挂起，并在稍后恢复执行</p>
<p><strong>原理：</strong></p>
<ul>
<li>我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。</li>
<li>当线程数量非常多的时候，却产生了问题。一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</li>
<li>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<mark>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</mark>，</li>
</ul>
<p><strong>特点：</strong><br>用户态:协程是在用户态实现调度。<br>轻量级:协程不用内核调度，不被被操作系统内核所管理，不需要内核态与用户态之间切换。<br>非抢占:协程是由用户自己实现调度，并且同一时间只能有一个协程在执行，协程自己主动交出CPU的。</p>
<p><strong>优点：</strong><br>协程切换的时候开销小，用户态且轻量<br>非抢占式，不用加很多锁，减小复杂度，不用很复杂的处理线程同步问题。</p>
<p><strong>缺点：</strong><br>协程可以在单线程内处理高并发,但是协程不能同时使用单个CPU的多个核心，不能利用多核，只能使用单核。<br>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，操作系统会让线程进入阻塞状态，<mark>当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度</mark>，这往往是不能接受的。因此，<strong>协程只有和异步IO结合起来才能发挥出最大的威力。</strong></p>
<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>所谓的管道，就是内核里面的一串缓存，所谓的管道，就是内核里面的一串缓存</p>
<h4 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>fd[0]为读而打开，fd[1]为写而打开</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/312724210260128.png"></p>
<p>使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符，但是管道只能一端写入，另一端读出，所以这种模式容易造成混乱，需要：<br>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；<br>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/206554310260305.png">                   <strong>关闭后变为-&gt;</strong>        <img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/345674310245857.png"></p>
<p><strong>执行A | B发生了什么</strong><br>A进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。<br><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/291044710262136.png"></p>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><p>也被叫做 FIFO ，因为数据是先进先出的传输⽅式。在使⽤命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkfifo</span> myPipe</span><br></pre></td></tr></table></figure>
<p>myPipe 就是这个管道的名称，基于 Linux ⼀切皆⽂件的理念，所以管道也是以⽂件的⽅式存在，我们可以⽤ ls 看⼀下，这个⽂件的类型是 p，也就是 pipe（管道） 的意思：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">prw-r--r--. 1 root root 0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure>

<p>管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才⾏。管道这种通信⽅式效率低，不适合进程间频繁地交换数据。    </p>
<ul>
<li>对于匿名管道，<strong>它的通信范围是存在⽗⼦关系的进程</strong>。因为管道没有实体，也就是没有管道⽂件，只能通过 fork 来复制⽗进程 fd ⽂件描述符，来达到通信的⽬的。</li>
<li>对于命名管道，<strong>它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了⼀个类型为管道的设备⽂件，在进程⾥只要使⽤这个设备⽂件，就可以相互通信。</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">msgget</span>();</span><br></pre></td></tr></table></figure>
<p><mark>消息队列是保存在内核中的消息链表，</mark>消息队列不适合⽐较⼤数据的传输，<br><mark>消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销</mark>，因为进程写⼊数据到内核中的消息队列时，会发⽣从⽤户态拷⻉数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态拷⻉数据到⽤户态的过程。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shmget</span>();</span><br></pre></td></tr></table></figure>
<p>多个进程将同一个文件（内存的匿名段）映射到它们的地址空间<br>共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中。<br><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/98108102469.png"></p>
<h4 id="存储映射I-O（mmap）"><a href="#存储映射I-O（mmap）" class="headerlink" title="存储映射I&#x2F;O（mmap）"></a><font color="red">存储映射I&#x2F;O（mmap）</font></h4><p>mmap将一个文件或者其它对象映射进内存上<br>mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。在要求高性能的应用中比较常用。mmap映射内存必须是页面大小的整数倍，面向流的设备不能进行mmap，mmap的实现和硬件有关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> len,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> off)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4064114819868.png"></p>
<ul>
<li>两个进程中通信<br>两个程序映射同一个文件到自己的地址空间, 进程A先运行, 每隔两秒读取映射区域, 看是否发生变化. 进程B后运行, 它修改映射区域, 然后推出, 此时进程A能够观察到存储映射区的变化。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> fd, nread, i;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sb;  </span><br><span class="line">    <span class="type">char</span> *mapped, buf[BUF_SIZE];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;  </span><br><span class="line">        buf[i] = <span class="string">&#x27;#&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 打开文件 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">fstat</span>(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fstat&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 将文件映射至进程的地址空间 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, sb.st_size, PROT_READ |   </span><br><span class="line">                    PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 文件已在内存, 关闭文件也可以操纵内存 */</span>  </span><br><span class="line">    <span class="built_in">close</span>(fd);  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程A：每隔两秒查看存储映射区是否被修改 */</span>  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mapped);  </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程B：修改一个字符 */</span>  </span><br><span class="line">    mapped[<span class="number">20</span>] = <span class="string">&#x27;9&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">semget</span>();</span><br></pre></td></tr></table></figure>
<p>信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。</p>
<p>信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：</p>
<ul>
<li>⼀个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使⽤，进程可正常继续执⾏。</li>
<li>⼀个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将阻塞的进程唤醒运⾏；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/595705014240451.png"></p>
<ul>
<li><strong>信号初始化为 1 ，就代表着是互斥信号量</strong>，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存<br>进程 A 在访问共享内存前，先执⾏了 P 操作，由于信号量的初始值为 1，故在进程 A 执 ⾏ P 操作后信号量变为 0，表示共享资源可⽤，于是进程 A 就可以访问共享内存。<br>若此时，进程 B 也想访问共享内存，执⾏了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占⽤，因此进程 B 被阻塞。<br>直到进程 A 访问完共享内存，才会执⾏ V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执⾏ V 操作，使信号量恢复到初始值 1。</li>
</ul>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/290185114258877.png"></p>
<ul>
<li><strong>信号初始化为 0 ，就代表着是同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执⾏。<br>如果进程 B ⽐进程 A 先执⾏了，那么执⾏到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没⽣产数据，于是进程 B 就阻塞等待；<br>接着，当进程 A ⽣产完数据后，执⾏了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；<br>最后，进程 B 被唤醒后，意味着进程 A 已经⽣产了数据，于是进程 B 就可以正常读取数据了。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>对于异常情况下的⼯作模式，就需要⽤「信号」的⽅式来通知进程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5)SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10)SIGUSR1</span><br><span class="line">11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15)SIGTERM</span><br><span class="line">16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20)SIGTSTP</span><br><span class="line">21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25)SIGXFSZ</span><br><span class="line">26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30)SIGPWR</span><br><span class="line">31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37)SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42)SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47)SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52)SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57)SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62)SIGRTMAX-2</span><br></pre></td></tr></table></figure>
<p>Ctrl+C 产⽣ SIGINT（2） （可被忽略）信号，表示终⽌该进程；<br>Ctrl+Z 产⽣ SIGTSTOP（19） 信号，表示挂起该进程，但还未结束；</p>
<p><strong>唯⼀的异步通信机制</strong>。进程有三种⽅式响应信号 1. 执⾏默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应⽤进程<mark>⽆法捕捉和忽略</mark>的，即<mark>SIGKILL（9） 和 SEGSTOP（19） </mark>，这是为了⽅便我们能在任何时候结束或停⽌某个进程</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>TCP网络编程<br><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4171516095354.png"></p>
<ul>
<li>服务端和客户端初始化 socket ，得到⽂件描述符；</li>
<li>服务端调⽤ bind ，将绑定在 IP 地址和端⼝;</li>
<li>服务端调⽤ listen ，进⾏监听；</li>
<li>服务端调⽤ accept ，等待客户端连接；</li>
<li>客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；</li>
<li>服务端 accept 返回⽤于传输的 socket 的⽂件描述符；</li>
<li>客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；</li>
<li>客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭</li>
</ul>
<h2 id="线程的同步与互斥"><a href="#线程的同步与互斥" class="headerlink" title="线程的同步与互斥"></a>线程的同步与互斥</h2><p><strong>如果要访问共享资源（内存，变量等），必须考虑互斥</strong>，保证一个线程在临界区执行时，其他线程应该被阻止进入</p>
<h3 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h3><p>pthread_mutex_******<br>确保同一时间只有一个线程访问数据</p>
<h3 id="读写锁（共享互斥锁）"><a href="#读写锁（共享互斥锁）" class="headerlink" title="读写锁（共享互斥锁）"></a>读写锁（共享互斥锁）</h3><p>pthread_rwlock_******<br>一次只有一个线程可以占有写模式的读写锁，多个线程可以同时占有读模式的读写锁</p>
<ul>
<li>写加锁状态时，所有试图对这个锁加锁的线程都会被阻塞</li>
<li>读加锁状态时，所有试图以读模式对它加锁的线程都可以得到访问权，所有试图以写模式对它加锁的线程都会阻塞</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>pthread_cond_******</p>
<ul>
<li>条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。</li>
<li>条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</li>
<li>传递给pthread_cond_wait的<mark>互斥量对条件变量进行保护</mark>。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>pthread_spin_******</p>
<ul>
<li>互斥锁加锁失败后，线程会释放 CPU ，给其他线程；</li>
<li>⾃旋锁加锁失败后，线程会忙等待，直到它拿到锁；</li>
<li>当加锁失败时，互斥锁⽤「线程切换」来应对，⾃旋锁则⽤「忙等待」来应对</li>
<li>在单核CPU 上，需要抢占式的调度器（即不断通过时钟中断⼀个线程，运⾏其他线程）。否则，⾃旋锁在单 CPU 上⽆法使⽤，因为⼀个⾃旋的线程永远不会放弃 CPU。</li>
</ul>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>pthread_barrier_******<br>是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。<br>但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。</p>
<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>P、V 操作，见上文信号量</p>
<h3 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h3><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><p>互斥条件；互斥条件是指多个线程不能同时使⽤同⼀个资源。<br>持有并等待条件； 一个进程本身占有资源（一种或多种），同时还有资源未得到满足，等待其他进程释放该资源。<br>不可剥夺条件；当线程已经持有了资源 ，在⾃⼰使⽤完之前不能被其他线程获取，<br>环路等待条件；在死锁发⽣的时候，两个线程获取资源的顺序构成了环形链。</p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>确保系统永远不会进入死锁状态<br><mark>a、破坏“占有且等待”条件</mark></p>
<ol>
<li>所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。</li>
<li>允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。</li>
</ol>
<p><mark>b、破坏“不可抢占”条件</mark><br>当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。</p>
<p><mark>c、破坏“循环等待”条件</mark><br> 可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。<br>两种避免办法：<br>    1、如果一个进程的请求会导致死锁，则不启动该进程<br>    2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。</p>
<p>避免死锁的具体实现通常利用<strong>银行家算法</strong><br>可利用资源向量Available：用于表示系统里边各种资源剩余的数目。<br>最大需求矩阵Max：用于表示各个进程对各种资源的额最大需求量。<br>分配矩阵Allocation：就是用于表示已经分配给各个进程的各种资源的数目。也是一个nxm的矩阵。<br>需求矩阵Need：用于表示进程仍然需要的资源数目，用一个nxm的矩阵表示。</p>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>方案一：<br>让偶数编号的哲学家「先拿左边的叉⼦后拿右边的叉⼦」，奇数编号的哲学家「先拿右边的叉⼦后拿左边的叉⼦」。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2239037095963.png"></p>
<p>方案二：<br>用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。第 i 个哲学家的左邻右舍，则由宏 LEFT 和 RIGHT 定义：<br>LEFT : ( i + 5 - 1 ) % 5<br>RIGHT : ( i + 1 ) % 5<br>比如 i 为 2，则 LEFT 为 1，RIGHT 为 3。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/283411416246744.png"></p>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><ol>
<li>悲观锁做事⽐较悲观，它认为多线程同时修改共享资源的概率⽐较⾼，于是很容易出现冲突，所以访问共享资源前，先要上锁。</li>
<li>乐观锁做事⽐较乐观，它假定冲突的概率很低，先修改完共享资源，再验证这段时间内有没有发⽣冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。<br>应用：在线文档多人编辑</li>
</ol>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="调度的原则"><a href="#调度的原则" class="headerlink" title="调度的原则"></a>调度的原则</h2><ul>
<li>CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li>
<li>系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li>
<li>周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；</li>
<li>等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li>
<li>响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h3><h3 id="最短作业优先调度算法"><a href="#最短作业优先调度算法" class="headerlink" title="最短作业优先调度算法"></a>最短作业优先调度算法</h3><h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4947119118995.png"></p>
<p>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应⽐」就越⾼，这样短作业的进程容易被选中运⾏；<br>如果两个进程「要求的服务时间」相同时，「等待时间」越⻓，「响应⽐」就越⾼，这就兼顾到了⻓作业进程，因为进程的响应⽐可以随时间等待的增加⽽提⾼，当其等待时间⾜够⻓时，其响应⽐便可以升到很⾼，从⽽获得运⾏的机会；</p>
<h3 id="时间⽚轮转调度算法"><a href="#时间⽚轮转调度算法" class="headerlink" title="时间⽚轮转调度算法"></a>时间⽚轮转调度算法</h3><p>如果时间⽚设得太短会导致过多的进程上下⽂切换，降低了 CPU 效率；如果设得太⻓⼜可能引起对短作业进程的响应时间变⻓。</p>
<h3 id="最⾼优先级调度算法"><a href="#最⾼优先级调度算法" class="headerlink" title="最⾼优先级调度算法"></a>最⾼优先级调度算法</h3><p>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运⾏时间优先级都不会变化；<br>动态优先级：根据进程的动态变化调整优先级，如果进程运⾏时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升⾼其优先级，也就是随着时间的推移增加等待进程的优先级。<br>⾮抢占式：当就绪队列中出现优先级⾼的进程，运⾏完当前进程，再选择优先级⾼的进程。<br>抢占式：当就绪队列中出现优先级⾼的进程，当前进程挂起，调度优先级⾼的进程运⾏。<br>但是依然有缺点，可能会导致低优先级的进程永远不会运⾏。</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5290937106862.png"></p>
<p>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从⾼到低，同时优先级越⾼时间⽚越短；新的进程会被放⼊到第⼀级队列的末尾，按先来先服务的原则排队等待被调度，如果在第⼀级队列规定的时间⽚没运⾏完成，则将其转⼊到第⼆级队列的末尾，以此类推，直⾄完成；<br>当较⾼优先级的队列为空，才调度较低优先级的队列中的进程运⾏。如果进程运⾏时，有新进程进⼊较⾼优先级的队列，则停⽌当前运⾏的进程并将其移⼊到原队列末尾，接着让较⾼优先级的进程运⾏；</p>
<h2 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h2><h3 id="最佳⻚⾯置换算法"><a href="#最佳⻚⾯置换算法" class="headerlink" title="最佳⻚⾯置换算法"></a>最佳⻚⾯置换算法</h3><p>最佳⻚⾯置换算法基本思路是，置换在「未来」最⻓时间不访问的⻚⾯。</p>
<h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><p>既然我们⽆法预知⻚⾯在下⼀次访问前所需的等待时间，那我们可以选择在内存驻留时间很⻓的⻚⾯进⾏中置换，这个就是「先进先出置换」算法的思想</p>
<h3 id="最近最久未使⽤的置换算法"><a href="#最近最久未使⽤的置换算法" class="headerlink" title="最近最久未使⽤的置换算法"></a>最近最久未使⽤的置换算法</h3><p>最近最久未使⽤（LRU）的置换算法的基本思路是，发⽣缺⻚时，选择最⻓时间没有被访问的⻚⾯进⾏置换，</p>
<h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><p>像浏览器的缓存策略、memcached的缓存策略都是使用LRU这个算法，LRU算法会将近期最不会访问的数据淘汰掉。<br><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1128100686625.png"></p>
<ul>
<li>新数据插入到链表头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>当链表满的时候，将链表尾部的数据丢弃</li>
</ul>
<p>LRU Cache具备的操作：<br>set(key,value)：如果key在hashmap中存在，则先重置对应的value值，然后获取对应的节点cur，将cur节点从链表删除，并移动到链表的头部；若果key在hashmap不存在，则新建一个节点，并将节点放到链表的头部。当Cache存满的时候，将链表最后一个节点删除即可。<br>get(key)：如果key在hashmap中存在，则把对应的节点放到链表头部，并返回对应的value值；如果不存在，则返回-1。</p>
<p>LRU的c++实现：<br>LRU实现采用双向链表 + Map 来进行实现。这里采用双向链表的原因是：如果采用普通的单链表，则删除节点的时候需要从表头开始遍历查找，效率为O(n)，采用双向链表可以直接改变节点的前驱的指针指向进行删除达到O(1)的效率。使用Map来保存节点的key、value值便于能在O(logN)的时间查找元素,对应get操作。</p>
<p>双链表节点的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CacheNode</span> &#123;</span><br><span class="line"> <span class="type">int</span> key;  <span class="comment">// 键</span></span><br><span class="line"> <span class="type">int</span> value; <span class="comment">// 值</span></span><br><span class="line"> CacheNode *pre, *next; <span class="comment">// 节点的前驱、后继指针</span></span><br><span class="line"> <span class="built_in">CacheNode</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">pre</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于LRUCache这个类而言，构造函数需要指定容量大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LRUCache</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"> size = capacity;  <span class="comment">// 容量</span></span><br><span class="line"> head = <span class="literal">NULL</span>;   <span class="comment">// 链表头指针</span></span><br><span class="line"> tail = <span class="literal">NULL</span>;   <span class="comment">// 链表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双链表的节点删除操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(CacheNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (node -&gt; pre != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> head = node -&gt; next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (node -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> tail = node -&gt; pre;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将节点插入到头部的操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHead</span><span class="params">(CacheNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> node -&gt; next = head;</span><br><span class="line"> node -&gt; pre = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> head -&gt; pre = node;</span><br><span class="line"> &#125;</span><br><span class="line"> head = node;</span><br><span class="line"> <span class="keyword">if</span> (tail == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> tail = head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(key)操作的实现比较简单，直接通过判断Map是否含有key值即可，如果查找到key，则返回对应的value，否则返回-1;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> map&lt;<span class="type">int</span>, CacheNode *&gt;::iterator it = mp.<span class="built_in">find</span>(key);</span><br><span class="line"> <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> CacheNode *node = it -&gt; second;</span><br><span class="line"> <span class="built_in">remove</span>(node);</span><br><span class="line"> <span class="built_in">setHead</span>(node);</span><br><span class="line"> <span class="keyword">return</span> node -&gt; value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set(key, value)操作需要分情况判断。如果当前的key值对应的节点已经存在，则将这个节点取出来，并且删除节点所处的原有的位置，并在头部插入该节点；如果节点不存在节点中，这个时候需要在链表的头部插入新节点，插入新节点可能导致容量溢出，如果出现溢出的情况，则需要删除链表尾部的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> map&lt;<span class="type">int</span>, CacheNode *&gt;::iterator it = mp.<span class="built_in">find</span>(key);</span><br><span class="line"> <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> CacheNode *node = it -&gt; second;</span><br><span class="line"> node -&gt; value = value;</span><br><span class="line"> <span class="built_in">remove</span>(node);</span><br><span class="line"> <span class="built_in">setHead</span>(node);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> CacheNode *newNode = <span class="keyword">new</span> <span class="built_in">CacheNode</span>(key, value);</span><br><span class="line"> <span class="keyword">if</span> (mp.<span class="built_in">size</span>() &gt;= size)</span><br><span class="line"> &#123;</span><br><span class="line">  map&lt;<span class="type">int</span>, CacheNode *&gt;::iterator iter = mp.<span class="built_in">find</span>(tail -&gt; key);</span><br><span class="line">  <span class="built_in">remove</span>(tail);</span><br><span class="line">  mp.<span class="built_in">erase</span>(iter);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">setHead</span>(newNode);</span><br><span class="line"> mp[key] = newNode;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时钟⻚⾯置换算法"><a href="#时钟⻚⾯置换算法" class="headerlink" title="时钟⻚⾯置换算法"></a>时钟⻚⾯置换算法</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5742525189098.png"></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1333708746621.png"></p>
<h3 id="最不常⽤算法"><a href="#最不常⽤算法" class="headerlink" title="最不常⽤算法"></a>最不常⽤算法</h3><p>当发⽣缺⻚中断时，选择「访问次数」最少的那个⻚⾯，并将其淘汰。</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h3><h3 id="最短寻道时间优先算法"><a href="#最短寻道时间优先算法" class="headerlink" title="最短寻道时间优先算法"></a>最短寻道时间优先算法</h3><p>根据距离磁头最近的请求的算法</p>
<h3 id="扫描算法（电梯算法）"><a href="#扫描算法（电梯算法）" class="headerlink" title="扫描算法（电梯算法）"></a>扫描算法（电梯算法）</h3><p>磁头在⼀个⽅向上移动，访问所有未完成的请求，直到磁头到达该⽅向上的最后的磁道，才调换⽅向，这就是扫描（Scan）算法。<br><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5363799515717.png"></p>
<h3 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h3><p>只有磁头朝某个特定⽅向移动时，才处理磁道访问请求，⽽返回时直接快速移动⾄最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应⼀个⽅向上的请求。<br><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3568121535713.png"><br>循环扫描算法相⽐于扫描算法，对于各个位置磁道响应频率相对⽐较平均。</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>一切皆文件</p>
<h2 id="Linux的文件类型"><a href="#Linux的文件类型" class="headerlink" title="Linux的文件类型"></a>Linux的文件类型</h2><ol>
<li>普通文件<br>普通文件根据存放的内容的不同，又分为如下两种：</li>
</ol>
<ul>
<li><p>文本文件<br>存放的都是文字编码，文本编辑器打开后，会将这些文字编码翻译为文字图形，以供人识别。</p>
</li>
<li><p>纯二进制文件（机器码）</p>
</li>
<li><p><input disabled type="checkbox"> 
比如经过编译后得到的可执行文件，里面放的是cpu执行的纯二进制机器码，由于文编编辑器只认识文字编码，所以用文本编辑器打开后，显示的内容无法是错乱的，无法辨识。命令cat就是一个二进制文件</p>
</li>
<li><p><input disabled type="checkbox"> 
其实不管存放的是文字编码，还是机器码，在计算机中存储时，其实都是以二进制形式存放的，只不过我们这里可刻意的把机器码这类非文字编码的数据，特意强调为了二进制数据。</p>
</li>
<li><p><input disabled type="checkbox"> 
对linux内核而言，这两种文件并无区别，至于文件中的数据如何解释，则由处理这些数据的应用程序（比如文本编辑器）来决定。</p>
</li>
<li><p><input disabled type="checkbox"> 
不管是文字编码数据，还是纯二进制数据，应用程序调用read、write读写文件时，没有任何区别。</p>
</li>
</ul>
<ol start="2">
<li>目录文件<br>目录是一种特殊的文件，专门用于管理其它文件。第一个属性为 [d]，例如 [drwxrwxrwx]。</li>
<li>字符设备文件<br>字符设备文件，就是字符设备驱动程序，在上层的表现形式。<br>当应用程序调用底层字符设备驱动程序，实现对某个字符设备进行读写时，上层就需要对接底层的字符驱动程序，字符设备驱动在上层，会以“字符设备文件”的形式表现出来，我们通过open、read、write去读写字符设备文件，就实现了和底层字符设备驱动程序的交互。</li>
<li>块设备文件<br>对应块设备（如磁盘等）。<br>块设备文件，是块设备驱动程序在上层的表现形式。</li>
</ol>
<ul>
<li><mark>字符设备与块设备有什么区别？</mark><br>（a）字符设备<br>以字节为单位来操作数据。<br>比如：键盘、鼠标、显示器都等是字符设备。<br>（b）块设备<br>块设备存储的数据量往往非常大，为了提高读写效率，都是以块（1024字节）为单位来操作数据。<br>比如：电脑硬盘、移动硬盘、u盘等，凡是涉及大量数据存储的，都是以块为单位来操作数据的，都是块设备。</li>
</ul>
<ol start="5">
<li>FIFO（fifo：p）<br>管道文件，用于实现不同进程（程序）之间的通信，管道是OS提供的一种纯代码层面的通信机制。<br>A进程 ————————&gt; 管道文件 ————————&gt;B进程</li>
<li>套接字文件（socket：s）<br>专门用于网络通信的文件。</li>
</ol>
<h2 id="文件的管理"><a href="#文件的管理" class="headerlink" title="文件的管理"></a>文件的管理</h2><p>索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。<br>目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。</strong></p>
<p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，Linux 读写逻辑块，逻辑块大小为 4KB，也就是一次性读写 8 个扇区。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/503013809240452.png"></p>
<p>磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。</p>
<ul>
<li>超级块：用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。当文件系统挂载时进入内存。</li>
<li>索引节点区：用来存储索引节点；当文件被访问时进入内存</li>
<li>数据块区：用来存储文件或目录数据；</li>
</ul>
<h2 id="文件的存放方式"><a href="#文件的存放方式" class="headerlink" title="文件的存放方式"></a>文件的存放方式</h2><p>连续空间存放方式<br>缺陷：「磁盘空间碎片」和「文件长度不易扩展」</p>
<p>非连续空间存放方式：「链表方式」和「索引方式」</p>
<p>「隐式链表」的方式存放<br>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置，</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/104654809258878.png"></p>
<p>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间。隐式链接分配的稳定性较差，系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失</p>
<p>「显式链接」的方式存放<br>它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘仅设置一张，每个表项中存放链接指针，指向下一个数据块号。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/280175009246745.png"></p>
<p>缺点是不适用于大磁盘</p>
<p>「索引方式」</p>
<p>单索引</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/552165409256135.png"></p>
<p>链表 + 索引</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/437125409259580.png"></p>
<p>多级索引块</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/60975509251889.png"></p>
<h2 id="Unix和Linux-Ext-2-3"><a href="#Unix和Linux-Ext-2-3" class="headerlink" title="Unix和Linux Ext 2&#x2F;3"></a>Unix和Linux Ext 2&#x2F;3</h2><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/144745809269769.png"></p>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>适用于建立连续文件</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/527295909267373.png"></p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/145370110264875.png"></p>
<h3 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h3><p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，</p>
<p>「位图 + 数据」<br>每位表示一个数据块，共可以表示 4 * 1024 * 8 &#x3D; 2^15 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 2^15 * 4 * 1024 &#x3D; 2^27 个 byte，也就是 128M。表示的大小过少，Linux使用块组结构</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/594342710246116.png"></p>
<ul>
<li>超级块，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>
<li>块组描述符，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>
<li>数据位图和 inode 位图， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>
<li>inode 列表，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>
<li>数据块，包含文件的有用数据。</li>
</ul>
<p>超级块和块组描述符表，这两个都是全局信息，而且非常的重要，这么做是有两个原因：<br>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。<br>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</p>
<h2 id="目录的管理"><a href="#目录的管理" class="headerlink" title="目录的管理"></a>目录的管理</h2><p>目录文件的块里面保存的是目录里面一项一项的文件信息。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/301453410268556.png"></p>
<h2 id="软链接-ln-s-和硬链接-ln-d）"><a href="#软链接-ln-s-和硬链接-ln-d）" class="headerlink" title="软链接(ln -s)和硬链接(ln -d）"></a>软链接(ln -s)和硬链接(ln -d）</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p> 多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode。<strong>每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/366183610263692.png"></p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/234184310240902.png" alt="软链接"></p>
<h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I&#x2F;O"></a><font color="red">文件I&#x2F;O</font></h2><h3 id="缓冲与非缓冲-I-O"><a href="#缓冲与非缓冲-I-O" class="headerlink" title="缓冲与非缓冲 I&#x2F;O"></a>缓冲与非缓冲 I&#x2F;O</h3><p>文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲 I&#x2F;O：</p>
<ul>
<li>缓冲 I&#x2F;O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li>
<li>非缓冲 I&#x2F;O，直接通过系统调用访问文件，不经过标准库缓存。<br>这里所说的「缓冲」特指标准库内部实现的缓冲。</li>
</ul>
<p>例如，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p>
<h3 id="直接与非直接-I-O"><a href="#直接与非直接-I-O" class="headerlink" title="直接与非直接 I&#x2F;O"></a>直接与非直接 I&#x2F;O</h3><p>我们都知道磁盘 I&#x2F;O 是非常慢的，所以 Linux 内核为了减少磁盘 I&#x2F;O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，<strong>这个内核缓存空间也就是「页缓存」（page cache），只有当缓存满足某些条件的时候，才发起磁盘 I&#x2F;O 的请求。</strong></p>
<p>那么，根据是「否利用操作系统的缓存」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O：</p>
<p>直接 I&#x2F;O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。<br>非直接 I&#x2F;O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</p>
<p><strong>非直接I&#x2F;O下，什么时候刷盘？</strong></p>
<ol>
<li>在调用 write 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li>
<li>用户主动调用 sync，内核缓存会刷到磁盘上；</li>
<li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li>
<li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li>
</ol>
<h3 id="阻塞与非阻塞I-O"><a href="#阻塞与非阻塞I-O" class="headerlink" title="阻塞与非阻塞I&#x2F;O"></a>阻塞与非阻塞I&#x2F;O</h3><p>阻塞等待的是<strong>内核数据准备好</strong> 和 <strong>数据从内核态拷贝到用户态</strong>这两个过程</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/422510511240452.png"></p>
<p>非阻塞 I&#x2F;O，非阻塞的 read 请求在数据未准备好的情况下<strong>立即返回，可以继续往下执行</strong>，此时应用程序不断<strong>轮询内核</strong>，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。<br>最后一次 read 调用，获取数据的过程，<strong>是一个同步的过程，是需要等待的过程</strong>。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/253940811258878.png"></p>
<h3 id="同步与异步-I-O"><a href="#同步与异步-I-O" class="headerlink" title="同步与异步 I&#x2F;O"></a>同步与异步 I&#x2F;O</h3><p>使用 select I&#x2F;O 多路复用过程。注意，read 获取数据的过程（数据从内核态拷贝到用户态的过程），也是<strong>一个同步的过程</strong>，需要等待</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/375061511246745.png"></p>
<p>是否阻塞一般指的是进程、线程状态，是否异步一般指的是是否依赖其它任务已经完成</p>
<ul>
<li>如果这个进程、线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞；</li>
<li>如果这个进程、线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞；</li>
</ul>
<p>所以，<strong>阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用都是同步调用</strong>。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</p>
<p>异步I&#x2F;O：</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/421221711266911.png"></p>
<h3 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h3><p>信号驱动式I&#x2F;O是指进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。当数据报到达时触发SIGIO信号，该信号通知数据已经到来，并没有将数据都入到应用程序的buffer中。因此，还需要我们在SIGIO信号处理函数中，手动的读取到来的数据，将其存放在buffer中。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4626434545792.png"></p>
<p><strong>总结</strong></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5077935819947.png"></p>
<h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p>非直接I&#x2F;O中，内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。</p>
<p>当然， 我们也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/meminfo</span><br><span class="line"></span><br><span class="line">Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached</span><br></pre></td></tr></table></figure>
<p>Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。</p>
<h3 id="文件持久化的一致性-可靠性"><a href="#文件持久化的一致性-可靠性" class="headerlink" title="文件持久化的一致性&amp;可靠性"></a>文件持久化的一致性&amp;可靠性</h3><p>当前 Linux 下以两种方式实现文件一致性：</p>
<p>Write Through（写穿）：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；<br>Write back（写回）：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fsync(intfd)</td>
<td align="center">fsync(fd)：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。</td>
</tr>
<tr>
<td align="center">fdatasync(int fd)</td>
<td align="center">fdatasync(fd)：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息</td>
</tr>
<tr>
<td align="center">sync()</td>
<td align="center">sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中</td>
</tr>
</tbody></table>
<ul>
<li>关于多线程的架构问题，Linux 内核采取了 Lighthttp 的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。</li>
<li>管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。</li>
<li>而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。</li>
</ul>
<p>刷新线程刷新设备上脏页面大致设计如下：<br>每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；</p>
<p>系统中存在多个回写时机:</p>
<ol>
<li>第一是应用程序主动调用回写接口（fsync，fdatasync 以及 sync 等）</li>
<li>第二管理线程周期性地唤醒设备上的回写线程进行回写</li>
<li>第三是某些应用程序&#x2F;内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要。</li>
</ol>
<h2 id="Swap详解"><a href="#Swap详解" class="headerlink" title="Swap详解"></a>Swap详解</h2><p>操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为<strong>缺页中断</strong>，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。</p>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/106675315259580.png"></p>
<h2 id="I-O-控制⽅式"><a href="#I-O-控制⽅式" class="headerlink" title="I&#x2F;O 控制⽅式"></a>I&#x2F;O 控制⽅式</h2><ol>
<li>轮询等待<br>让 CPU ⼀直查寄存器的状态，直到状态标记为完成，很明显，这种⽅式⾮常的傻⽠，它会占⽤ CPU 的全部时间。</li>
<li>中断<br>通知操作系统数据已经准备好了。我们⼀般会有⼀个硬件的中断控制器，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，⼀个中断产⽣了，CPU 需要停下当前⼿⾥的事情来处理中断。<br>另外，中断有两种，⼀种软中断，例如代码调⽤ INT 指令触发，⼀种是硬件中断，就是硬件通过中断控制器触发的。<br>但中断的⽅式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占⽤CPU ⼤量的时间。对于这⼀类设备的问题的解决⽅法是使⽤ DMA功能，它可以使得设备在 CPU 不参与的情况下，能够⾃⾏完成把设备 I&#x2F;O 数据放⼊到内存。那要实现 DMA 功能要有 「DMA 控制器」硬件的⽀持。</li>
</ol>
<h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a><font color="red">DMA技术</font></h2><p>实现了文件I&#x2F;O的第一道流程</p>
<p>在进⾏ I&#x2F;O 设备和内存的数据传输的时候，数据搬运的⼯作全部交给 DMA 控制器，⽽ CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3320624841468.png"></p>
<ol>
<li>⽤户进程调⽤ read ⽅法，向操作系统发出 I&#x2F;O 请求，请求读取数据到⾃⼰的内存缓冲区中，进程进⼊阻塞状态；</li>
<li>操作系统收到请求后，进⼀步将 I&#x2F;O 请求发送 DMA，然后让 CPU 执⾏其他任务；</li>
<li>DMA 进⼀步将 I&#x2F;O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I&#x2F;O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知⾃⼰缓冲区已满；</li>
<li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷⻉到内核缓冲区中，此时不占⽤CPU，CPU 可以执⾏其他任务；</li>
<li>当 DMA 读取了⾜够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷⻉到⽤户空间，系统调⽤返回；</li>
</ol>
<h2 id="传统文件传输"><a href="#传统文件传输" class="headerlink" title="传统文件传输"></a>传统文件传输</h2><p>两个系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<p>4 次用户态与内核态的上下文切换， 4 次数据拷贝</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/324970016256135.png"></p>
<h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a><font color="red">零拷贝技术</font></h2><ul>
<li>要想提⾼⽂件传输的性能，就需要<strong>减少⽤户态与内核态的上下⽂切换</strong>和<strong>内存拷贝</strong>的次数。</li>
</ul>
<ol>
<li>方案一：<br>mmap（见上文共享内存） + write</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">mmap</span>(file, len);</span><br><span class="line"><span class="built_in">write</span>(sockfd, buf, len);</span><br></pre></td></tr></table></figure>
<p>mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，可以减少一次数据拷贝，但是需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次，3次数据拷贝</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/165871416251889.png"></p>
<ol start="2">
<li>方案二：<br>sendfile();</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</span></span><br></pre></td></tr></table></figure>
<p>只有 2 次上下文切换，和 3 次数据拷贝</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/515381916269769.png"></p>
<ol start="3">
<li>方案三（真正的零拷贝）：<br>网卡需支持SG-DMA技术<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ethtool -k eth0 | grep scatter-gather</span></span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3305717821354.png"></p>
<ol>
<li>通过 DMA 将磁盘上的数据拷⻉到内核缓冲区⾥；</li>
<li>缓冲区描述符和数据⻓度传到 socket 缓冲区，这样⽹卡的 SG-DMA 控制器就可以<strong>直接将内核缓存中的数据拷⻉到⽹卡的缓冲区⾥</strong>，此过程不需要将数据从操作系统内核缓冲区拷⻉到 socket 缓冲区中，这样就减少了⼀次数据拷⻉；</li>
</ol>
<p><strong>零拷⻉技术的⽂件传输⽅式相⽐传统⽂件传输的⽅式，减少了 2 次上下⽂切换和数据拷⻉次数，只需要 2 次上下⽂切换和数据拷⻉次数，就可以完成⽂件的传输，⽽且 2 次的数据拷⻉过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p><strong>零拷贝技术的应用：Kafka、Nginx、Java NIO 库里的 transferTo方法</strong></p>
<h2 id="理想的文件传输方式"><a href="#理想的文件传输方式" class="headerlink" title="理想的文件传输方式"></a>理想的文件传输方式</h2><p>传输⽂件的时候，我们要根据⽂件的⼤⼩来使⽤不同的⽅式：<br>传输⼤⽂件的时候，使⽤「异步 I&#x2F;O + 直接 I&#x2F;O」；<br>传输⼩⽂件的时候，则使⽤「零拷⻉技术」；</p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 实现多路复⽤的⽅式是，将已连接的 Socket 都放到⼀个⽂件描述符集合，然后调⽤select 函数<mark>将⽂件描述符集合拷⻉到内核⾥</mark>，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是<mark>通过遍历</mark>⽂件描述符集合的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着<mark>再把整个⽂件描述符集合拷⻉回⽤户态⾥</mark>，然后⽤户态还需要<mark>再通过遍历</mark>的⽅法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种⽅式，需要进行2 次「遍历」⽂件描述符集合，⼀次是在内核态⾥，⼀个次是在⽤户态⾥ ，⽽且还会发⽣ 2 次「拷⻉」⽂件描述符集合，先从⽤户空间传⼊内核空间，由内核修改后，再传出到⽤户空间中。<br>select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤<mark>动态数组，以链表形式来组织</mark>，突破了 select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。<br>但是 poll 和 select 并没有太⼤的本质区别，都是使⽤<strong>线性结构</strong>存储进程关注的 Socket集合，因此都需要遍历⽂件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">bind</span>(s, ...);</span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(...);</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。</p>
<ul>
<li>第⼀点，<mark>epoll 在内核⾥使⽤红⿊树来跟踪进程所有待检测的⽂件描述字</mark>，把需要监控的socket 通过 epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，<mark>增删查⼀般时间复杂度是 O(logn)</mark> ，通过对这棵⿊红树进⾏操作，这样就不需要像 select&#x2F;poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，<mark>减少了内核和⽤户空间⼤量的数据拷贝和内存分配</mark></li>
<li>第⼆点， epoll 使⽤事件驱动的机制，内核⾥维护了⼀个链表来记录就绪事件，当某个socket 有事件发⽣时，通过回调函数内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。</li>
<li>第三点，使用__put_user 函数，将数据从内核拷贝到用户空间，而非共享内存</li>
</ul>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/118080312240551.png"></p>
<h4 id="两种事件触发模式"><a href="#两种事件触发模式" class="headerlink" title="两种事件触发模式"></a>两种事件触发模式</h4><ul>
<li>边缘触发模式(ET)，当被监控的 Socket 描述符上有可读事件发⽣时，<mark>服务器端只会从epoll_wait 中苏醒⼀次</mark>，即使进程没有调⽤ read 函数从内核读取数据，也依然只苏醒⼀次，因此我们程序要保证⼀次性将内核缓冲区的数据读取完；</li>
<li>⽔平触发模式(LT)，当被监控的 Socket 上有可读事件发⽣时，<mark>服务器端不断地从epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</mark>，⽬的是告诉我们有数据需要读取；</li>
</ul>
<p>如果使⽤边缘触发模式，在收到通知后应尽可能地读写数据，以免错失读写的机会。如果是阻塞的，没有数据可读写时，进程会<mark>阻塞</mark>在读写函数那⾥，程序就没办法继续往下执⾏。<mark>所以，边缘触发模式⼀般和⾮阻塞 I&#x2F;O 搭配使⽤，</mark>程序会⼀直执⾏ I&#x2F;O 操作，直到系统调⽤（如 read 和 write ）返回错误，错误类型为EAGAIN 或 EWOULDBLOCK 。</p>
<p>⼀般来说，边缘触发的效率⽐⽔平触发的效率要⾼,因为边缘触发可以减少 epoll_wait 的系统调⽤次数，系统调⽤也是有⼀定的开销的的，毕竟也存在上下⽂的切换。</p>
<h4 id="ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？"><a href="#ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？" class="headerlink" title="ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？"></a>ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？</h4><ol>
<li>LT的编程更符合用户直觉，业务层逻辑更简单，不易出错，但效率较低；</li>
<li>ET的编程可以做到更加简洁，某些场景下更加高效，但另一方面容易遗漏事件，容易产生bug；</li>
<li>对于nginx这种高性能服务器，ET模式是很好的，Redis使用的是LT，避免使用的过程中出现bug；</li>
<li>当并发量比较小时，比较推荐LT，因为LT模式下应用的读写逻辑比较简单，不容易遗漏事件，代码不易出错好维护，而且性能损失不大。当并发量非常大时，推荐使用ET模式，可以有效提升EPOLL效率。</li>
</ol>
<h1 id="操作系统其它知识"><a href="#操作系统其它知识" class="headerlink" title="操作系统其它知识"></a>操作系统其它知识</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><ol>
<li>什么是shell？</li>
</ol>
<ul>
<li>shell是linux的一个外壳，它包在linux内核的外面，为用户和内核之间的交互提供了一个接口。</li>
<li>当用户下达指令给该操作系统的时候，实际上是把指令告诉shell，经过shell解释，处理后让内核做出相应的动作。</li>
<li>系统的回应和输出的信息也由shell处理，然后显示在用户的屏幕上</li>
</ul>
<ol start="2">
<li>为什么使用shell脚本？</li>
</ol>
<ul>
<li>适合处理操作系统底层的业务，有众多系统命令为其做支撑（还有文本处理三兄弟：grep，sed，awk）</li>
<li>适合处理纯文本文件，linux中许多服务配置文件，启动脚本，都是纯文本文件（如：httpd，nfs，mysql，nginx，lvs）</li>
<li>linux系统脚本用shell开发更简单，简言之，shell脚本操作更加方便，快捷，高效。</li>
</ul>
<ol start="3">
<li>shell脚本与编程语言的区别？</li>
</ol>
<ul>
<li>shell脚本是能运行的文本，它包含命令和运行逻辑关系 。与C语言、C++、C#等编程语言不同。</li>
<li>shell脚本不需要编译、连接及生成可执行文件，直接由相应的解释器（最常用的解释器为bash） 解释执行即可。</li>
<li>它的优点是可批量，多次执行（使用）。简言之，shell脚本是解释性语言，而c语言则是编译性语言。</li>
</ul>
<h2 id="句柄（windows）"><a href="#句柄（windows）" class="headerlink" title="句柄（windows）"></a>句柄（windows）</h2><p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2535111169068.png">       <img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3580711156935.png"></p>
<p>Windows是一个以虚拟内存为基础的操作系统，进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被换出到外存，当再次需要时，再装入内存。两次装入的地址绝大多数情况下是不一样的。</p>
<p>系统为每个进程在内存中分配一定的区域，用来存放各个句柄，即一个个无符号整型。每个无符号整型值相当于一个指针，指向内存中的另一个区域A。而区域A中存放的正是对象在内存中的地址。<mark>当对象在内存中的位置发生变化时，区域A的值被更新，变为当前时刻对象在内存中的地址，而在这个过程中，区域A的位置以及对应句柄的值是不发生变化的。</mark></p>
<ol>
<li>所谓“唯一”、“不变”是指在程序的一次运行中。如果本次运行完，关闭程序，再次启动程序运行，那么这次运行中，同一对象的句柄的值和上次运行时比较，一般是不一样的。</li>
<li>句柄是对象生成时系统指定的，属性是只读的，程序员不能修改句柄。</li>
<li>不同的系统中，句柄的大小（字节数）是不同的，可以使用sizeof()来计算句柄的大小。</li>
<li>通过句柄，程序员只能调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事。</li>
</ol>
<h2 id="Linux网络传输"><a href="#Linux网络传输" class="headerlink" title="Linux网络传输"></a>Linux网络传输</h2><h3 id="Linux-接收⽹络包的流程"><a href="#Linux-接收⽹络包的流程" class="headerlink" title="Linux 接收⽹络包的流程"></a>Linux 接收⽹络包的流程</h3><ul>
<li>⽹卡是计算机⾥的⼀个硬件，专⻔负责接收和发送⽹络包，当⽹卡接收到⼀个⽹络包后，会通过 DMA 技术，将⽹络包放⼊到 Ring Buffer，这个是⼀个环形缓冲区。</li>
<li>Linux 内核在 2.6 版本中引⼊了 NAPI 机制，它是混合「中断和轮询」的⽅式来接收⽹络包，它的核⼼概念就是<mark>不采⽤中断的⽅式读取数据</mark>，⽽是⾸先<mark>采⽤中断唤醒数据接收的服务程序</mark>，然后 poll 的⽅法来轮询数据</li>
<li>⽐如，当有⽹络包到达时，⽹卡发起硬件中断，于是会执⾏⽹卡硬件中断处理函数，中断处理函数处理完需要「暂时屏蔽中断」，然后唤醒「软中断」来轮询处理数据，直到没有新数据时才恢复中断，这样⼀次中断处理多个⽹络包，于是就可以降低⽹卡中断带来的性能开销。</li>
</ul>
<h3 id="高性能网络模式：Reactor-和-Proactor"><a href="#高性能网络模式：Reactor-和-Proactor" class="headerlink" title="高性能网络模式：Reactor 和 Proactor"></a>高性能网络模式：Reactor 和 Proactor</h3><p><strong>1. 单 Reactor 单进程 &#x2F; 线程</strong></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2882998769758.png"></p>
<ul>
<li>Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch 进⾏分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li>
<li>如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理，Acceptor 对象会通过 accept⽅法 获取连接，并创建⼀个 Handler 对象来处理后续的响应事件；</li>
<li>如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应；Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li>
</ul>
<p><strong>2. 单 Reactor 多线程 &#x2F; 多进程</strong></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/583932456400.png"></p>
<ul>
<li>Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch 进⾏分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li>
<li>如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理，Acceptor 对象会通过 accept⽅法 获取连接，并创建⼀个 Handler 对象来处理后续的响应事件；</li>
<li>如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应；</li>
<li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给⼦线程⾥的 Processor 对象进⾏业务处理；</li>
<li>⼦线程⾥的 Processor 对象就进⾏业务处理，处理完后，将结果发给主线程中的 Handler对象，接着由 Handler 通过 send ⽅法将响应结果发送给 client；</li>
</ul>
<p>「单 Reactor」的模式还有个问题，因为⼀个 Reactor 对象承担所有事件的监听和响应，⽽且只在主线程中运⾏，在⾯对瞬间⾼并发的场景时，容易成为性能的瓶颈的地⽅。</p>
<p><strong>3. 多 Reactor 多进程 &#x2F; 线程</strong><br><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4893934002878.png"></p>
<ul>
<li>主线程中的 MainReactor 对象通过 select 监控连接建⽴事件，收到事件后通过 Acceptor对象中的 accept 获取连接，将新的连接分配给某个⼦线程；</li>
<li>⼦线程中的 SubReactor 对象将 MainReactor 对象分配的连接加⼊ select 继续进⾏监听，并创建⼀个 Handler ⽤于处理连接的响应事件。</li>
<li>如果有新的事件发⽣时，SubReactor 对象会调⽤当前连接对应的 Handler 对象来进⾏响应。</li>
<li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li>
</ul>
<p>主线程和⼦线程分⼯明确，主线程只负责接收新连接，⼦线程负责完成后续的业务处理。<br>主线程和⼦线程的交互很简单，主线程只需要把新连接传给⼦线程，⼦线程⽆须返回数据，直接就可以在⼦线程将处理结果发送给客户端。</p>
<ul>
<li>Reactor 是⾮阻塞同步⽹络模式，感知的是就绪可读写事件。在每次感知到有事件发⽣（⽐如可读就绪事件）后，就需要应⽤进程主动调⽤ read ⽅法来完成数据的读取，也就是要应⽤进程主动将 socket 接收缓存中的数据读到应⽤进程内存中，这个过程是同步的，读取完数据后应⽤进程才能处理数据。</li>
<li>Proactor 是异步⽹络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传⼊数据缓冲区的地址（⽤来存放结果数据）等信息，这样系统内核才可以⾃动帮我们把数据的读写⼯作完成，这⾥的读写⼯作全程由操作系统来做，并不需要像 Reactor 那样还需要应⽤进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写⼯作后，就会通知应⽤进程直接处理数据。</li>
</ul>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p>
<p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算，是一个固定的值。</p>
<p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为哈希环，如下图：</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/84610117267373.png"></p>
<p>一致性哈希要进行两步哈希：</p>
<p>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；<br>第二步：当对数据进行存储或访问时，对数据进行哈希映射；<br>所以，一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。</p>
<h2 id="Linux内核体系结构"><a href="#Linux内核体系结构" class="headerlink" title="Linux内核体系结构"></a>Linux内核体系结构</h2><p>系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p>
<h3 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h3><p>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 .&#x2F;linux&#x2F;kernel 中您可以找到 SCI 的实现，并在 .&#x2F;linux&#x2F;arch 中找到依赖于体系结构的部分。</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</p>
<p>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 .&#x2F;linux&#x2F;kernel 中找到进程管理的源代码，在 .&#x2F;linux&#x2F;arch 中可以找到依赖于体系结构的源代码。</p>
<h3 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h3><p>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 .&#x2F;linux&#x2F;mm 中找到。</p>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图4）。</p>
<h2 id="Linux文件系统层次结构"><a href="#Linux文件系统层次结构" class="headerlink" title="Linux文件系统层次结构"></a>Linux文件系统层次结构</h2><p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 .&#x2F;linux&#x2F;fs 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<h3 id="网络堆栈"><a href="#网络堆栈" class="headerlink" title="网络堆栈"></a>网络堆栈</h3><p>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 .&#x2F;linux&#x2F;net 中找到。</p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 .&#x2F;linux&#x2F;drivers 中找到。</p>
<h3 id="依赖体系结构的代码"><a href="#依赖体系结构的代码" class="headerlink" title="依赖体系结构的代码"></a>依赖体系结构的代码</h3><p>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。.&#x2F;linux&#x2F;arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 .&#x2F;linux&#x2F;arch 中找到。</p>
<p>如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP&#x2F;IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。</p>
<p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p>
<p>Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft Windows也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/17/Redis/" rel="prev" title="Redis">
      <i class="fa fa-chevron-left"></i> Redis
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">1.</span> <span class="nav-text">操作系统的能力</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9A%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">伟大的原理：局部性原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU"><span class="nav-number">3.</span> <span class="nav-text">CPU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">3.1.</span> <span class="nav-text">CPU三级缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E6%80%A7%E8%83%BD"><span class="nav-number">3.2.</span> <span class="nav-text">CPU性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">CPU读取数据方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E7%9A%84%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5"><span class="nav-number">3.4.</span> <span class="nav-text">CPU的缓存写入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">3.5.</span> <span class="nav-text">CPU缓存一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF%E5%97%85%E6%8E%A2"><span class="nav-number">3.5.1.</span> <span class="nav-text">总线嗅探</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MESI-%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.5.2.</span> <span class="nav-text">MESI 协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">3.6.</span> <span class="nav-text">CPU软中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8"><span class="nav-number">4.</span> <span class="nav-text">内核</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">用户态-&gt;内核态的方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">为什么要有虚拟内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">5.2.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="nav-number">5.2.1.</span> <span class="nav-text">内存分段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="nav-number">5.2.2.</span> <span class="nav-text">内存分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%88%86%E9%A1%B5"><span class="nav-number">5.2.3.</span> <span class="nav-text">多级分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLB%E6%8A%80%E6%9C%AF"><span class="nav-number">5.2.3.1.</span> <span class="nav-text">TLB技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">5.2.4.</span> <span class="nav-text">段页式存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.5.</span> <span class="nav-text">伙伴算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%BF%9B%E9%98%B6"><span class="nav-number">5.3.</span> <span class="nav-text">内存进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">5.3.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-number">5.3.2.</span> <span class="nav-text">malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84%EF%BC%9F"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">malloc 是如何分配内存的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-1-%E4%BC%9A%E5%88%86%E9%85%8D%E5%A4%9A%E5%A4%A7%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">malloc(1) 会分配多大的虚拟内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-mmap-%E6%9D%A5%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">为什么不全部使用 mmap 来分配内存？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8-brk-%E6%9D%A5%E5%88%86%E9%85%8D%EF%BC%9F"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">为什么不全部使用 brk 来分配？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free-%E5%87%BD%E6%95%B0%E5%8F%AA%E4%BC%A0%E5%85%A5%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E7%9F%A5%E9%81%93%E8%A6%81%E9%87%8A%E6%94%BE%E5%A4%9A%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F"><span class="nav-number">5.3.2.5.</span> <span class="nav-text">free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">5.3.3.</span> <span class="nav-text">内存对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%88%E6%9C%AA%E6%8C%87%E5%AE%9A-pragma-pack%E6%97%B6%EF%BC%89"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">结构体内存对齐的规则（未指定#pragma pack时）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.3.4.</span> <span class="nav-text">大小端模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="nav-number">5.4.</span> <span class="nav-text">内存回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="nav-number">5.4.1.</span> <span class="nav-text">哪些内存可以被回收？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ELRU%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.2.</span> <span class="nav-text">基于LRU算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%A2%AB-OOM-%E6%9D%80%E6%8E%89%E5%91%A2%EF%BC%9F"><span class="nav-number">5.4.3.</span> <span class="nav-text">如何保护一个进程不被 OOM 杀掉呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.4.4.</span> <span class="nav-text">swap机制的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="nav-number">5.5.</span> <span class="nav-text">内存的预读失效和缓存污染</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E7%9A%84-Page-Cache-%E5%92%8C-MySQL-%E7%9A%84-Buffer-Pool"><span class="nav-number">5.5.1.</span> <span class="nav-text">Linux 的 Page Cache 和 MySQL 的 Buffer Pool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88"><span class="nav-number">5.5.2.</span> <span class="nav-text"> 解决预读失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="nav-number">5.5.3.</span> <span class="nav-text">解决缓存污染</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E5%86%85%E5%AD%98"><span class="nav-number">5.6.</span> <span class="nav-text">深入内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%B8%83%E5%B1%80%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-number">5.6.1.</span> <span class="nav-text">内核如何布局进程虚拟内存空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">5.6.2.</span> <span class="nav-text">内核如何管理虚拟内存区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E7%BB%84%E7%BB%87%E7%9A%84"><span class="nav-number">5.6.3.</span> <span class="nav-text">虚拟内存区域在内核中是如何被组织的</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">6.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">Linux的进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0%E5%8F%B7%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.1.</span> <span class="nav-text">0号进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E5%8F%B7%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.2.</span> <span class="nav-text">1号进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E5%8F%B7%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.3.</span> <span class="nav-text">2号进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">6.1.4.</span> <span class="nav-text">写时复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.5.</span> <span class="nav-text">孤儿进程与僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.6.</span> <span class="nav-text">守护进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.6.1.</span> <span class="nav-text">创建守护进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.2.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%EF%BC%9A"><span class="nav-number">6.2.1.</span> <span class="nav-text">进程：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">进程的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-number">6.2.1.2.</span> <span class="nav-text">并行和并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">6.2.1.3.</span> <span class="nav-text">进程的状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="nav-number">6.2.2.</span> <span class="nav-text">线程：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E7%8E%AF%E5%A2%83"><span class="nav-number">6.2.2.1.</span> <span class="nav-text">线程共享的环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">6.2.2.2.</span> <span class="nav-text">线程的优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">6.2.2.3.</span> <span class="nav-text">线程的缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">6.2.2.4.</span> <span class="nav-text">线程上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E2%BD%85%E5%BC%8F"><span class="nav-number">6.2.2.5.</span> <span class="nav-text">三种线程的实现⽅式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.2.2.5.1.</span> <span class="nav-text">用户线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-number">6.2.2.5.2.</span> <span class="nav-text">内核线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.2.2.5.3.</span> <span class="nav-text">轻量级进程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E2%BD%90%E8%BE%83"><span class="nav-number">6.2.3.</span> <span class="nav-text">线程与进程的⽐较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E2%BD%90%E8%BF%9B%E7%A8%8B%E8%83%BD%E5%87%8F%E5%B0%91%E5%BC%80%E9%94%80"><span class="nav-number">6.2.4.</span> <span class="nav-text">线程相⽐进程能减少开销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">6.2.5.</span> <span class="nav-text">多线程和多进程的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">6.3.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">6.4.</span> <span class="nav-text">进程的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">6.4.1.</span> <span class="nav-text">管道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">无名管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="nav-number">6.4.1.2.</span> <span class="nav-text">命名管道</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">6.4.2.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">6.4.3.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84I-O%EF%BC%88mmap%EF%BC%89"><span class="nav-number">6.4.3.1.</span> <span class="nav-text">存储映射I&#x2F;O（mmap）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">6.4.4.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">6.4.5.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket"><span class="nav-number">6.4.6.</span> <span class="nav-text">Socket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">6.5.</span> <span class="nav-text">线程的同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F%EF%BC%88%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%89"><span class="nav-number">6.5.1.</span> <span class="nav-text">互斥量（互斥锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88%E5%85%B1%E4%BA%AB%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%89"><span class="nav-number">6.5.2.</span> <span class="nav-text">读写锁（共享互斥锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">6.5.3.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">6.5.4.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E9%9A%9C"><span class="nav-number">6.5.5.</span> <span class="nav-text">屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="nav-number">6.5.6.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7-1"><span class="nav-number">6.5.7.</span> <span class="nav-text">信号</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">6.6.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.6.1.</span> <span class="nav-text">死锁的四个条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">6.6.2.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">6.6.3.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.4.</span> <span class="nav-text">哲学家就餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">6.6.5.</span> <span class="nav-text">悲观锁与乐观锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">7.1.</span> <span class="nav-text">调度的原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">进程调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">先来先服务调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.2.</span> <span class="nav-text">最短作业优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.3.</span> <span class="nav-text">高响应比优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E2%BD%9A%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.4.</span> <span class="nav-text">时间⽚轮转调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E2%BE%BC%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.5.</span> <span class="nav-text">最⾼优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.2.6.</span> <span class="nav-text">多级反馈队列调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">内存页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E2%BB%9A%E2%BE%AF%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.1.</span> <span class="nav-text">最佳⻚⾯置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.2.</span> <span class="nav-text">先进先出置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E2%BD%A4%E7%9A%84%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.3.</span> <span class="nav-text">最近最久未使⽤的置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LRU%E7%BC%93%E5%AD%98"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">LRU缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E2%BB%9A%E2%BE%AF%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.4.</span> <span class="nav-text">时钟⻚⾯置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E2%BD%A4%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.5.</span> <span class="nav-text">最不常⽤算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.</span> <span class="nav-text">磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.1.</span> <span class="nav-text">先来先服务算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.</span> <span class="nav-text">最短寻道时间优先算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95%EF%BC%88%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">7.4.3.</span> <span class="nav-text">扫描算法（电梯算法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.4.</span> <span class="nav-text">循环扫描算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%9A%84%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.1.</span> <span class="nav-text">Linux的文件类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">文件的管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F"><span class="nav-number">8.3.</span> <span class="nav-text">文件的存放方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unix%E5%92%8CLinux-Ext-2-3"><span class="nav-number">8.4.</span> <span class="nav-text">Unix和Linux Ext 2&#x2F;3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">8.5.</span> <span class="nav-text">空闲空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="nav-number">8.5.1.</span> <span class="nav-text">空闲表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="nav-number">8.5.2.</span> <span class="nav-text">空闲链表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BE%E6%B3%95"><span class="nav-number">8.5.3.</span> <span class="nav-text">位图法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">8.6.</span> <span class="nav-text">目录的管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5-ln-s-%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5-ln-d%EF%BC%89"><span class="nav-number">8.7.</span> <span class="nav-text">软链接(ln -s)和硬链接(ln -d）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="nav-number">8.7.1.</span> <span class="nav-text">硬链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="nav-number">8.7.2.</span> <span class="nav-text">软链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6I-O"><span class="nav-number">8.8.</span> <span class="nav-text">文件I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2-I-O"><span class="nav-number">8.8.1.</span> <span class="nav-text">缓冲与非缓冲 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5-I-O"><span class="nav-number">8.8.2.</span> <span class="nav-text">直接与非直接 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9EI-O"><span class="nav-number">8.8.3.</span> <span class="nav-text">阻塞与非阻塞I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5-I-O"><span class="nav-number">8.8.4.</span> <span class="nav-text">同步与异步 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8FIO"><span class="nav-number">8.8.5.</span> <span class="nav-text">信号驱动式IO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Cache"><span class="nav-number">8.9.</span> <span class="nav-text">Page Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7-%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">8.9.1.</span> <span class="nav-text">文件持久化的一致性&amp;可靠性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swap%E8%AF%A6%E8%A7%A3"><span class="nav-number">8.10.</span> <span class="nav-text">Swap详解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">设备管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E6%8E%A7%E5%88%B6%E2%BD%85%E5%BC%8F"><span class="nav-number">9.1.</span> <span class="nav-text">I&#x2F;O 控制⽅式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E6%8A%80%E6%9C%AF"><span class="nav-number">9.2.</span> <span class="nav-text">DMA技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="nav-number">9.3.</span> <span class="nav-text">传统文件传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF"><span class="nav-number">9.4.</span> <span class="nav-text">零拷贝技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E6%83%B3%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="nav-number">9.5.</span> <span class="nav-text">理想的文件传输方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">9.6.</span> <span class="nav-text">I&#x2F;O多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">9.6.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">9.6.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">9.6.3.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.6.3.1.</span> <span class="nav-text">两种事件触发模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ET%E5%92%8CLT%E6%A8%A1%E5%BC%8F%E5%90%84%E8%87%AA%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86%E9%AB%98%E6%95%88%E7%9A%84ET%E8%BF%98%E9%9C%80%E8%A6%81LT%EF%BC%9F"><span class="nav-number">9.6.3.2.</span> <span class="nav-text">ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86"><span class="nav-number">10.</span> <span class="nav-text">操作系统其它知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shell"><span class="nav-number">10.1.</span> <span class="nav-text">shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84%EF%BC%88windows%EF%BC%89"><span class="nav-number">10.2.</span> <span class="nav-text">句柄（windows）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="nav-number">10.3.</span> <span class="nav-text">Linux网络传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-%E6%8E%A5%E6%94%B6%E2%BD%B9%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">10.3.1.</span> <span class="nav-text">Linux 接收⽹络包的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%EF%BC%9AReactor-%E5%92%8C-Proactor"><span class="nav-number">10.3.2.</span> <span class="nav-text">高性能网络模式：Reactor 和 Proactor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">10.4.</span> <span class="nav-text">一致性哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">10.5.</span> <span class="nav-text">Linux内核体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">10.5.1.</span> <span class="nav-text">系统调用接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">10.5.2.</span> <span class="nav-text">进程管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="nav-number">10.5.3.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.5.4.</span> <span class="nav-text">虚拟文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">10.6.</span> <span class="nav-text">Linux文件系统层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%A0%86%E6%A0%88"><span class="nav-number">10.6.1.</span> <span class="nav-text">网络堆栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">10.6.2.</span> <span class="nav-text">设备驱动程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">10.6.3.</span> <span class="nav-text">依赖体系结构的代码</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">徐川</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">徐川</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
