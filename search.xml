<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Golang</title>
    <url>/mybook.github.io/2024/05/20/Go/</url>
    <content><![CDATA[<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><h2 id="数值（-16-个）"><a href="#数值（-16-个）" class="headerlink" title="数值（ 16 个）"></a>数值（ 16 个）</h2><h3 id="整型（-12-个）"><a href="#整型（-12-个）" class="headerlink" title="整型（ 12 个）"></a>整型（ 12 个）</h3><p>byte int int8 int16 int32 int64 </p>
<p>uint unint8 uint16 uint32 uint64 uintprt </p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint8</td>
<td align="center">0 到 255</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">0 到 65535</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">0 到 4294967295</td>
</tr>
<tr>
<td align="center">unit64</td>
<td align="center">(0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">-128 到 127</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="center">-32768 到 32767</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">-2147483648 到 2147483647</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">(-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h3 id="浮点型（-2个）"><a href="#浮点型（-2个）" class="headerlink" title="浮点型（ 2个）"></a>浮点型（ 2个）</h3><p>float32 float64 </p>
<h3 id="复数型（-2个）"><a href="#复数型（-2个）" class="headerlink" title="复数型（ 2个）"></a>复数型（ 2个）</h3><p>complex64    complex128 </p>
<h3 id="字符和字符串型（-2个）"><a href="#字符和字符串型（-2个）" class="headerlink" title="字符和字符串型（ 2个）"></a>字符和字符串型（ 2个）</h3><p>string   rune </p>
<h3 id="接口型（-1个）"><a href="#接口型（-1个）" class="headerlink" title="接口型（ 1个）"></a>接口型（ 1个）</h3><p>error </p>
<h3 id="布尔型（1个）"><a href="#布尔型（1个）" class="headerlink" title="布尔型（1个）"></a>布尔型（1个）</h3><p>bool </p>
<p>token 是构成源程序的基本不可再分割的单元。</p>
<p>变量表示指向的内存可以被修改，常量表示指向的内存不能被修改。</p>
<p>需要注意的是 { 不能单独放在一行，在运行时会产生错误</p>
<p>字符串是常量，可以通过类 数组 索引访问其字节单元，但是不能修改某个字节的值。</p>
<p>Go语言基本的复合数据类型有指针、数组、切片、字典（ map ）、通道、结构和接口，它们的字面量格式如下&#96;</p>
<p> :&#x3D; 是一个声明语句。intVal :&#x3D; 1 相等于：</p>
<p>Go 函数可以返回多个值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var intVal int </span><br><span class="line">intVal =1 </span><br></pre></td></tr></table></figure>

<p>可以将 var f string &#x3D; “Runoob” 简写为 f :&#x3D; “Runoob”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pointerType  	／／指针类型使用＊后面跟其指向的类型名</span><br><span class="line">[n] elementType 	／／数纽类型使用［ ）后面跟数纽元素类型来表示， 表示该数组的长度</span><br><span class="line">[] elementType 		／／ 切片类型使用［］后面跟切片元素类型来表示</span><br><span class="line">map [keyType)valueType 	//map 类型使用 map ［键类型］值类型来表</span><br><span class="line">chan valueType 	／／通道使 ch an 后面跟远远元素类型来表示</span><br><span class="line">struct &#123; 	／／结构类型使 str uct ｛｝将各个结构字段扩起来表示</span><br><span class="line">    feildType feildType</span><br><span class="line">    feildType feildType </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">interface ｛／／接 口类型使用 interface ｛｝将各个方法括起来表示</span><br><span class="line">methodl ( inputParams) ( returnParams)</span><br><span class="line">method2 (inputParams) (returnParams)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<center><font size="32">------赞助耶耶，加快更新！------</font></center>

<p> <img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/mybook.github.io/2024/05/22/Mysql/</url>
    <content><![CDATA[<h1 id="sql分类"><a href="#sql分类" class="headerlink" title="sql分类"></a>sql分类</h1><p>DDL中常用的命令有：create，drop，alter，truncate、rename<br>DML中常用的命令有：insert，update，delete、select</p>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><h2 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h2><p><mark>列不可再分</mark><br>每一列属性都是不可再分的属性值，确保每一列的原子性</p>
<h2 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h2><p><mark>属性完全依赖于主键</mark><br>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p>
<h2 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h2><p><mark>属性不依赖于其它非主属性    属性直接依赖于主键</mark><br>数据不能存在传递关系，需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p>
<h1 id="四种特性"><a href="#四种特性" class="headerlink" title="四种特性"></a>四种特性</h1><ol>
<li>原子性（Atomicity）<br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li>一致性（Consistency）<br>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</li>
<li>隔离性（Isolation）<br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li>持久性（Durability）<br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ol>
<h1 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h1><ul>
<li>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</li>
<li>聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续</li>
<li>聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序。<br>非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。</li>
<li>聚集索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li>
</ul>
<h2 id="主键索引与聚集索引的区别"><a href="#主键索引与聚集索引的区别" class="headerlink" title="主键索引与聚集索引的区别"></a>主键索引与聚集索引的区别</h2><p>innodb引擎里面，主键的确就是聚集索引，但是myisam引擎里面主键也不是聚集索引。<br><mark>聚集索引决定了数据库的物理存储结构，而主键只是确定表格逻辑组织方式。这两者不可混淆</mark><br>对于Innodb：</p>
<ol>
<li>如果一个主键被定义了，那么这个主键就是作为聚集索引</li>
<li>如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引</li>
<li>如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是每行数据内置的6字节ROWID，该列的值会随着数据的插入自增。</li>
</ol>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><ol>
<li>脏读<br>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。因为另外一个事务还没提交，所以它随时可能会回滚，那么必然导致你更新的数据就没了。<br>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致</li>
<li>不可重复读<br>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。<br>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。<br><mark>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</mark></li>
<li>虚读(幻读)<br>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><mark>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</mark></li>
</ol>
<p>现在来看看MySQL数据库为我们提供的四种隔离级别：<br>① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。<br>② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。<br>③ Read committed (读已提交)：可避免脏读的发生。<br>④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。<br>设置数据库的隔离级别一定要是在开启事务之前！<br>Mysql 默认采用的②Repeatable read隔离级别 </p>
<h1 id="索引与B-树"><a href="#索引与B-树" class="headerlink" title="索引与B+树"></a>索引与B+树</h1><h2 id="为什么数据库索引使用B-树"><a href="#为什么数据库索引使用B-树" class="headerlink" title="为什么数据库索引使用B+树"></a>为什么数据库索引使用B+树</h2><ul>
<li><p>MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。</p>
</li>
<li><p>那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。</p>
</li>
<li><p>尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息，磁盘的I&#x2F;O操作也少一些，而且B+树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。一颗B&#x2F;B+树的高度远远小于红黑树的高度。B+树上操作的时间通常由存取磁盘的时间和CPU计算时间这两部分构成，而CPU的速度非常快，所以<mark>B树的操作效率取决于访问磁盘的次数</mark>，B树的高度越小，磁盘I&#x2F;O所花的时间越少。</p>
</li>
</ul>
<h2 id="为什么说B-树比B树更适合数据库索引"><a href="#为什么说B-树比B树更适合数据库索引" class="headerlink" title="为什么说B+树比B树更适合数据库索引"></a>为什么说B+树比B树更适合数据库索引</h2><ol>
<li><p>B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
<li><p>由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，例如数据库中select数据，很多时候会选多条，比如按照id排序后选10条。B树需要做局部的中序遍历，可能要跨层访问。而B+树由于所有数据都在叶子结点，不用跨层，同时由于有链表结构，只需要找到首尾，通过链表就能把所有数据取出来了。所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
</li>
</ol>
<h2 id="为什么数据库索引不采用hash"><a href="#为什么数据库索引不采用hash" class="headerlink" title="为什么数据库索引不采用hash"></a>为什么数据库索引不采用hash</h2><ol>
<li>hash不能进行范围查找 如果只选一个数据，那确实是hash更快。但是数据库中经常会选择多条，这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。</li>
<li>数据库中的索引一般是在磁盘上，使用hash时，数据量大的情况可能无法一次装入内存，B+树的设计可以允许数据分批加载，同时树的高度较低，提高查找效率。</li>
<li>当数据量很大时，hash冲突的概率也会非常大</li>
</ol>
<h1 id="数据库内存技术"><a href="#数据库内存技术" class="headerlink" title="数据库内存技术"></a>数据库内存技术</h1><h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p><img data-src="/mybook.github.io/vx_images/173992495713.png"></p>
<ul>
<li>由于CPU速度和磁盘速度的鸿沟，使用缓冲池提高数据库性能，</li>
<li>在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</li>
<li>页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过Checkpoint的机制刷新回磁盘</li>
</ul>
<h2 id="LRU-list"><a href="#LRU-list" class="headerlink" title="LRU list"></a>LRU list</h2><p>最近最少使用算法</p>
<ul>
<li>最频繁使用的页在LRU列表的前端，最少使用的在LRU列表的尾端，首先释放LRU尾端的页</li>
<li>在 InnoDB的存储引擎中，LRU列表中还加入了midpoint位置。新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint 位置。在默认配置下，该位置在LRU列表长度的5／8处。</li>
<li><mark>为什么不采用朴素的LRU算法，直接将读取的页放人到LRU列表的首部呢？</mark><br>常见的这类操作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘，从而影响缓冲池的效率。</li>
</ul>
<h2 id="Free-list"><a href="#Free-list" class="headerlink" title="Free list"></a>Free list</h2><ul>
<li>Free List中的每一个结点都是缓存页对应的描述信息。并且通过描述信息可以找到指定的缓存页，如果一个缓存页中没有存储任何数据，那么它对应的描述信息就会被维护进Free List中。</li>
<li>当数据库刚启动时，LRU列表是空的，即没有任何的页。这时页都存放在Free列表中。</li>
<li>当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，若有则将该页从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。</li>
<li>当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb_old_blocks_time的设置而导致页没有从old部分移动到new部分的操作称为page not made young。</li>
</ul>
<h2 id="Flush-List"><a href="#Flush-List" class="headerlink" title="Flush List"></a>Flush List</h2><ul>
<li>在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。</li>
<li>这时数据库会通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。需要注意的是，脏页既存在于LRU列表中，也存在于Flush列表中。</li>
<li><mark>LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘</mark>，二者互不影响。</li>
</ul>
<h2 id="Checkpoint技术（持久性）"><a href="#Checkpoint技术（持久性）" class="headerlink" title="Checkpoint技术（持久性）"></a>Checkpoint技术（持久性）</h2><p>为了避免发生数据丢失的问题， 当前事务数据库系统普遍都采用了WriteAhead Log策略， 即当事务提交时，先写重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是事务ACID中D (Durability持久性）的要求。<br>Checkpoint（检查点）技术的目的是解决以下几个问题：</p>
<ul>
<li>缩短数据库的恢复时间；</li>
<li>缓冲池不够用时，将脏页刷新到磁盘；</li>
<li>重做日志不可用时，刷新脏页。</li>
</ul>
<h3 id="重做日志缓冲"><a href="#重做日志缓冲" class="headerlink" title="重做日志缓冲"></a>重做日志缓冲</h3><p>InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。<br>下列几种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中：</p>
<ol>
<li>MasterThread每一秒将重做日志缓冲刷新到重做日志文件；</li>
<li>每个事务提交时会将重做日志缓冲刷新到重做日志文件；</li>
<li>当重做日志缓冲池剩余空间小于1 &#x2F;2时，重做日志缓冲刷新到重做日志文件。</li>
</ol>
<h2 id="undo-log-原子性"><a href="#undo-log-原子性" class="headerlink" title="undo log(原子性)"></a>undo log(原子性)</h2><p>undo log主要记录数据的逻辑变化，为了在发生错误时回滚之前的操作，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。</p>
<p>undo log的作用<br>undo是一种逻辑日志，有两个作用：</p>
<p>事务回滚<br>MVCC<br>重点关注如何利用undo log进行事务回滚。</p>
<p>undo日志，只将数据库逻辑地恢复到原来的样子，在回滚的时候，它实际上是做的相反的工作，比如一条INSERT ，对应一条 DELETE，对于每个UPDATE,对应一条相反的 UPDATE,将修改前的行放回去。通过undo log进行事务回滚操作可以保障事务的原子性。</p>
<p>undo log的写入时机<br>DML操作修改聚簇索引前，记录undo log<br>二级索引记录的修改，不记录undo log<br>需要注意的是，undo log页面的修改，同样需要记录redo日志。</p>
<p>undo log的存储位置<br>在InnoDB存储引擎中，undo log存储在回滚段(Rollback Segment)中,每个回滚段记录了1024个undo log segment，而在每个undo log segment段中进行undo 页的申请，在5.6以前，Rollback Segment是在共享表空间里的，5.6.3之后，可通过 innodb_undo_tablespace设置undo存储的位置。</p>
<p>undo的类型<br>在InnoDB存储引擎中，undo log分为：</p>
<p>insert undo log<br>update undo log<br>insert undo log是指在insert 操作中产生的undo log，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p>
<p>而update undo log记录的是对delete 和update操作产生的undo log，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。</p>
<p>补充：purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种”假删除”,只是做了个标记，真正的删除工作需要后台purge线程去完成。</p>
<p>undo log 是否是redo log的逆过程？<br>undo log 是否是redo log的逆过程？其实从前文就可以得出答案了，undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子，而redo log是物理日志，记录的是数据</p>
<h1 id="InnoDB与MyISAM的区别"><a href="#InnoDB与MyISAM的区别" class="headerlink" title="InnoDB与MyISAM的区别"></a>InnoDB与MyISAM的区别</h1><p>InnoDB支持4个事务隔离级别，回滚，崩溃修复能力和多版本并发的事务安全，包括ACID。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能<br>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择</p>
<ol>
<li><p><strong>InnoDB 支持事务，MyISAM 不支持事务。</strong><br>这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</p>
</li>
<li><p><strong>InnoDB 支持外键，而 MyISAM 不支持。</strong><br>对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  </p>
</li>
<li><p><strong>InnoDB 是聚集索引，MyISAM 是非聚集索引。</strong><br>InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p>
</li>
</ol>
<p>![](vx_images&#x2F;4903259199102.png &#x3D;700x)</p>
<p>![](vx_images&#x2F;4502782766625.png &#x3D;500x)</p>
<ol start="4">
<li><p><strong>InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</strong></p>
</li>
<li><p><strong>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</strong></p>
</li>
<li><p><strong>MyISAM支持全文类型索引，而InnoDB不支持全文索引</strong></p>
</li>
<li><p><strong>MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</strong></p>
</li>
</ol>
<h1 id="一条SQL语句的执行流程"><a href="#一条SQL语句的执行流程" class="headerlink" title="一条SQL语句的执行流程"></a>一条SQL语句的执行流程</h1><p>![](vx_images&#x2F;5001518199187.png &#x3D;500x)</p>
<p>MySQL 主要分为 Server 层和存储引擎层：</p>
<ul>
<li>Server 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li>存储引擎： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</li>
</ul>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol>
<li><p>客户端向MySQL服务器发送一条查询请求</p>
</li>
<li><p>服务器首先先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</p>
</li>
<li><p>服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</p>
</li>
<li><p>MySQL根据执行计划，调用存储引擎的API来执行查询</p>
</li>
<li><p>将结果返回给客户端，同时缓存查询结果</p>
</li>
</ol>
<h1 id="mysql分页查询"><a href="#mysql分页查询" class="headerlink" title="mysql分页查询"></a>mysql分页查询</h1><ul>
<li><p>方式1：select * from table order by id limit m, n;<br>该语句的意思就是查询m+n条记录，去掉前m条，返回后n条。无疑该查询能够实现分页，但m越大，查询性能就越低，因为MySQL需要扫描全部m+n条记录。</p>
</li>
<li><p>方式2：select * from table where id &gt; #max_id# order by id limit n;<br>该查询同样会返回后n条记录，却无需像方式1扫描前m条记录，但必须在每次查询时拿到上一次查询（上一页）的最大id（或最小id）。该查询的问题也在于我们不一定能拿到这个id，比如当前在第3页，需要查询第5页的数据，就不行了。</p>
</li>
<li><p>方式3：<br>为了避免方式2不能实现的跨页查询，就需要结合方式1。<br>性能需要，m得尽量小，比如当前在第3页，需要查询第5页，每页10条数据，而当前第3页的最大id为#max_id#，则：<br>select * from table where id &gt; #max_id# order by id limit 10, 10;<br>该查询方式就部分解决了方式2的问题，但如果当前在第2页，要查第1000页，性能仍然较差。</p>
</li>
<li><p>方式4：select * from table as a inner join (select id from table order by id limit m, n) as b on a.id &#x3D; b.id order by a.id;<br>该查询同方式1一样，m的值可能很大，但由于内部的子查询只扫描了id字段，而非全表，所以性能要强于方式1，并且能够解决方式2和方式3不能解决的问题。</p>
</li>
<li><p>方式5：select * from table where id &gt; (select id from table order by id limit m, 1) limit n;<br>该查询同样是通过子查询扫描字段id，效果同方式4。但方式5的性能会略好于方式4，因为方式5不需要进行表的关联，而是一个简单的比较，在不知道上一页最大id的情况下，是比较推荐的用法。</p>
</li>
</ul>
<center><font size="32">------赞助耶耶，加快更新！------</font></center>

<p><img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>C++</title>
    <url>/mybook.github.io/2024/05/20/C++/</url>
    <content><![CDATA[<h1 id="面向对象特性"><a href="#面向对象特性" class="headerlink" title="面向对象特性"></a>面向对象特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类，类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。</p>
<h3 id="继承的实现方式"><a href="#继承的实现方式" class="headerlink" title="继承的实现方式"></a>继承的实现方式</h3><ol>
<li>实现继承：是指使用基类的属性和方法而无需额外编码的能力；</li>
<li>接口继承：是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</li>
<li>可视继承：是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态:"></a>多态:</h2><h3 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h3><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>其实编译器对函数模板进行了两次编译，第一次编译时,首先去检查函数模板本身有没有语法错误，第二次编译时，若编译器发现有调用，又会在调用的地方编译一次，生成相应类型的调用代码，然后通过代码的真正参数,来生成真正的函数。<strong>所以函数模板,其实只是一个模具,当我们调用它时,编译器就会给我们生成真正的函数.</strong><br>在编译期间，编译器推断出模板参数，这类似于重载函数在编译器进行推导，以确定哪一个函数被调用。对模板参数而言，多态是通过模板特例化和函数重载解析实现的。以不同的模板参数特例化导致调用不同的函数，这就是所谓的编译期多态。</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>程序从编译到运行出结果几个阶段。其中一个阶段提到生成符号表。</p>
<p><img data-src="/mybook.github.io/images/5868715178993.png"></p>
<p>编译器在编译.c文件时，只会给函数进行简单的重命名；具体的方法是给函数名之前加上”_”;所以加入两个函数名相同的函数在编译之后的函数名也照样相同；调用者会因为不知道到底调用那个而出错；</p>
<p><img data-src="/mybook.github.io/images/1285516166860.png"></p>
<p>后边的3个字符分别表示返回值类型，两个参数类型。“@Z”表示名称结束。由于在.cpp文件中，两个函数生成的符号表中的名称不一样，所以是可以编译通过的。</p>
<h4 id="重载、覆盖、遮蔽、"><a href="#重载、覆盖、遮蔽、" class="headerlink" title="重载、覆盖、遮蔽、"></a>重载、覆盖、遮蔽、</h4><ol>
<li>函数重载发生在同一个类或顶层函数中，同名的函数具有不同的参数列表</li>
<li>函数覆盖发生在继承层次中，该函数在父类中必须是virtual，而子类的该函数必须与父类具有相同的参数列表</li>
<li>函数遮蔽（隐藏）发生在继承层次中，父类和子类同名的函数中，不属于函数覆盖的都属于函数遮蔽</li>
</ol>
<h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><p>运行期多态的实现依赖于虚函数机制。当某个类声明了虚函数时，编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现。运行期多态通过虚函数发生于运行期</p>
<h1 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h1><h2 id="C程序编译过程"><a href="#C程序编译过程" class="headerlink" title="C程序编译过程"></a>C程序编译过程</h2><ol>
<li><strong>预处理</strong>：处理以 # 开头的指令；将.c 文件转化成 .i文件</li>
<li><strong>编译和优化</strong>：将源码 .i 文件翻译成 .s 汇编代码；</li>
<li><strong>汇编</strong>：将汇编代码 .s 翻译成机器指令 .o 文件；</li>
<li><strong>链接</strong>：链接程序的主要工作就是将有关的目标文件连接起来<br>.o文件无法立即执行，原因：1.某个源文件调用了另一个源文件中的函数或常量2.在程序中调用了某个库文件中的函数</li>
</ol>
<p><img data-src="/mybook.github.io/images/2944424248989.png"></p>
<h2 id="gdb的工作原理"><a href="#gdb的工作原理" class="headerlink" title="gdb的工作原理"></a>gdb的工作原理</h2><p>通过一个系统调用：ptrace。ptrace系统调用的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *addr, <span class="type">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>说明：ptrace系统调用提供了一种方法来让父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。 主要用来实现断点调试和系统调用跟踪。（man手册）</p>
<p>下面我们来看ptrace函数中request参数的一些主要选项：</p>
<ul>
<li>PTRACE_TRACEME： 表示本进程将被其父进程跟踪，交付给这个进程的所有信号，即使信号是忽略处理的（除SIGKILL之外），都将使其停止，父进程将通过wait()获知这一情况。</li>
<li>这是什么意思呢？我们可以结合到gdb上来看。如果在gdb中run一个程序，首先gdb会fork一个子进程，然后该子进程调用ptrace系统调用，参数就是PTRACE_TRACEME，然后调用一个exec执行程序。基本过程是这样，细节上可能会有出入。需要注意的是，这个选项PTRACE_TRACEME是由子进程调用的而不是父进程！</li>
</ul>
<p>以下选项都是由父进程调用：</p>
<ul>
<li>PTRACE_ATTACH：attach到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次PTRACE_TRACEME操作。但是，需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进程使用getppid()的到的仍将是其原始父进程的pid。</li>
<li>这下子gdb的attach功能也就明朗了。当你在gdb中使用attach命令来跟踪一个指定进程&#x2F;线程的时候，gdb就自动成为改进程的父进程，而被跟踪的进程则使用了一次PTRACE_TRACEME，gdb也就顺理成章的接管了这个进程。</li>
</ul>
<p>PTRACE_CONT：继续运行之前停止的子进程。可同时向子进程交付指定的信号。</p>
<ul>
<li>这个选项呢，其实就相当于gdb中的continue命令。当你使用continue命令之后，一个被gdb停止的进程就能继续执行下去，如果有信号，信号也会被交付给子进程。</li>
</ul>
<h2 id="库和链接"><a href="#库和链接" class="headerlink" title="库和链接"></a>库和链接</h2><h3 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h3><h4 id="静态库（-a、-lib）特点总结"><a href="#静态库（-a、-lib）特点总结" class="headerlink" title="静态库（.a、.lib）特点总结"></a>静态库（.a、.lib）特点总结</h4><p>静态库，在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p>
<ul>
<li>静态库对函数库的链接是放在编译时期完成的。</li>
<li>程序在运行时与函数库再无瓜葛，移植方便。</li>
<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>
</ul>
<p>Linux创建静态库过程如下：</p>
<ol>
<li>首先，将代码文件编译成目标文件.o（StaticMath.o）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ -c StaticMath.cpp <span class="comment">//注意带参数-c，否则直接编译为可执行文件</span></span><br></pre></td></tr></table></figure></li>
<li>然后，通过ar工具将目标文件打包成.a静态库文件<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ar -crv libstaticmath.a StaticMath.o</span><br></pre></td></tr></table></figure></li>
<li>生成静态库libstaticmath.a。</li>
</ol>
<h4 id="动态库（-so、-dll）特点总结"><a href="#动态库（-so、-dll）特点总结" class="headerlink" title="动态库（.so、.dll）特点总结"></a>动态库（.so、.dll）特点总结</h4><ul>
<li>动态库把对一些库函数的链接载入推迟到程序运行的时期。</li>
<li>可以实现进程之间的资源共享。（因此动态库也称为共享库）</li>
<li>将一些程序升级变得简单。</li>
<li>甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）。</li>
<li>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。</li>
</ul>
<p>Linux创建动态库过程如下：</p>
<ol>
<li>首先，生成目标文件，此时要加编译器选项-fpic<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ -fPIC -c DynamicMath.cpp <span class="comment">//-fPIC 创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</span></span><br></pre></td></tr></table></figure></li>
<li>然后，生成动态库，此时要加链接器选项-shared<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">g++ -shared -o libdynmath.so DynamicMath.o <span class="comment">//-shared指定生成动态链接库。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h3><ul>
<li><p>静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</p>
</li>
<li><p>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</p>
</li>
</ul>
<h4 id="二者的优缺点"><a href="#二者的优缺点" class="headerlink" title="二者的优缺点"></a>二者的优缺点</h4><ul>
<li><p>静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</p>
</li>
<li><p>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</p>
</li>
</ul>
<h2 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h2><p>GCC:GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言。</p>
<ul>
<li>gcc是GCC中的GUN C Compiler（C 编译器）</li>
<li>g++是GCC中的GUN C++ Compiler（C++编译器）</li>
</ul>
<h3 id="gcc和g-的主要区别"><a href="#gcc和g-的主要区别" class="headerlink" title="gcc和g++的主要区别"></a>gcc和g++的主要区别</h3><ol>
<li>对于* .c和* .cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）</li>
<li>对于* .c和* .cpp文件，g++则统一当做cpp文件编译</li>
<li>使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL</li>
<li>gcc在编译C文件时，可使用的预定义宏是比较少的</li>
<li>gcc在编译cpp文件时&#x2F;g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __GXX_WEAK__ 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __cplusplus 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DEPRECATED 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GNUG__ 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __EXCEPTIONS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __private_extern__ extern</span></span><br></pre></td></tr></table></figure></li>
<li>在用gcc编译c++文件时，为了能够使用STL，需要加参数 –lstdc++ ，但这并不代表 gcc –lstdc++ 和 g++等价。<br>误区:编译只能用gcc，链接只能用g++<br>编译可以用gcc&#x2F;g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。</li>
</ol>
<h1 id="深入C"><a href="#深入C" class="headerlink" title="深入C++"></a>深入C++</h1><h2 id="C-的内存"><a href="#C-的内存" class="headerlink" title="C++的内存"></a>C++的内存</h2><p>可以结合操作系统–内存篇学习</p>
<h3 id="C-C-内存分布"><a href="#C-C-内存分布" class="headerlink" title="C&#x2F;C++内存分布"></a>C&#x2F;C++内存分布</h3><ol>
<li>BSS段（bss）：通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS段属于静态内存分配。</li>
<li>数据段（data）：通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。<br><strong>全局数据区(静态存储区)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放</strong></li>
<li>代码段（code &#x2F;text）：通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
<li>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>
<li>栈(stack)：存<strong>放函数的局部变量、函数参数、返回地址等</strong>，由编译器自动分配和释放，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，<strong>static意味着在数据段中存放变量</strong>）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存&#x2F;恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
</ol>
<p>从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 –&gt; .data 段 –&gt; .bss 段 –&gt; 堆 –&gt; unused –&gt; 栈 –&gt; env</p>
<p><img data-src="/mybook.github.io/images/5352252191017.png"></p>
<h3 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h3><ol>
<li><p>申请方式：栈是系统自动分配，堆是程序员主动申请。</p>
</li>
<li><p>申请后系统响应：</p>
</li>
</ol>
<ul>
<li>分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；</li>
<li>申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</li>
</ul>
<ol start="3">
<li><p>栈在内存中是连续的一块空间<strong>（向低地址扩展）</strong>最大容量是系统预定好的，堆在内存中的空间<strong>（向高地址扩展）</strong>是不连续的。</p>
</li>
<li><p>申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</p>
</li>
<li><p>存放内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</p>
</li>
</ol>
<h3 id="new与malloc区别"><a href="#new与malloc区别" class="headerlink" title="new与malloc区别"></a>new与malloc区别</h3><ol>
<li>malloc与free是c++&#x2F;c语言的标准函数，new&#x2F;delete是C++的运算符，  C++允许重载new&#x2F;delete操作符</li>
<li>new&#x2F;delete比malloc&#x2F;free更加智能，其实底层也是执行的malloc&#x2F;free。因为new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。</li>
<li>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</li>
<li>new返回指定类型的指针，并且可以自动计算出所需要的大小。malloc必须用户指定大小，并且默认返回类型为void*,必须强行转换为实际类型的指针。</li>
<li>申请的内存所在位置<br>new操作符从自由存储区(free store)上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。<br>那么自由存储区是否能够是堆，这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</li>
<li>对数组的处理<br>C++提供了new[]与delete[]来专门处理数组类型:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A * ptr = <span class="keyword">new</span> A[<span class="number">10</span>];<span class="comment">//分配10个A对象</span></span><br></pre></td></tr></table></figure>
使用new[]分配的内存必须使用delete[]进行释放：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] ptr;</span><br></pre></td></tr></table></figure>
new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。<br>至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * ptr = (<span class="type">int</span> *) <span class="built_in">malloc</span>( <span class="built_in">sizeof</span>(<span class="type">int</span>)* <span class="number">10</span> );<span class="comment">//分配一个10个int元素的数组</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="C-中内存泄漏的几种情况"><a href="#C-中内存泄漏的几种情况" class="headerlink" title="C++中内存泄漏的几种情况"></a>C++中内存泄漏的几种情况</h3><ol>
<li><p>在类的构造函数和析构函数中没有匹配的调用new和delete函数<br>一是在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；<br>二是在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存</p>
</li>
<li><p>没有正确地清除嵌套的对象指针（share_ptr）</p>
</li>
<li><p>在释放对象数组时在delete中没有使用方括号<br>方括号是告诉编译器这个指针指向的是一个对象数组，同时也告诉编译器正确的对象地址值并调用对象的析构函数，如果没有方括号，那么这个指针就被默认为只指向一个对象，对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。如果在方括号中间放了一个比对象数组大小还大的数字，那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。如果方括号中间的数字值比对象数组的大小小的话，编译器就不能调用足够多个析构函数，结果会造成内存泄露。<br>释放单个对象、单个基本数据类型的变量或者是基本数据类型的数组不需要大小参数，释放定义了析构函数的对象数组才需要大小参数。</p>
</li>
<li><p>指向对象的指针数组不等同于对象数组<br>对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间<br>指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。</p>
</li>
<li><p>缺少拷贝构造函数<br>两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。<br>按值传递会调用（拷贝）构造函数，引用传递不会调用。<br>在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员，如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。<br>所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符</p>
</li>
<li><p>缺少重载赋值运算符<br>这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露，如下图:</p>
</li>
</ol>
<p><img data-src="/mybook.github.io/images/3373632189087.png"></p>
<ol start="7">
<li><p>关于nonmodifying运算符重载的常见迷思<br>a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针<br>b. 返回内部静态对象的引用。<br>c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收<br>解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&amp;而是int</p>
</li>
<li><p>没有将基类的析构函数定义为虚函数<br>当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露</p>
</li>
<li><p>野指针：指向被释放的或者访问受限内存的指针。<br>造成野指针的原因：<br>指针变量没有被初始化（如果值不定，可以初始化为NULL）<br>指针被free或者delete后，没有置为NULL, free和delete只是把指针所指向的内存给释放掉，并没有把指针本身干掉，此时指针指向的是“垃圾”内存。释放后的指针应该被置为NULL.<br>指针操作超越了变量的作用范围，比如返回指向栈内存的指针就是野指针。</p>
</li>
</ol>
<h2 id="struct与class"><a href="#struct与class" class="headerlink" title="struct与class"></a>struct与class</h2><h3 id="C中的struct与C-中struct的区别"><a href="#C中的struct与C-中struct的区别" class="headerlink" title="C中的struct与C++中struct的区别"></a>C中的struct与C++中struct的区别</h3><ol>
<li><p>成员<br>C中的struct将一系列数据放在一个结构体中统一管理，只有数据，没有函数。<br>C++中的struct允许同时又函数和数据出现，允许通过构造函数进行初始化等。</p>
</li>
<li><p>访问权限<br>C中的struct没有访问权限的设定，也就是说对外并没有隐藏数据的做法。<br>C++中的struct有访问权限的设定，private、protected、public三种。默认的访问权限是public。</p>
</li>
<li><p>是否可以继承<br>C中struct不存在继承的关系。<br>C++中struct可以继承class和struct，也可以被class和struct继承。<br><img data-src="/mybook.github.io/images/1304608150642.png"></p>
</li>
</ol>
<h3 id="C-中struct与class的区别"><a href="#C-中struct与class的区别" class="headerlink" title="C++中struct与class的区别"></a>C++中struct与class的区别</h3><ol>
<li><p>在C++中，为了保持对于C的兼容，保留了struct，并在此基础上对struct进行了扩充。<br>C++中的struct可以包含成员函数，可以继承，可以实现多态，但是在C++中的struct还是与class有一些区别的：<br>首先明确，struct是一个数据结构的实现体；而class更像是一个对象的实现体。</p>
</li>
<li><p>默认的访问权限不同<br>struct默认的访问权限是public的，class默认的访问权限是private的。<br>但是我们在平时应该习惯在程序里明确指出某个数据&#x2F;成员的访问权限，而不是靠默认，这是个比较好的编程习惯。</p>
</li>
<li><p>默认的继承访问权限不同<br>对于默认的继承访问权限：<br>struct是public的，而class是private的。<br>并且要注意的是，C++中，struct可以继承struct也可以继承class，class也是一样，可以继承struct也可以继承class。因此默认的继承访问权限是取决于子类，而不是取决于基类。<br>也就是说：struct做子类的时候，默认是public的；class做子类的时候，默认是private的。与基类无关。</p>
</li>
<li><p>定义模板参数<br>class关键字可以用于定义模板参数，而struct不能。</p>
</li>
</ol>
<h2 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h2><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数默认第一个参数为T* const this。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; &#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>func的原型在编译器看来应该是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(A* <span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span>  p)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。</p>
</li>
<li><p>this指针不会影响sizeof(对象)的结果。任何对类成员的直接访问都被看成this的隐式使用。</p>
</li>
<li><p>每个对象都拥有一个this指针，通过this指针来访问自己的地址，所以this是一个常量指针，我们不允许改变this中保存的地址</p>
</li>
<li><p>this只能在成员函数中使用。全局函数，静态函数不能使用this。（原因：静态函数不属于具体的对象）</p>
</li>
</ul>
<ol>
<li><p>this指针是什么时候创建的？<br><strong>this在成员函数的开始执行前构造，在成员的执行结束后清除。</strong></p>
</li>
<li><p>this指针存放在何处？堆、栈、全局变量，还是其他？<br>this指针会因编译器不同而又不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。</p>
</li>
<li><p>我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？<br>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
</li>
</ol>
<h2 id="extern-“C”的作用"><a href="#extern-“C”的作用" class="headerlink" title="extern “C”的作用"></a>extern “C”的作用</h2><p>“提示”编译器，下面的文件和函数，要用C语言的命名规则进行。<br>所以加入要在A.cpp中使用C语言的B.lib库文件中的在xx.h中定义的导出函数CFun()，需要这么做。</p>
<ol>
<li>首先将这个库文件链接到我们的工程中。</li>
<li>声明<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;abc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">CFun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
但是我发现，有时候不使用extern “C”的方式(而是直接#include “”….)也可以使用这类函数，原因我分析如下：</li>
<li>那个库文件并不是纯正的C语言下环境下编译而成的(具体是环境是在.c文件中使用了C++中的关键字)。</li>
<li>extern “C”只是一种“提示”，而不是强制性命令编译器，具体是要不要用C语言规则，让编译器自己去判断。</li>
</ol>
<p>在C语言的库文件中，”abc.h”包含如下定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">﻿<span class="meta">#<span class="keyword">ifdef</span> __cplusplus  <span class="comment">//在C++编译环境下</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，在”abc.c”中 #include “abc.h”进行编译的时候，#ifdef__cplusplus并不会生效，因为当前是C语言的编译环境。<br>而在外部”abc.cpp”中  #include “abc.h” #ifdef __cplusplus就会生效了，所以可以用C语言的方式进行编译。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数机制：</p>
<ol>
<li>定义一个函数（普通函数即可）；</li>
<li>将此函数的地址注册给调用者；</li>
<li>特定的事件或条件发生时，调用者使用函数指针调用回调函数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*callback)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,callback p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*p)(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *args[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">add</span>(<span class="number">4</span>,<span class="number">2</span>,add);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，可以看到，我们定义了一个callbak的函数指针，参数为两个int，返回值为int，通过调用函数地址来进行简单的相加运算。</p>
<h2 id="define和inline"><a href="#define和inline" class="headerlink" title="define和inline"></a>define和inline</h2><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><p>宏定义在形式及使用上像一个函数，但它使用预处理器实现，没有了参数压栈，代码生成等一系列的操作,因此，效率很高<br>缺点：</p>
<ol>
<li>宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，和局限性。</li>
<li>宏不能访问对象私有成员。</li>
<li>#define用参数时，是严格的替换策略。无论你得参数时何种形式，在展开代码中都是用形参替换实参。这样，宏的定义很容易产生二意性，它的使用就存在着一系列的隐患</li>
</ol>
<p>　</p>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">调用：cout&lt;&lt;<span class="built_in">max</span>(a, b)&lt;&lt;endl;</span><br><span class="line">在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1.内联函数在运行时可调试，而宏定义不可以;<br>2.编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会；<br>3.内联函数可以访问类的成员变量，宏定义则不能；</p>
<h2 id="include重复引入问题"><a href="#include重复引入问题" class="headerlink" title="include重复引入问题"></a>include重复引入问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//student.h</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//school.h</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">School</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> </span><br><span class="line">    Student stu[<span class="number">50</span>];</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;student.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;school.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>编译器报“Student 类型重定义”错误</strong></p>
<h3 id="使用宏定义避免重复引入"><a href="#使用宏定义避免重复引入" class="headerlink" title="使用宏定义避免重复引入"></a>使用宏定义避免重复引入</h3><p>在实际多文件开发中，我们往往使用如下的宏定义来避免发生重复引入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _NAME_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NAME_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//头文件内容</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中，_NAME_H 是宏的名称。这里设置的宏名必须是独一无二的<br>当程序中第一次 #include 该文件时，由于_NAME_H 尚未定义，所以会定义_NAME_H并执行“头文件内容”部分的代码；当发生多次 #include 时，因为前面已经定义了 _NAME_H，所以不会再重复执行“头文件内容”部分的代码。<br>student.h 文件做如下修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STUDENT_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STUDENT_H</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>虽然该项目 main.cpp 文件中仍 #include 了 2 次 “student.h”，但鉴于 _STUDENT_H 宏只能定义一次，所以 Student 类也仅会定义一次。再次执行该项目会发现，其可以正常执行。</p>
<h3 id="使用-pragma-once避免重复引入"><a href="#使用-pragma-once避免重复引入" class="headerlink" title="使用#pragma once避免重复引入"></a>使用#pragma once避免重复引入</h3><p>使用 #pragma once指令，将其附加到指定文件的最开头位置，则该文件就只会被 #include 一次。<br>我们知道，#ifndef 是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。但考虑到 C 和 C++ 都支持宏定义，所以项目中使用 #ifndef 规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。<br>和 ifndef 相比，#pragma once 不涉及宏定义，当编译器遇到它时就会立刻知道当前文件只引入一次，所以效率很高。<br><strong>除此之外，#pragma once 只能作用于某个具体的文件，而无法向 #ifndef 那样仅作用于指定的一段代码。</strong><br>将其内容修改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用-Pragma操作符"><a href="#使用-Pragma操作符" class="headerlink" title="使用_Pragma操作符"></a>使用_Pragma操作符</h3><p>C99 标准中新增加了一个和 #pragma 指令类似的 _Pragma 操作符，其可以看做是 #pragma 的增强版，不仅可以实现 #pragma 所有的功能，更重要的是，_Pragma 还能和宏搭配使用。<br>当处理头文件重复引入问题时，可以将如下语句添加到相应文件的开头：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">_Pragma</span>(<span class="string">&quot;once&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>比如，将该语句添加到前面项目中 student.h 文件中的开头位置，再次执行项目，其可以正常执行。<br>事实上，无论是 C 语言还是 C++，<strong>为防止用户重复引入系统库文件，几乎所有库文件中都采用了以上 3 种结构中的一种，这也是为什么重复引入系统库文件编译器也不会报错的原因。</strong></p>
<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><h3 id="指针传递的实质"><a href="#指针传递的实质" class="headerlink" title="指针传递的实质"></a>指针传递的实质</h3><p>形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作</p>
<h3 id="引用传递的实质"><a href="#引用传递的实质" class="headerlink" title="引用传递的实质"></a>引用传递的实质</h3><p>被调函数的形参也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的<mark>实参的地址</mark>。被调函数对形参的任何操作都被处理成<mark>间接寻址</mark>，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ol>
<li>指针是一个实体，而引用仅是个别名；</li>
<li>引用只能在定义时被初始化一次，之后不可变；指针可变；</li>
<li>引用不能为空，指针可以为空；</li>
<li>“sizeof引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；32位操作系统返回值4，64位操作系统返回值8</li>
<li>引用是类型安全的，而指针不是 （引用比指针多了类型检查）</li>
</ol>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="C-语言的-static-关键字有三种（具体来说是两种）用途："><a href="#C-语言的-static-关键字有三种（具体来说是两种）用途：" class="headerlink" title="C 语言的 static 关键字有三种（具体来说是两种）用途："></a>C 语言的 static 关键字有三种（具体来说是两种）用途：</h3><h4 id="静态局部变量：用于函数体内部修饰变量，这种变量的生存期长于该函数。"><a href="#静态局部变量：用于函数体内部修饰变量，这种变量的生存期长于该函数。" class="headerlink" title="静态局部变量：用于函数体内部修饰变量，这种变量的生存期长于该函数。"></a>静态局部变量：用于函数体内部修饰变量，<mark>这种变量的生存期长于该函数</mark>。</h4><p>对于一个完整的程序，在内存中的分布情况如下图：　 </p>
<ul>
<li>栈区： 由编译器自动分配释放，像局部变量，函数参数，都是在栈区。会随着作用于退出而释放空间。</li>
<li>全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。</li>
<li>堆区：程序员分配并释放的区域，像malloc(c),new(c++) </li>
<li>代码区<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// note:1</span></span><br><span class="line">    <span class="comment">//int i = 1;  // note:2</span></span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>它存在的意义就是随着第一次函数的调用而初始化，却不随着函数的调用结束而销毁(如果把以上的note:1换成note:2,那么i就是在栈区分配了，会随着foo的调用结束而释放)。</li>
<li>它是在第一次调用进入note:1的时候初始化（当初面试被坑过，我居然说是一开始就初始化了）。且只初始化一次，也就是你第二次调用foo(),不会继续初始化，而会直接跳过。</li>
</ol>
<p>那么它跟定义一个全局变量有什么区别呢，同样是初始化一次，连续调用foo()的结果是一样的，<strong>但是，使用全局变量的话，变量就不属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</strong></p>
<p>那么我们总结一下，静态局部变量的特点（括号内为note:2,也就是局部变量的对比）：</p>
<ol>
<li>该变量在全局数据区分配内存(局部变量在栈区分配内存);</li>
<li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);</li>
<li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);</li>
<li>它始终驻留在全局数据区，直到程序运行结束。但<strong>其作用域为局部作用域，也就是不能在函数体外面使用它</strong>(局部变量在栈区，在函数结束后立即释放内存);</li>
</ol>
<h4 id="静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见"><a href="#静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见" class="headerlink" title="静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见"></a>静态全局变量：定义在函数体外，用于修饰全局变量，<mark>表示该变量只在本文件可见</mark></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//note:3</span></span><br><span class="line"><span class="comment">//int i = 1;  //note:4</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我有一个文件a.c,我们再新建一个b.c,内容如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file a.c</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//static int n = 15;  //note:5</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">15</span>;  <span class="comment">//note:6</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//file b.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;after: %d\n&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;before: %d\n&quot;</span>,n);</span><br><span class="line">	<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们先使用note:6,也就是非静态全局变量，发现输出为:<br>before: 15<br>after: 16</p>
<p>也就是我们的b.c通过extern使用了a.c定义的全局变量。<br>那么我们改成使用note:5,也就是使用静态全局变量呢？会出现类似undeference to “n”的报错，它是找不到n的，因为static进行了<mark>文件隔离</mark>，你是没办法访问a.c定义的静态全局变量的，当然你用 #include “a.c”,那就不一样了。</p>
<p>以上我们就可以得出静态全局变量的特点：</p>
<ol>
<li>静态全局变量不能被其它文件所用(全局变量可以);</li>
<li>其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了);</li>
</ol>
<h4 id="静态函数：-准确的说，静态函数跟静态全局变量的作用类似："><a href="#静态函数：-准确的说，静态函数跟静态全局变量的作用类似：" class="headerlink" title="静态函数： 准确的说，静态函数跟静态全局变量的作用类似："></a>静态函数： 准确的说，静态函数跟静态全局变量的作用类似：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this is non-static func in a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//file b.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">fn</span><span class="params">()</span></span>;  <span class="comment">//我们用extern声明其他文件的fn(),供本文件使用。</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以正常输出：this is non-static func in a。当给void fn()加上static的关键字之后呢？ undefined reference to “fn”.</p>
<p>所以，静态函数的好处跟静态全局变量的好处就类似了：</p>
<ol>
<li>静态函数不能被其它文件所用;</li>
<li>其它文件中可以定义相同名字的函数，不会发生冲突;</li>
</ol>
<p>上面一共说了三种用法，为什么说准确来说是两种呢？</p>
<ol>
<li>一种是修饰变量，一种是修饰函数，所以说是两种（这种解释不多）。</li>
<li>静态全局变量和修饰静态函数的作用是一样的，一般合并为一种。（这是比较多的分法）。</li>
</ol>
<h3 id="C-语言的-static-关键字有额外二种用途："><a href="#C-语言的-static-关键字有额外二种用途：" class="headerlink" title="C++ 语言的 static 关键字有额外二种用途："></a>C++ 语言的 static 关键字有额外二种用途：</h3><h4 id="静态数据成员："><a href="#静态数据成员：" class="headerlink" title="静态数据成员："></a>静态数据成员：</h4><p>用于修饰 class 的数据成员，即所谓“静态成员”。这种数据成员的生存期大于 class 的对象（实体 instance）。静态数据成员是每个 class 有一份，普通数据成员是每个 instance 有一份，因此静态数据成员也叫做类变量，而普通数据成员也叫做实例变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_w,m_h;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_sum;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rectangle</span>(<span class="type">int</span> w,<span class="type">int</span> h)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_w = w;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_h = h;</span><br><span class="line">		s_sum += (<span class="keyword">this</span>-&gt;m_w * <span class="keyword">this</span>-&gt;m_h);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GetSum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;s_sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> Rectangle::s_sum = <span class="number">0</span>;  <span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<p>static 并不占用Rectangle的内存空间，static在全局数据区(静态区)分配内存的。static只会被初始化一次，于实例无关。<br>对于非静态数据成员，每个类对象(实例)都有自己的拷贝。而静态数据成员被当作是类的成员，由该类型的所有对象共享访问,对该类的多个对象来说，静态数据成员只分配一次内存。<br>静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。<br>也就是说，你每new一个Rectangle，并不会为static int s_sum的构建一份内存拷贝，它是不管你new了多少Rectangle的实例，因为它只与类Rectangle挂钩，而跟你每一个Rectangle的对象没关系。</p>
<h4 id="静态成员函数：用于修饰-class-的成员函数。"><a href="#静态成员函数：用于修饰-class-的成员函数。" class="headerlink" title="静态成员函数：用于修饰 class 的成员函数。"></a>静态成员函数：用于修饰 class 的成员函数。</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_w,m_h;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_sum;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rectangle</span>(<span class="type">int</span> w,<span class="type">int</span> h)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_w = w;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_h = h;</span><br><span class="line">		s_sum += (<span class="keyword">this</span>-&gt;m_w * <span class="keyword">this</span>-&gt;m_h);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetSum</span><span class="params">()</span>  <span class="comment">//这里加上static</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;sum = &quot;</span>&lt;&lt;s_sum&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> Rectangle::s_sum = <span class="number">0</span>;  <span class="comment">//初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面注释可见:对GetSum()加上static，使它变成一个静态成员函数，可以用类名::函数名进行访问。</p>
<ol>
<li>静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;</li>
<li>非静态成员函数可以任意地访问静态成员函数和静态数据成员;</li>
<li>静态成员函数不能访问非静态成员函数和非静态数据成员;</li>
<li>调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)</li>
</ol>
<h5 id="为什么静态成员不能在类内初始化"><a href="#为什么静态成员不能在类内初始化" class="headerlink" title="为什么静态成员不能在类内初始化"></a>为什么静态成员不能在类内初始化</h5><p>在C++中，类的静态成员（static member）必须在类内声明，在类外初始化，像下面这样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count ; <span class="comment">// 类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::count = <span class="number">0</span> ; <span class="comment">// 类外初始化，不必再加static关键字</span></span><br></pre></td></tr></table></figure>
<p>为什么？<mark>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。</mark></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态成员不能在类内初始化</span></span><br><span class="line">&#125;;</span><br><span class="line">错误</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 常量成员也不能在类内初始化</span></span><br><span class="line">&#125;;</span><br><span class="line">错误</span><br></pre></td></tr></table></figure>
<p>能在类中初始化的成员只有一种，那就是静态常量成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 静态常量成员可以在类内初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="数据成员初始化位置："><a href="#数据成员初始化位置：" class="headerlink" title="数据成员初始化位置："></a>数据成员初始化位置：</h5><ol>
<li>静态常量数据成员可以在类内初始化(即类内声明的同时初始化)，也可以在类外，即类的实现文件中初始化，不能在构造函数中初始化，也不能在构造函数的初始化列表中初始化；</li>
<li>静态非常量数据成员只能在类外，即类的实现文件中初始化，也不能在构造函数中初始化，不能在构造函数的初始化列表中初始化；</li>
<li>非静态的常量数据成员不能在类内初始化，也不能在构造函数中初始化，而只能且必须在构造函数的初始化列表中初始化；</li>
<li>非静态的非常量数据成员不能在类内初始化，可以在构造函数中初始化，也可以在构造函数的初始化列表中初始化；</li>
</ol>
<p><img data-src="/mybook.github.io/images/2939959150567.png"></p>
<h5 id="为什么静态成员函数只能访问静态成员变量"><a href="#为什么静态成员函数只能访问静态成员变量" class="headerlink" title="为什么静态成员函数只能访问静态成员变量"></a>为什么静态成员函数只能访问静态成员变量</h5><ol>
<li>静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的。</li>
<li>静态成员函数产生在前，非静态成员函数产生在后。类的静态成员在类加载的时候就已经分配内存，而此时类的非静态成员尚未分配内存，当且仅当实例化对象之后才存在，访问内存中不存在的东西自然会出错。</li>
<li>内部访问静态成员用self：：，而访问非静态成员要用this指针，静态成员函数没有this指针，故不能访问。</li>
</ol>
<h5 id="为什么静态成员函数只能访问静态成员变量-1"><a href="#为什么静态成员函数只能访问静态成员变量-1" class="headerlink" title="为什么静态成员函数只能访问静态成员变量"></a>为什么静态成员函数只能访问静态成员变量</h5><ol>
<li>静态成员函数只属于类本身，随着类的加载而存在，不属于任何对象，是独立存在的。</li>
<li>静态成员函数产生在前，非静态成员函数产生在后。类的静态成员在类加载的时候就已经分配内存，而此时类的非静态成员尚未分配内存，当且仅当实例化对象之后才存在，访问内存中不存在的东西自然会出错。</li>
<li>内部访问静态成员用self：：，而访问非静态成员要用this指针，静态成员函数没有this指针，故不能访问。</li>
</ol>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><ol>
<li>普通函数是静态编译的，没有运行时多态，只会根据指针或引用的“字面值”类对象，调用自己的普通函数。</li>
<li>普通函数是父类为子类提供的“强制实现”。</li>
<li>因此，在继承关系中，子类不应该重写父类的普通函数，因为函数的调用至于类对象的字面值有关。</li>
</ol>
<h3 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数"></a>虚函数</h3><ol>
<li>编译器检测到虚函数(virtual)时，会将虚函数的地址放到虚表(vftable)中，并且在类中增加一个指针：vfpter。</li>
<li>在对象初始化调用构造函数时，编译器会在编写的每一个构造函数中，增加vfpter初始化的代码，使它指向本对象的虚函数表。<strong>在多态调用的时候，根据vfpter指针，找到虚函数表来实现动态绑定</strong></li>
<li>子类继承基类的vfpter指针，这个指针指向基类虚函数表，当子类调用构造函数时，子类的vfpter指针便会指向子类的虚函数表。</li>
<li>当实例化子类时，检测到有虚函数的重写，编译器会用子类重写的虚函数地址覆盖掉之前父类的虚函数地址，</li>
<li>当调用虚函数时，检测到是虚函数就会从虚表中找对应的位置调用，若子类没有重写，虚表中的虚函数地址就还是父类的，若子类中有重写，虚表记录的就是子类重写的虚函数地址，即实现了父类的指针调用子类的函数</li>
<li>虚表中先记录父类中的虚函数地址，接着记录子类中虚函数地址(若子类重写父类的虚函数则是覆盖)</li>
<li>最后虚表还有一个尾值是 0</li>
</ol>
<h3 id="普通函数与虚函数的区别"><a href="#普通函数与虚函数的区别" class="headerlink" title="普通函数与虚函数的区别"></a>普通函数与虚函数的区别</h3><ol>
<li>调用流程不同：虚函数通过虚函数指针间接引用，普通函数可以使用函数名直接调用</li>
<li>调用效率不同：虚函数调用流程复杂，效率低，普通函数效率高</li>
<li>使用场景不同：虚函数的目的是为了实现多态</li>
<li>使用了虚函数，会增加访问内存开销，降低效率。</li>
</ol>
<h3 id="虚函数与纯虚函数区别"><a href="#虚函数与纯虚函数区别" class="headerlink" title="虚函数与纯虚函数区别"></a>虚函数与纯虚函数区别</h3><ol>
<li>虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，而只含有虚函数的类不能被称为抽象类。</li>
<li>虚函数可以被直接使用，也可以被子类重载以后以多态的形式调用，<strong>而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类只有声明而没有定义。</strong></li>
<li>在虚函数和纯虚函数的定义中不能有static标识符，原因很简单，被static修饰的函数在编译时候要求前期bind,然而虚函数却是动态绑定，而且被两者修饰的函数生命周期也不一样。</li>
<li>虚函数必须实现，如果不实现，编译器将报错</li>
<li>对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。</li>
</ol>
<h3 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h3><ol>
<li><strong>如果释放父类指针(指向子类的父类指针)，只会调用父类的析构函数，将父类的析构函数声明为虚函数，就会先调用子类的析构函数再调用父类的析构函数</strong>（子类中存放的是自己的析构函数）</li>
<li>父类的析构函数加了 virtual 修饰，delete 会调用子类和父类的析构函数，子类可以显式的加 virtual ，也可以不加， 默认是有的 virtual，</li>
</ol>
<h4 id="为什么使用虚析构"><a href="#为什么使用虚析构" class="headerlink" title="为什么使用虚析构"></a>为什么使用虚析构</h4><p>用对象指针来调用一个函数，有以下两种情况：</p>
<ol>
<li>如果是虚函数，会调用子类中的版本。（在有子类的情况下）</li>
<li>如果是非虚函数，会调用指针所指类型的实现版本。</li>
</ol>
<ul>
<li>当子类对象出了作用域，子类的析构函数会先调用，然后再调用它父类的析构函数， 这样能保证分配给对象的内存得到正确释放。</li>
<li>但是，如果我们删除一个指向派生类对象的基类指针，而基类析构函数又是非虚的话， 那么就会先调用基类的析构函数(上面第2种情况)，子类的析构函数得不到调用。</li>
</ul>
<h4 id="为什么不默认使用虚析构"><a href="#为什么不默认使用虚析构" class="headerlink" title="为什么不默认使用虚析构"></a>为什么不默认使用虚析构</h4><p>因为它会为类增加一个虚函数表，使得对象的体积翻倍，还有可能降低其可移植性。</p>
<h4 id="为什么构造函数不可以被声明为虚函数："><a href="#为什么构造函数不可以被声明为虚函数：" class="headerlink" title="为什么构造函数不可以被声明为虚函数："></a>为什么构造函数不可以被声明为虚函数：</h4><ol>
<li>因为创建一个对象时要确定对象的类型，而虚函数是在运行时确定其类型的，而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型。</li>
<li>如果构造函数是虚的，就需要通过虚表来调用，可是对象还没有构造，也就是内存空间还没有，无法找到虚表。所以构造函数不能是虚函数。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>非虚函数属于静态绑定：编译器在编译期间，根据指针（或对象）的类型完成了绑定。而对于虚函数，知道指针的类型也无济于事。假设 func() 为虚函数，p 的类型为 A，那么 p-&gt;func() 可能调用 A 类的函数，也可能调用 B、C 类的函数，不能根据指针 p 的类型对函数重命名。也就是说，虚函数在编译期间无法绑定。</p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><h3 id="无继承"><a href="#无继承" class="headerlink" title="无继承"></a>无继承</h3><p>类A定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> A_1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> A_2;</span><br><span class="line">	<span class="type">int</span> A_3;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun3</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> A::A_2 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这里给A定义了一个私有变量，一个静态变量、一个公有变量以及3个虚函数，现在来看看A的内存布局：</p>
<p> A的内存布局如下：</p>
<p><img data-src="/mybook.github.io/images/391070916250468.png"></p>
<p>从A的内存布局中可以知道：在无继承的情况下，对象内存布局中会先放置虚表指针vfptr，然后再按声明顺序存放数据成员。并且可以知道：虚表vftable中按声明先后顺序存放了A中定义的3个虚函数的地址，此外，类中定义的静态变量A_2并不存在于类中，并且类成员变量的访问权限也不会影响到成员的内存布局（比如这里的私有变量A_1和公有变量A_3是放在一起的）。</p>
<h3 id="一般继承"><a href="#一般继承" class="headerlink" title="一般继承"></a>一般继承</h3><h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h4><p>现在定义一个A的继承类B，类B定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> B_1;</span><br><span class="line">        <span class="type">int</span> B_2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//重写了A中定义的一个虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//定义了一个新的虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类B中，重写了父类A的虚函数Vfun1，并且定义了一个新的虚函数Vfun4，现在来看看B的内存布局：<br>B的内存布局如下：</p>
<p><img data-src="/mybook.github.io/images/18351216248072.png"></p>
<p>从这里可以看到，在类B中的前面，存放了类A的整个布局，即类A中的所有非静态数据成员都原封不动地放在了类B的前面，然后才是类B自己的数据成员B_1和B_2。不过值得注意的是，在类B的最前面，存放的依然是一个虚表指针vfptr，再来看vfptr所指的虚表中，由于类B重写了虚函数Vfun1，因此B中定义的虚函数的地址&amp;B::Vfun1覆盖了之前的&amp;A::Vfun1，并且在虚表最后还加上了类B中新定义的虚函数地址&amp;B::Vfun4。</p>
<p>因此我们可以得出以下结论：在子类的内存布局的最前面存放的是父类的内存布局，一开始依然是存放一个虚表指针，只不过这个虚表指针与父类的虚表指针是不一样的，这个虚表指针所指向的虚函数表中，会包含所有父类中的虚函数（不一定是父类所定义的，也可能是父类从爷爷类继承下来的虚函数）的地址以及子类中新定义的虚函数的地址，如果子类对虚函数进行了重写，那么重写后的虚函数地址将会覆盖相应的父类虚函数地址。这也说明了如果父类和子类中有不同的虚函数，最终在子类中也只有一个虚表指针，对应一个虚函数表。</p>
<p>那么要是多层继承也是这样吗？</p>
<h4 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h4><p>现在来定义一个类C，用于继承类B，类C的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> C_1;</span><br><span class="line">	<span class="type">int</span> C_2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写了B中定义的虚函数（这个函数在B中也是重写的A定义的虚函数）</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写了A中定义的虚函数（这个函数在B中未被重写）</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写了B中新定义的虚函数（这个函数未在A中定义）</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun5</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//定义了一个新的虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在先不看C的内存布局结果，试着来推测一下：</p>
<p>首先，如前所述：子类的内存布局最前面存放的是父类的内存布局，因此在类C的内存布局中，最开始应当存放一个类B的布局，相当于直接把上面B的内存布局搬到C中，最前面依然是一个虚表指针vfptr，只不过这个虚表指针与原先B中的虚表指针完全不一样。接着在B的布局之后，则应当是按照声明顺序存放的C中的成员变量，如下所示：</p>
<p><img data-src="/mybook.github.io/images/487141316245574.png"></p>
<p>再来看虚表中的内容：根据前面所分析的，如果C中没有进行任何的虚函数的声明定义，那么C中虚表指针所指虚表中应当与B中虚表指针所指虚表的内容一样了。而现在类C重写了Vfun1，Vfun2和Vfun4，并且新定义了一个虚函数Vfun5，那么虚表中的内容应当如下所示：（黑色表示未发生重写的父类虚函数，蓝色表示重写的虚函数，紫色表示新定义的虚函数）</p>
<p><img data-src="/mybook.github.io/images/54181416226815.png"></p>
<p>有了上述的分析，再来看下类C实际的内存布局：</p>
<p><img data-src="/mybook.github.io/images/198691416249255.png"></p>
<p>由此可见，完全符合前面的分析结果。</p>
<p>为了考虑更多的情况，下面再来分析一下多重继承的情况。</p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>多重继承的是指一个子类含多个不同的父类。为了验证这种情况，将B与A的继承关系取消，让C同时继承自A和B，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> A_1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> A_2;</span><br><span class="line">	<span class="type">int</span> A_3;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun3</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::A_2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> B_1;</span><br><span class="line">	<span class="type">int</span> B_2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C_1;</span><br><span class="line">	<span class="type">int</span> C_2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//A中和B中均含有Vfun1虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//重写A中的虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//重写B中的虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun5</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//新定义虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>这时候的C同时继承A和B，并且重写了一个A和B中均定义了的虚函数，为了考虑所有因素，现在来分别看看类C先继承A再继承B和先继承B再继承A的各自内存布局是怎样的？</p>
<p><img data-src="/mybook.github.io/images/205501616244391.png">   <img data-src="/mybook.github.io/images/276331616237937.png"></p>
<p>左图为类C先继承A再继承B，由图为先继承B再继承A，分析两种情况可以发现，C的内存布局中，先按照继承顺序包含父类的布局，然后才是C中定义的数据成员。不过尤其需要注意的是，C的内存布局中所包含的每一个父类的布局最开始都各自含有一个虚表指针vfptr，也就是说，有几个父类就会有虚表指针，自然也就有几个虚表了。这里的C类继承自两个类，因此就有两个虚表指针，也就对应两个虚表，这里设定为vftA和vftB，现在来看看两个虚表中的内容。</p>
<p>当先继承A再继承B的时候，虚函数的覆盖情况如下：</p>
<p><img data-src="/mybook.github.io/images/463331616231071.png"></p>
<p>这里有个需要注意的地方，C中重写的Vfun1在A和B中都有定义，此时在vftA中有Vfun1的地址，而在vftB中显示的是this-&#x3D;12,goto C::Vfun1，这是什么意思呢？注意到vftB的偏移量本身就是12，而vftA的偏移量为0，因此在C的内存布局中vftB虚表指针的地址 &#x3D; vftA虚表指针的地址+12，而这里有一个this-&#x3D;12，相当于访问vftB的时候又回到了vftA的位置，此时访问的函数还是C::Vfun1。可以写一段程序测试一下：</p>
<p><img data-src="/mybook.github.io/images/120981716221601.png"></p>
<p>这也就表示vftA所指虚表中第一个虚函数的地址与vftB所指虚表中第一个虚函数的地址是完全相同的，都是指向Vfun1函数。</p>
<p>另外一个需要注意的地方是：C中新定义了一个Vfun5，而该虚函数的地址，是存放在vftA中的。</p>
<p>当先继承B然后继承A时，情况和上述类似，这里就不多说了。</p>
<p>由此可以得出结论：当一个子类C继承于多个相互独立的父类的时候，会先按照继承的先后顺序存放每个父类的内存布局，然后才是子类定义的数据成员。而在子类下的每个父类对应的布局中都有一个虚表指针各自对应一个虚函数表，各个虚函数表的构成只需关注该父类中的虚函数是否在子类中重写，如2.1中单继承所示。如果子类中新定义了一个虚函数，那么这个虚函数的地址会放在子类布局下先声明继承的那个父类对应的虚表中；如果子类重写了多个父类定义的同名虚函数（如这里的Vfun1），那么在子类布局下每个父类对应的虚表中都会有被重写的虚函数的地址。</p>
<p>那么，要是子类所继承的多个父类之间也有关系呢？下面就拿菱形继承为例进行分析。</p>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>  菱形继承的含义是在设定的多层继承基础上，类A和类B又同时继承于同一个父类。因此这里先定义一个类D，然后让类A和类B都继承它，这里给类D添加了如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> D_1;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun5</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun6</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:<span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> A_1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> A_2;</span><br><span class="line">	<span class="type">int</span> A_3;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写D中的Vfun1</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写D中的Vfun2</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun3</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//新定义的Vfun3</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::A_2 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> D</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> B_1;</span><br><span class="line">	<span class="type">int</span> B_2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写D中的Vfun1</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写D中的Vfun4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> C_1;</span><br><span class="line">	<span class="type">int</span> C_2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写Vfun1，该虚函数在父类A和父类B以及类D中都有定义</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写类D及类A中均有定义的虚函数Vfun2</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写类D及类B中均有定义的虚函数Vfun2</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun5</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//重写类D中定义，但类B和类C中未定义的Vfun5</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun7</span><span class="params">()</span> </span>&#123;&#125;;   <span class="comment">//定义的新虚函数Vfun7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>查看C的内存布局如下所示：</p>
<p><img data-src="/mybook.github.io/images/210981816224105.png"><img data-src="/mybook.github.io/images/268671816233052.png"></p>
<p>整个过程的虚函数地址覆盖如图所示：（蓝色线表示有重写，黑色线表示无重写，红色字体表示为新定义虚函数）</p>
<p><img data-src="/mybook.github.io/images/405231816225937.png"></p>
<p>虽然举的例子复杂了点，但是从整个过程中也清楚了虚表内容的覆盖过程的：当子类继承自多个类时，每一个父类在子类中都有一个虚表指针，举个例子，类C继承自类A和类B，那么在类C中，会有一个虚表指针vfptrA和虚表指针vfptrB，vfptrA所指向的虚表内容，实际上就只用关注类C和类A之间的虚函数重写关系，这与类B没有任何关系，可以参考2.1；同样的，vfptrB所指向的虚表内容，就只用关注类C和类B之间的虚函数重写关系，和类A也没有任何关系。</p>
<p>简单来说，多重继承下的子类，每个父类在该子类中都对应一个虚函数表，而每个虚函数表的内容只用关注该子类与对应父类之间虚函数关系，与其他父类无关，如果子类重写的虚函数在多个父类中存在定义，那么每个父类与子类对应的虚表中都会存在这个虚函数的地址(实际上只有第一个声明继承的父类与子类对应的虚表中的才是直接存储的该虚函数的地址，其他虚表都是间接寻址第一个虚表相应位置来得到的该虚函数地址)。即使是菱形继承，子类中的虚表也只关心父类中的虚函数与自身虚函数的关系，而并不关心父类的父类。</p>
<p>除此之外，虚表中虚函数地址的顺序，是按照每个虚函数第一次定义和声明的先后顺序。如果子类中含有新定义的虚函数，那么该虚函数的地址只会存在于第一个虚表中的末尾。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><h4 id="虚继承的布局"><a href="#虚继承的布局" class="headerlink" title="虚继承的布局"></a>虚继承的布局</h4><p>有了前面对一般继承的分析，实际上虚继承也很容易了。不过最需要注意的，还是虚继承与一般继承相比，最大的不同点。我们知道，虚继承最常用的场景，就是在菱形继承下防止子类访问父类成员出现二义性的情况，比如按照2.4所用例子，现在我要在C的实例中访问D_1成员，此时就会出现二义性。如下所示：</p>
<p><img data-src="/mybook.github.io/images/184131916226546.png"></p>
<p>其实从2.4中C的内存布局就可以知道原因：C的内存布局中由于A和B都继承D，因此存在两个D_1，此时C的实例去访问D_1，到底访问哪一个呢？这样就出现了二义性。虚继承就可以解决这个问题。</p>
<p>那么是如何解决的呢？我们先从虚继承下子类的内存布局说起。</p>
<p>用前面2.1单继承的例子，将B继承A改为虚继承，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> A_1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> A_2;</span><br><span class="line">	<span class="type">int</span> A_3;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun3</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::A_2 = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> B_1;</span><br><span class="line">	<span class="type">int</span> B_2;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//重写了A中定义的一个虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">//定义了一个新的虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>B的内存布局如下所示：<br><img data-src="/mybook.github.io/images/429231916253501.png"><img data-src="/mybook.github.io/images/484831916235714.png"></p>
<p>可以看到，和一般继承不同的是，虚继承并不是将父类的布局放在子类布局的开头了，而是将其放在了子类数据成员的后面。在一般继承中，只有一个虚表指针放在布局最前面，而虚继承下出现了两个虚表指针vfptr，分别位于子类布局最前面以及子类中父类布局的最前面。这里还涉及到一个vbptr，现在先不管它。</p>
<p>因此虚继承中子类和父类的布局关系与一般继承中的区别如下所示：(先无视vbptr)<br><img data-src="/mybook.github.io/images/55402016225012.png"><br>再来看各自虚函数表的内容。类A中定义了3个虚函数Vfun1、Vfun2和Vfun3，类B中重写了Vfun1并且定义了一个新的虚函数Vfun4。而在类B所对应的虚函数表中，只有一个&amp;B::Vfun4，在类A对应的虚表中，含有被类B重写的&amp;B::Vfun1，以及类A定义的&amp;A::Vfun2和&amp;A::Vfun3。这里尤其需要注意的是，B重写的虚函数Vfun1的地址是放在父类A对应的虚表中的。</p>
<p>也就是说，在虚继承的情况下，每一个虚函数表中只会包含在对应类下第一次定义的虚函数的地址，即使该虚函数在子类中被重写，它的地址仍然是放在第一次定义该虚函数的父类中，并且被重写后的虚函数地址所覆盖。如这里的Vfun1，在类A中被第一次定义，在类B中被重写，因此&amp;A::Vfun1被覆盖为&amp;B::Vfun1，并且存在于类A布局中的虚表指针所对应的虚函数表中，而不是类B对应的虚函数表中。而相应的，在子类对应的虚函数表中，只包含在子类中第一次定义的虚函数的地址，如果子类中没有定义新的虚函数，那么子类中的虚表就为空，自然也就不存在虚表指针了，如把上面B类下定义的Vfun4删去，得到的B内存布局如下所示：</p>
<p><img data-src="/mybook.github.io/images/118462416221263.png"></p>
<p>此时由于子类中没有新定义的虚函数，因此子类所属的内存布局中没有虚表指针。</p>
<p>实际上，虚继承的类内存布局与一般继承的类内存布局还是大体类似的，每一个父类在子类中依然都各自对应一个虚函数表，不同的是，虚继承相当于在子类的内存布局中把虚基类的布局独立了出去，在一般继承中，子类新定义的虚函数是放在第一个声明继承的父类所对应的虚函数表的末尾，而在虚继承中，则是单独用一个属于子类的虚函数表去存放所有子类新定义的虚函数的地址。</p>
<p>现在再来回头看，这里还多了一个“虚基类表指针”vbptr，它指向一个虚基类表，并且可以看到虚基类表vbtable中有两个数据，一个是-4，一个是12，-4描述的是虚基类表指针vbptr自身相对于整个类首地址的偏移地址，12描述的是虚基类A的首地址相对于vbptr的偏移地址。</p>
<p>而这两个数据刚好就是两个虚表指针vfptr相对于虚基类表指针vbptr的偏移，也可以说，虚基类表中存放的数据是子类中子类的首地址和各个虚基类的首地址相对于虚基类表指针的地址偏移量。下面举个例子来看一看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun3</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> B,<span class="keyword">virtual</span> <span class="keyword">public</span> A,<span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> g;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里先不去管虚函数了，只关注虚基类在子类中的布局，D的内存布局如下：</p>
<p><img data-src="/mybook.github.io/images/594032416221402.png"></p>
<p>可以看到， 子类D先后虚继承类B和类A，再一般继承类C，在子类D的内存布局中，由于B和A属于虚继承，因此存在虚基类表指针，D中虚基类表指针地址偏移量为12，虚基类B和虚基类A各自布局下的虚函数表指针偏移量分别为24和36，由于D是一般继承继承类C，因此类C布局下的虚函数表指针放在最开头，偏移量为0。</p>
<p>再来看虚基类表vftable中，有三个元素，第一个元素为-12，刚好是C布局下的虚函数表指针(图中红色指向的vfptr)相对于虚基类表指针vbptr的偏移量(0-12 &#x3D; -12)；第二个元素为12，刚好也是B布局下的虚函数表指针(图中黄色指向的vfptr)相对于虚基类表指针vbptr的偏移量(24-12 &#x3D; 12)；第三个元素为24，刚好也是A布局下的虚函数表指针(图中蓝色指向的vfptr)相对于虚基类表指针vbptr的偏移量(36-12 &#x3D; 24)；</p>
<p>由此可以看出，不管是否为虚继承还是一般继承，如果发生多层继承，子类继承自多少个父类，子类内存布局中就会存在多少个虚表指针，每个虚表指针对应一个虚表；如果多层继承中某一个继承为虚继承，那么在子类的内存布局就还会存在一个虚基类表指针，对应一个虚基类表，在虚基类表中，第一项放的是整个类首地址相对于虚基类表指针的偏移地址，从第二项开始存放的是所有虚基类首地址相对于虚基类表指针的偏移地址，虚基类表中不会存放非虚基类的偏移地址。而虚基类指针的位置，则是放在属于子类的那一段布局的最前面（比如说这里由于一般继承C，因为会先放C的布局，C的布局之后，才是属于子类D的布局，当然如果没有一般继承全部为虚继承，那么虚基类指针就直接放在第一个虚表指针的后面）。</p>
<h4 id="虚继承的多层继承"><a href="#虚继承的多层继承" class="headerlink" title="虚继承的多层继承"></a>虚继承的多层继承</h4><p>通过分析虚继承的单继承以及虚继承的多重继承知道了虚继承的内存布局，现在再来看看虚继承的多层继承。</p>
<p>现有如下定义：类B虚继承类A，类C继承类B，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	virtual void Vfun1() &#123;&#125;;</span><br><span class="line">	virtual void Vfun2() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">class B:virtual public A</span><br><span class="line">&#123;</span><br><span class="line">	int c;</span><br><span class="line">	int d;</span><br><span class="line">	virtual void Vfun1() &#123;&#125;;</span><br><span class="line">	virtual void Vfun3() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">class C:public B</span><br><span class="line">&#123;</span><br><span class="line">	int e;</span><br><span class="line">	int f;</span><br><span class="line">	virtual void Vfun1() &#123;&#125;;    //重写B中重写的Vfun1</span><br><span class="line">	virtual void Vfun3() &#123;&#125;;    //重写B中定义的Vfun3</span><br><span class="line">	virtual void Vfun2() &#123;&#125;;    //重写A中定义的但是B中未重写的Vfun2</span><br><span class="line">	virtual void Vfun4() &#123;&#125;;    //定义一个新的虚函数Vfun4</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看类C的布局：<br><img data-src="/mybook.github.io/images/254280816232588.png"><img data-src="/mybook.github.io/images/123480816236834.png"></p>
<p>从该布局中可以看到，类A一旦被类B虚继承，那么即使类B被类C一般继承，在类C中类A的布局也是独立的，类A的布局中也拥有自己的虚表指针对应一个虚函数表。与前面的分析相同，在类A的虚函数表中，即使类C中重写了Vfun1，重写后的Vfun1函数地址依然存在与类A对应的虚函数表中。而由于C是一般继承B，因此C中新定义的虚函数Vfun4的地址则放在了类B所对应的虚函数表中。</p>
<p>那么如果这里类C也是虚继承类B呢？来看看结果：<br><img data-src="/mybook.github.io/images/537002516233492.png"><img data-src="/mybook.github.io/images/4332616238531.png"></p>
<p>可以看到，在类C的内存布局中，类A和类B都成虚基类，并且各自都有一个虚基类表指针，其中类B对应的虚基类表描述的是类B自己的的虚函数表指针和类A的虚函数表指针偏移地址（B也是虚继承自A），而类C对应的虚基类表描述的则是类C自己的虚函数表指针和类B的虚函数表指针偏移地址（C虚继承自B）。因此可以知道，每发生一次虚继承，那么虚继承的子类中就会存在一个虚基类表指针，所对应的虚基类表中存放的则是该子类和其所继承的虚基类的虚函数表指针的偏移量。</p>
<p>那么如果两个类同样虚继承自同一个父类呢？在子类中会如何存放这一个父类呢？这就来分析一下虚继承下的菱形继承：</p>
<h4 id="虚继承的菱形继承"><a href="#虚继承的菱形继承" class="headerlink" title="虚继承的菱形继承"></a>虚继承的菱形继承</h4><p>在最开始就说了，虚继承最常用于解决菱形继承下的“二义性”，那么现在定义如下：B虚继承自A，C也虚继承自A，D同时继承于B和C。定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun2</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="type">int</span> d;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun3</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e;</span><br><span class="line">	<span class="type">int</span> f;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun4</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:<span class="keyword">public</span> B,<span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> g;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun1</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Vfun5</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 再来看类D的内存布局：<br><img data-src="/mybook.github.io/images/213150716247610.png"><img data-src="/mybook.github.io/images/291720716240279.png"></p>
<p> 可以看到，虽然D的父类B和C都虚继承自类A，但是在类B中，只存在一个类A的布局，这样，当类D的对象访问成员a时，由于在D的内存布局中只存在一个a，这样也就不会出现二义性了。</p>
<p> 再来看虚函数表，由于这里继承了两个父类，并且还有一个虚基类，因此在类D中会有3个虚函数表，分别对应于类B，类C和类A，由于类B虚继承自类A，因此类B的虚函数表中只含有类B中新定义的虚函数Vfun3的地址，又因为类B是第一个声明继承的，因此类B的虚函数表中还有类D新定义的虚函数Vfun5的地址；同样的，对于类C来说，由于类C虚继承自类A，因此类C对应的虚函数表中只包含新定义的虚函数Vfun4的地址；再看类A，由于类A是虚基类，因此它对应的虚函数表中就包含所有在类A中定义的虚函数的地址，也就是虚函数Vfun1和Vfun2的地址。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>对于单继承来说，<br>如果是一般继承，那么子类内存布局的最前面会先放父类的内存布局，然后才是子类自身的数据成员。并且在该父类的内存布局的最前面会有一个虚函数表指针，其所对应的虚函数表中，会先继承父类自身虚函数表的所有内容，如果子类对父类的虚函数进行了重写，那么就会对相应的虚函数地址进行覆盖，如果子类有新定义的虚函数，那么还会将新定义的虚函数地址追加在虚函数表的后面；</p>
<p>而如果是虚继承，那么子类内存布局中则会把父类的内存布局单独放在最后，在该父类的内存布局中，最前面会有一个虚函数表指针，其所对应的虚函数表会继承父类的虚函数表所有内容，如果子类对父类中的虚函数进行了重写，那么也会将继承下来的虚函数表中的对应函数进行覆盖。如果子类中新定义了虚函数，那么在子类布局的最前面，就会有一个虚函数表指针，其对应一个新的虚函数表，表中存放的是所有子类中新定义的虚函数地址，如果子类中没有定义虚函数，那么就不存在子类的虚函数表指针了。然后会放一个虚基类表指针，该指针所指向的虚基类表，反映的是该子类以及父类(虚基类)的虚函数表指针相对于虚基类表指针的偏移位置，由此可以知道，通过虚基类表指针，可以找到虚继承中子类和父类各自的虚函数表。</p>
<p>对于多层继承来说，实际上也可以理解为子类和父类的单继承，如果是一般继承，那么实际上就是先看父类到父类的父类之间的单继承，然后再看子类到父类之间的单继承；但是一旦在多层继承中出现了虚继承，那么被虚继承的父类，都会在其子类、子类的子类、子类的子类的子类…的内存布局最后存在一份该父类的布局，并且该父类的布局中也会有一个虚函数表指针（如果该父类有继承或定义虚函数）和一个虚基类表指针，虚基类表的第一项是虚基类表指针相对于整个类的首地址的偏移量，从第二项开始是该类所有虚基类首地址相对于该虚基类表指针的偏移地址。</p>
<p>对于多重继承来说，不管是虚继承还是一般继承，每继承一个类就都会有一个虚函数表，该虚函数表会先继承对应父类的虚函数表的所有内容，如果子类中对虚函数有重写，那么就会覆盖相应的虚函数表中的虚函数地址。如果子类中有重新定义虚函数，那么该虚函数地址就会放在最先声明的一般继承的父类对应的虚函数表的最后，如果每一个继承都是虚继承，那么在子类的最前面就会有一个虚函数表指针，对应一个属于子类自己的虚函数表，其中是所有子类新定义的虚函数的地址。而每个父类在子类内存中的布局，则是虚继承的父类布局放在最后，一般继承的父类布局放在前面，均按照继承声明的先后顺序，并且在子类的开头还会存放一个虚基类指针（在子类的虚函数表指针后面），对应的虚基类表中存放所有虚继承的父类的虚函数表指针的相对于该虚基类指针的偏移地址。</p>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="STL组成"><a href="#STL组成" class="headerlink" title="STL组成"></a>STL组成</h2><p>容器、迭代器、仿函数、算法、分配器、配接器<br>他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数</p>
<table>
<thead>
<tr>
<th align="center">STL的组成</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">容器</td>
<td align="center">一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。</td>
</tr>
<tr>
<td align="center">算法</td>
<td align="center">STL 提供了非常多的算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件algorithm中，少部分位于头文件numeric中。</td>
</tr>
<tr>
<td align="center">迭代器</td>
<td align="center">在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td>
</tr>
<tr>
<td align="center">仿函数</td>
<td align="center">如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td>
</tr>
<tr>
<td align="center">适配器</td>
<td align="center">可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器</td>
</tr>
<tr>
<td align="center">内存分配器</td>
<td align="center">为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td>
</tr>
</tbody></table>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仿函数1,比较大小</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">comp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T in1, T in2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (in1&gt;in2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">comp&lt;<span class="type">int</span>&gt; m_comp_objext;</span><br><span class="line">cout &lt;&lt; <span class="built_in">m_comp_objext</span>(<span class="number">6</span>, <span class="number">3</span>) &lt;&lt; endl;     <span class="comment">//使用对象调用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">comp</span>&lt;<span class="type">int</span>&gt;()(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;       <span class="comment">//使用仿函数实现</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>C++中定义了3种容器适配器，它们让容器提供的接口变成了我们常用的的3种数据结构：栈stack，队列queue和优先队列priority_queue。<br>默认情况下，栈和队列都是基于deque实现的，而优先级队列则是基于vector实现的。</p>
<h3 id="内存分配器（allocaotr）"><a href="#内存分配器（allocaotr）" class="headerlink" title="内存分配器（allocaotr）"></a>内存分配器（allocaotr）</h3><ul>
<li>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</li>
<li>delete运算分两个阶段：(1)调用对象析构函数；(2)调用::operator delete释放内存</li>
<li>为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</li>
</ul>
<p><strong>上述工作分别由stl_construct.h, stl_alloc.h, stl_uninitialized.h</strong></p>
<h4 id="对象的构造和析构工具（stl-construct-h）"><a href="#对象的构造和析构工具（stl-construct-h）" class="headerlink" title="对象的构造和析构工具（stl_construct.h）"></a>对象的构造和析构工具（stl_construct.h）</h4><p>提供了两种对象的构造方法，默认构造和赋值构造：<br>提供了两种析构方法：</p>
<ol>
<li>析构函数接受一个指针，将该指针所指的对象析构掉；</li>
<li>析构函数接受first和last两个迭代器，将这两个迭代器范围内的对象析构掉。</li>
</ol>
<h4 id="内存空间管理工具（stl-alloc-h）"><a href="#内存空间管理工具（stl-alloc-h）" class="headerlink" title="内存空间管理工具（stl_alloc.h）"></a>内存空间管理工具（stl_alloc.h）</h4><ol>
<li>__malloc_alloc_template内存分配器（malloc）</li>
<li>__default_alloc_template分配器（内存池）</li>
</ol>
<ul>
<li>allocator是一个由两级分配器构成的内存管理器</li>
<li>当申请的内存大小大于128byte时，就启动第一级分配器通过malloc直接向系统的堆空间分配，</li>
<li>如果申请的内存大小小于128byte时，就启动第二级分配器，从一个预先分配好的内存池中取一块内存交付给用户，这个内存池由16个不同大小（8的倍数，8~128byte）的空闲列表组成，allocator会根据申请内存的大小（将这个大小round up成8的倍数）从对应的空闲块列表取表头块给用户。</li>
</ul>
<p>这种做法有两个优点：</p>
<ol>
<li>小对象的快速分配。小对象是从内存池分配的，这个内存池是系统调用一次malloc分配一块足够大的区域给程序备用，当内存池耗尽时再向系统申请一块新的区域，整个过程类似于批发和零售，起先是由allocator向总经商批发一定量的货物，然后零售给用户，与每次都总经商要一个货物再零售给用户的过程相比，显然是快捷了。当然，这里的一个问题时，内存池会带来一些内存的浪费，比如当只需分配一个小对象时，为了这个小对象可能要申请一大块的内存池，但这个浪费还是值得的，况且这种情况在实际应用中也并不多见。</li>
<li>避免了内存碎片的生成。程序中的小对象的分配极易造成内存碎片，给操作系统的内存管理带来了很大压力，系统中碎片的增多不但会影响内存分配的速度，而且会极大地降低内存的利用率。以内存池组织小对象的内存，从系统的角度看，只是一大块内存池，看不到小对象内存的分配和释放。</li>
</ol>
<h4 id="基本内存处理工具（stl-uninitialized-h）"><a href="#基本内存处理工具（stl-uninitialized-h）" class="headerlink" title="基本内存处理工具（stl_uninitialized.h）"></a>基本内存处理工具（stl_uninitialized.h）</h4><p>STL提供了三类内存处理工具：uninitialized_copy(), uninitialized_fill()和uninitialized_fill_n()</p>
<ol>
<li>uninitialized_copy()会将迭代器_first和_last之间的对象拷贝到迭代器_result开始的地方</li>
<li>uninitialized_fill()会将迭代器_first和_last范围内的所有元素初始化为x</li>
<li>uninitialized_fill_n()会将迭代器_first开始处的n个元素初始化为x</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ol>
<li>算术转换(Arithmetic conversion) : 在混合类型的算术表达式中, 最宽的数据类型成为目标转换类型。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">3</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14159</span>;</span><br><span class="line">ival + dval;<span class="comment">//ival被提升为double类型</span></span><br></pre></td></tr></table></figure></li>
<li>一种类型表达式赋值给另一种类型的对象：目标类型是被赋值对象的类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="number">0</span>; <span class="comment">// 0被转化为int *类型</span></span><br><span class="line">ival = dval; <span class="comment">// double-&gt;int</span></span><br></pre></td></tr></table></figure>
例外：void指针赋值给其他指定类型指针时，不存在标准转换，编译出错</li>
<li>将一个表达式作为实参传递给函数调用，此时形参和实参类型不一致：目标转换类型为形参的类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The square root of 2 is &quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//2被提升为double类型：2.0</span></span><br></pre></td></tr></table></figure>
4。 从一个函数返回一个表达式，表达式类型与返回类型不一致：目标转换类型为函数的返回类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">difference</span><span class="params">(<span class="type">int</span> ival1, <span class="type">int</span> ival2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ival1 - ival2;</span><br><span class="line">    <span class="comment">//返回值被提升为double类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四种显示类型转换"><a href="#四种显示类型转换" class="headerlink" title="四种显示类型转换"></a>四种显示类型转换</h3><ol>
<li>向上转换：子类向基类的转换</li>
<li>向下转换：基类向子类的转换</li>
</ol>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>进行无条件转换，静态类型转换：</p>
<ol>
<li>基类和子类之间的转换：<strong>其中子类指针转换为父类指针是安全的</strong>，但父类指针转换为子类指针是不安全的（基类和子类之间的动态类型转换建议用dynamic_cast）。</li>
<li>基本数据类型转换，enum，struct，int，char，float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。</li>
<li>把任何类型的表达式转换成void类型。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="number">7.987</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast:"></a>const_cast:</h4><p>去掉类型的const或volatile属性</p>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>volatile关键字是一种限定符用来声明一个对象在程序中可以被语句外的东西修改,比如操作系统、硬件或并发执行线程。<br>遇到该关键字，编译器不再对该变量的代码进行优化，不再从寄存器中读取变量的值，而是直接从它所在的内存中读取值，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。<br>一般说来，volatile用在如下的几个地方：</p>
<ol>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li><strong>多任务环境下各任务间共享的标志应该加volatile</strong>；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</li>
</ol>
<p>当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> T a;</span><br><span class="line">    <span class="comment">//a.i = 10;  //直接修改const类型，编译错误</span></span><br><span class="line">    T &amp;b = <span class="built_in">const_cast</span>&lt;T&amp;&gt;(a);</span><br><span class="line">    b.i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p>有条件转换，动态类型转换，运行时检查类型安全（转换失败返回NULL）：</p>
<ol>
<li>安全的基类和子类之间的转换。</li>
<li>必须有虚函数。原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。</li>
<li>相同基类不同子类之间的交叉转换，但结果返回NULL。</li>
</ol>
<ul>
<li>对指针进行dynamic_cast，失败返回null，成功返回正常cast后的对象指针；</li>
<li>对引用进行dynamic_cast，失败抛出一个异常bad_cast，成功返回正常cast后的对象引用。</li>
</ul>
<ol>
<li>对于“向上转换”（即派生类指针或引用转换为其基类类型）都是安全的。</li>
<li>对于“向下转型”有两种情况：<br>第一，基类指针所指对象是派生类类型，这种转换是安全的；<br>第二，基类指针所指对象为基类类型，dynamic_cast在运行时做检查，转换失败，返回结果为0。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       cout&lt;&lt;<span class="string">&quot;helloA&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;helloB&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a1=<span class="keyword">new</span> B;<span class="comment">//a1是A类型的指针指向一个B类型的对象</span></span><br><span class="line">    A* a2=<span class="keyword">new</span> A;<span class="comment">//a2是A类型的指针指向一个A类型的对象</span></span><br><span class="line">    B* b;</span><br><span class="line">    C* c;</span><br><span class="line">    b=<span class="built_in">dynamic_cast</span>&lt;B*&gt;(a1);<span class="comment">//向下转换成功，a1（A类型的指针）之前指向的就是B类型的对象，所以可以转换成B类型的指针。</span></span><br><span class="line">    b=<span class="built_in">dynamic_cast</span>&lt;B*&gt;(a2);<span class="comment">//结果为null，向下转换失败</span></span><br><span class="line">    c=<span class="built_in">dynamic_cast</span>&lt;C*&gt;(a);<span class="comment">//结果为null，向下转换失败</span></span><br><span class="line">    <span class="built_in">delete</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>为什么要使用智能指针：<br>申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。<br>智能指针是一个类对象，这样在被调函数执行完，程序过期时，对象将会被删除（对象的名字保存在栈变量中），这样不仅对象会被删除，它指向的内存也会被删除的。</p>
<h3 id="auto-ptr（c98-的方案，c11已经抛弃）采用所有权模式"><a href="#auto-ptr（c98-的方案，c11已经抛弃）采用所有权模式" class="headerlink" title="auto _ptr（c98 的方案，c11已经抛弃）采用所有权模式"></a>auto _ptr（c98 的方案，c11已经抛弃）采用所有权模式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt; string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;I reigned lonely as a cloud.”));</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">auto_ptr&lt;string&gt; p2;p2 = p1; //auto_ptr 不会报错. </span></span></span></span><br></pre></td></tr></table></figure>
<p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错。所以 auto_ptr的缺点是：存在潜在的内存崩溃问题！</p>
<h3 id="unique-ptr（替换-auto-ptr"><a href="#unique-ptr（替换-auto-ptr" class="headerlink" title="unique_ptr（替换 auto_ptr)"></a>unique_ptr（替换 auto_ptr)</h3><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以 new 创建对象后因为发生异常而忘记调用 delete”)特别有用。采用所有权模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;auto&quot;</span>))</span></span>; <span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4； <span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错！！</span></span><br></pre></td></tr></table></figure>
<p>编译器认为 p4&#x3D;p3 非法，避免了 p3 不再指向有效数据的问题。因此，unique_ptr 比 auto_ptr更安全。<br>另外 unique_ptr 还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1; <span class="comment">// #1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));  <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure>
<p>其中#1 留下悬挂的 unique_ptr(pu1)，这可能导致危害。而#2 不会留下悬挂的 unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的 auto_ptr 。<br>注：如果确实想执行类似与#1 的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数 std::move()，让你能够将一个 unique_ptr 赋给另一个。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; ps1, ps2;</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ps2 = <span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;alexia&quot;</span>);</span><br><span class="line">cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="shared-ptr实现共享式拥有概念"><a href="#shared-ptr实现共享式拥有概念" class="headerlink" title="shared_ptr实现共享式拥有概念"></a>shared_ptr实现共享式拥有概念</h3><p>多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count()来查看资源的所有者个数。除了可以通过 new 来构造，还可以通过传入 auto _ptr, unique_ptr,weak_ptr 来构造。当我们调用 release()时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被释放。<br>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。<br>成员函数：</p>
<ul>
<li>use_count 返回引用计数的个数</li>
<li>unique 返回是否是独占所有权( use_count 为 1)</li>
<li>swap 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li>reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</li>
<li>get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的</int></li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared _ptr. weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题, 如果说两个 shared _ptr 相互引用,那么这两个指针的引用计数永远不可能下降为 0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B delete\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 fun 函数中 pa ，pb 之间互相引用，两个资源的引用计数为 2，当要跳出函数时，智能指针 pa，pb 析构时两个资源引用计数会减一，但是两者引用计数还是为 1，导致跳出函数时资源没有被释放（A B 的析构函数没有被调用）<br>把其中一个改为 weak_ptr，我们把类 A 里面的 shared_ptr pb; 改为 weak_ptr pb; 运行结果如下，这样的话，资源 B 的引用开始就只有 1，当 pb 析构时，B 的计数变为 0，B 得到释放，B 释放的同时也会使 A 的计数减 1，同时 pa 析构时使 A 的计数减 1，那么 A 的计数为 0，A 得到释放。<br>注意的是我们不能通过 weak_ptr 直接访问对象的方法，比如 B 对象中有一个方法 print(), 我们不能这样访问，pa-&gt;pb-&gt;print(); 英文 pb是一个 weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p &#x3D; pa-&gt;pb.lock(); p-&gt;print();</p>
<h2 id="emplace-back-和push-back-的区别"><a href="#emplace-back-和push-back-的区别" class="headerlink" title="emplace_back()和push_back()的区别"></a>emplace_back()和push_back()的区别</h2><p>push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）<br>emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p>
<h2 id="string是如何存储数据的，具体过程？为什么会扩容2倍或1-5倍？"><a href="#string是如何存储数据的，具体过程？为什么会扩容2倍或1-5倍？" class="headerlink" title="string是如何存储数据的，具体过程？为什么会扩容2倍或1.5倍？"></a>string是如何存储数据的，具体过程？为什么会扩容2倍或1.5倍？</h2><ol>
<li>以前的编译器是用写时复制（COW）技术，每当字符串发生复制构造或赋值时进行浅拷贝，只复制指针并增加一个引用计数，只有对其中一个字符串进行修改时才会执行真正的复制。既然用到了引用计数，那么就要考虑在多线程环境下的线程安全问题，而且string会把operator[]和at()都认定为修改“语义”，即使我们只是访问字符串也会触发COW，这就导致string的COW实现存在诸多弊端；</li>
<li>现在编译器大多采用SSO短字符串优化，<strong>当字符串长度小于15字节时直接存放在栈中，大于15字节时，栈中存放指针，指针指向堆中的完整字符串</strong>。这样的好处是，当字符串较短时，直接将其数据存在栈中，而不用去堆中动态申请空间，避免了申请堆空间的开销；</li>
<li>在g++环境下，string的扩容机制跟vector一样是两倍扩容，最初分配的capacity是15字节；</li>
<li>如果扩容倍率太低，继续插入字符的话会出现频繁扩容的现象，效率降低；如果倍率太高，又会造成空间浪费，所以我想2倍或1.5倍是一个折中的考虑，兼顾了效率与空间利用率；</li>
</ol>
<h2 id="unorder-map底层分布"><a href="#unorder-map底层分布" class="headerlink" title="unorder_map底层分布"></a>unorder_map底层分布</h2><ul>
<li>unordered_map 内部采用 hashtable 的数据结构存储，每个特定的 key 会通过特定的哈希运算映射到一个特定的位置。</li>
<li>一般来说，hashtable 是可能存在冲突的，即不同的key值经过哈希运算之后得到相同的结果。解决方法是：在每个位置放一个桶，用于存放映射到此位置的元素，  当桶内数据量在8以内使用链表来实现桶，当数据量大于8 则自动转换为红黑树结构 也就是有序map的实现结构。<br><img data-src="/mybook.github.io/images/1709815129102.png"></li>
</ul>
<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h2 id="1-nullptr"><a href="#1-nullptr" class="headerlink" title="1. nullptr"></a>1. nullptr</h2><p>在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 (void* 0)，有些则会直接将其定义为 0。<br>C++ 不允许直接将 void * 隐式转换到其他类型，但如果 NULL 被定义为 (void* 0)，那么当编译char *ch &#x3D; NULL;时，NULL 只好被定义为 0。<br>而这依然会产生问题，将导致了 C++ 中重载特性会发生混乱，考虑：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于这两个函数来说，如果 NULL 又被定义为了 0 那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直观。<br>为了解决这个问题，C++11 引入了 nullptr 关键字，专门用来区分空指针、0。<br>nullptr 的类型为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<h2 id="2-类型推导"><a href="#2-类型推导" class="headerlink" title="2. 类型推导"></a>2. 类型推导</h2><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。<br>注意：auto 不能用于函数传参，因此下面的做法是无法通过编译的（考虑重载的问题，我们应该使用模板）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>此外，auto 还不能用于推导数组类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">auto</span> i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="keyword">auto</span> auto_arr = arr;</span><br><span class="line"> <span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = arr;<span class="comment">//该行错误</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 sizeof 很相似：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure>
<p>拖尾返回类型、auto 与 decltype 配合<br>C++11 还引入了一个叫做拖尾返回类型（trailing return type），利用 auto 关键字将返回类型后置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-区间迭代"><a href="#3-区间迭代" class="headerlink" title="3. 区间迭代"></a>3. 区间迭代</h2><p>基于范围的 for 循环<br>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &amp; 启用了引用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : arr) &#123;    </span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-初始化列表"><a href="#4-初始化列表" class="headerlink" title="4. 初始化列表"></a>4. 初始化列表</h2><p>C++11 提供了统一的语法来初始化任意的对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> _a, <span class="type">float</span> _b): <span class="built_in">a</span>(_a), <span class="built_in">b</span>(_b) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a &#123;<span class="number">1</span>, <span class="number">1.1</span>&#125;;    <span class="comment">// 统一的初始化语法</span></span><br><span class="line">B b &#123;<span class="number">2</span>, <span class="number">2.2</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-lambda表达式"><a href="#5-lambda表达式" class="headerlink" title="5. lambda表达式"></a>5. lambda表达式</h2><p><img data-src="/mybook.github.io/images/5796141696695.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[]:表示不捕获任何外部变量</span><br><span class="line">[=]:以传值的方式捕获外部的所有变量</span><br><span class="line">[&amp;]:以传引用的方式捕获外部的所有变量</span><br><span class="line">[<span class="keyword">this</span>]:捕获外部的<span class="keyword">this</span>指针</span><br><span class="line">[=，&amp;a]：以传值的方式捕获外部的所有变量，但是a变量以传引用的方式捕获</span><br><span class="line">[a，b]：以传值的方式捕获外部变量a和b</span><br><span class="line">[a,&amp;b]：a以传值方式捕获，b以传引用的方式捕获</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func1 = []()&#123;cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="built_in">func1</span>();</span><br></pre></td></tr></table></figure>
<p>其对应的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">class</span> TestLambda01</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestLambda01</span>() &#123;&#125;</span><br><span class="line">	<span class="type">void</span> <span class="built_in">operator</span>()()<span class="type">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-右值引用"><a href="#6-右值引用" class="headerlink" title="6. 右值引用"></a>6. 右值引用</h2><p>左值持久，右值短暂，右值只能绑定到临时对象，所引用的对象将要销毁或该对象没有其他用户，使用右值引用的代码可以自由的接管所引用对象的内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">MyString</span>(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">    :<span class="built_in">m_data</span>(str.m_data) &#123;</span><br><span class="line">    MCtor ++;</span><br><span class="line">    str.m_data = <span class="literal">nullptr</span>; <span class="comment">//不再指向之前的资源了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右值优先进入移动构造函数而不是拷贝构造函数。而移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源，”偷”也白偷了。</p>
<p>C++11提供了std::move()方法来将左值转换为右值，从而方便应用移动语义。我觉得它其实就是告诉编译器，虽然我是一个左值，但是不要对我用拷贝构造函数，而是用移动构造函数吧。。。</p>
<p>如果我们没有提供移动构造函数，只提供了拷贝构造函数，std::move()会失效但是不会发生错误，因为编译器找不到移动构造函数就去寻找拷贝构造函数，也这是拷贝构造函数的参数是const T&amp;常量左值引用的原因！</p>
<center><font size="32">------赞助耶耶，加快更新！------</font></center>


<p> <img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/mybook.github.io/2024/05/17/Redis/</url>
    <content><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><p>常见的有五种：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</p>
<p>随着 Redis 版本的更新，后面又支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>是redis中最基本的数据类型，一个key对应一个value。</p>
<ul>
<li>String类型是二进制安全的，底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</li>
<li>SDS 不仅可以保存文本数据，还可以保存二进制数据， SDS 的所有 API 都会以处理二进制的方式处理存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。</li>
<li>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<p><img data-src="/mybook.github.io/images/542052117263693.png"></p>
<ul>
<li>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成 long），并将字符串对象的编码设置为int</li>
<li>如果字符串对象保存的是一个字符串，并且这个字符申的长度小于等于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为embstr， embstr编码是专门用于保存短字符串的一种优化编码方式</li>
<li>如果字符串对象保存的是一个字符串，并且这个字符串的长度大于 32 字节（redis 2.+版本），那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串，并将对象的编码设置为raw</li>
</ul>
<p><strong>embstr优点：</strong><br>embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS，raw编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject和SDS<br>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的利用 CPU 缓存提升性能。</p>
<p><strong>embstr缺点：</strong><br>embstr编码的字符串对象实际上是只读的，redis没有为embstr编码的字符串对象编写任何相应的修改程序。当我们对embstr编码的字符串对象执行任何修改命令（例如append）时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。<br>如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line"><span class="string">&quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用场景：</strong></p>
<ul>
<li>缓存对象</li>
<li>常规计数</li>
<li>分布式锁</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>双向链表或压缩列表</p>
<ul>
<li>如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用压缩列表作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用双向链表作为 List 类型的底层数据结构；</li>
<li>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。</li>
</ul>
<p>使用列表的技巧:</p>
<p><img data-src="/mybook.github.io/images/87172014255125.png"></p>
<ul>
<li>lpush+lpop&#x3D;Stack(栈)</li>
<li>lpush+rpop&#x3D;Queue（队列）</li>
<li>lpush+ltrim&#x3D;Capped Collection（有限集合）</li>
<li>lpush+brpop&#x3D;Message Queue（消息队列）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll <span class="built_in">ls</span> mem</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;mem&quot;</span></span><br><span class="line">2) <span class="string">&quot;ls&quot;</span></span><br><span class="line">3) <span class="string">&quot;ll&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>应用场景：</strong><br>消息队列</p>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>是一个Mapmap，指值本身又是一种键值对结构</p>
<p><img data-src="/mybook.github.io/images/313723511267020.png"></p>
<p>内部实现<br>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用压缩列表作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用哈希表作为 Hash 类型的 底层数据结构。</li>
<li>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li>
</ul>
<p>使用：所有hash的命令都是  h   开头的     hget  、hset 、  hdel 等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user name1 hao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user email1 hao@163.com</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall user</span><br><span class="line">1) <span class="string">&quot;name1&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">3) <span class="string">&quot;email1&quot;</span></span><br><span class="line">4) <span class="string">&quot;hao@163.com&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li>缓存对象</li>
<li>购物车</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 类型的底层数据结构是由<strong>哈希表</strong>或<strong>整数集合</strong>实现的：</p>
<p>使用：命令都是以s开头的  sset 、srem、scard、smembers、sismember</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao1&quot;</span></span><br><span class="line">3) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>


<p>如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；<br>如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。</p>
<p><img data-src="/mybook.github.io/images/208841010257242.png"></p>
<p>Set 类型和 List 类型的区别如下：</p>
<p>List 可以存储重复元素，Set 只能存储非重复元素；<br>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。<br>集合中的元素是无序的，不能通过索引下标获取元素</p>
<p><strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong></p>
<p>应用场景：<br>点赞<br>共同关注<br>抽奖活动</p>
<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p>对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。<br>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。</p>
<p><img data-src="/mybook.github.io/images/432203811259689.png"></p>
<p>Zset 类型的底层数据结构是由压缩列表或跳表实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用压缩列表作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用跳表作为 Zset 类型的底层数据结构；</li>
<li>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li>
</ul>
<p>使用： 有序集合的命令都是 以  z  开头    zadd 、 zrange、 zscore</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myscoreset 100 hao 90 xiaohao</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1</span><br><span class="line">1) <span class="string">&quot;xiaohao&quot;</span></span><br><span class="line">2) <span class="string">&quot;hao&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line"><span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别<strong>适合一些数据量大且使用二值统计的场景。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置值，其中value只能是 0 和 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取值</span></span><br><span class="line">GETBIT key offset</span><br></pre></td></tr></table></figure>


<p>内部实现:<br>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。<br>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组</p>
<p><strong>应用场景</strong><br>签到统计<br>判断用户登陆态<br>连续签到用户总数</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog 提供不精确的去重计数, 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。<br>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。<br>每个 HyperLogLog 键<strong>只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间:<br><a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog数学原理</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong><br>百万级网页 UV 计数</p>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><p><strong>内部实现</strong><br>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p>
<p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p>
<p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span></span><br><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span></span><br><span class="line">GEOPOS key member [member ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回两个给定位置之间的距离。</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong><br>滴滴叫车<br>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p>
<p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p>
<p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure>
<p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p>
<p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p>
<p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p>
<p>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；<br>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</p>
<p><strong>常见命令</strong><br>Stream 消息队列操作命令：</p>
<p>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；<br>XLEN ：查询消息长度；<br>XREAD：用于读取消息，可以按 ID 读取数据；<br>XDEL ： 根据消息 ID 删除消息；<br>DEL ：删除整个 Stream；<br>XRANGE ：读取区间消息<br>XREADGROUP：按消费组形式读取消息；<br>XPENDING 和 XACK：<br>XPENDING 命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；<br>XACK 命令用于向消息队列确认消息处理已完成；</p>
<p><strong>应用场景</strong></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">* 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">往名称为 mymq 的消息队列中插入一条消息，消息的键是 name，值是 xiaolin</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XADD mymq * name xiaolin</span></span><br><span class="line">&quot;1654254953808-0&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 ID 号为 1654254953807-0 的消息开始，读取后续的所有消息（示例中一共 1 条）。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREAD STREAMS mymq 1654254953807-0</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br><span class="line">            </span><br></pre></td></tr></table></figure>
<p>如果想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项，实现类似于 BRPOP 的阻塞读取操作。</p>
<p><img data-src="/mybook.github.io/images/332081109240466.png"></p>
<p>Stream 可以以使用 XGROUP 创建消费组，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</p>
<p>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XGROUP CREATE mymq group1 0-0</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XGROUP CREATE mymq group2 0-0</span></span><br><span class="line">OK</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure>
<p>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息。</p>
<p>比如说，我们执行完刚才的 XREADGROUP 命令后，再执行一次同样的命令，此时读到的就是空值了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>但是，不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）。<br>比如说，刚才 group1 消费组里的 consumer1 消费者消费了一条 id 为 1654254953808-0 的消息，现在用 group2 消费组里的 consumer1 消费者消费消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XREADGROUP GROUP group2 consumer1 STREAMS mymq &gt;</span></span><br><span class="line">1) 1) &quot;mymq&quot;</span><br><span class="line">   2) 1) 1) &quot;1654254953808-0&quot;</span><br><span class="line">         2) 1) &quot;name&quot;</span><br><span class="line">            2) &quot;xiaolin&quot;</span><br></pre></td></tr></table></figure>
<p>因为我创建两组的消费组都是从第一条消息开始读取，所以可以看到第二组的消费者依然可以消费 id 为 1654254953808-0 的这一条消息。因此，不同的消费组的消费者可以消费同一条消息。</p>
<h3 id="基于-Stream-实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？"><a href="#基于-Stream-实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？" class="headerlink" title="基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？"></a>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</h3><p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。</p>
<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成，整个流程的执行如下图所示：</p>
<p><img data-src="/mybook.github.io/images/5962009258892.png"></p>
<p>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。</p>
<p>一旦消息 1654256265584-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XACK mymq group2 1654256265584-0</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">XPENDING mymq group2 - + 10 consumer2</span></span><br><span class="line">(empty array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>消息保序：XADD&#x2F;XREAD</li>
<li>阻塞读取：XREAD block</li>
<li>重复消息处理：Stream 在使用 XADD 命令，会自动生成全局唯一 ID；</li>
<li>消息可靠性：内部使用 PENDING List 自动保存消息，使用 XPENDING 命令查看消费组已经读取但是未被确认的消息，消费者使用 XACK 确认消息；</li>
<li>支持消费组形式消费数据</li>
</ul>
<h3 id="Redis-基于-Stream-消息队列与专业的消息队列有哪些差距？"><a href="#Redis-基于-Stream-消息队列与专业的消息队列有哪些差距？" class="headerlink" title="Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？"></a>Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？</h3><ul>
<li>消息不丢?</li>
</ul>
<p>生产者会不会丢消息，消费者不会丢消息,,Redis 消息中间件会丢消息, Redis 在以下 2 个场景下，都会导致数据丢失：</p>
<ol>
<li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li>
<li>主从复制也是异步的，主从切换时，也存在丢失数据的可能 。</li>
</ol>
<ul>
<li>消息可堆积?<br>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上</li>
</ul>
<p><strong>关键看业务场景：</strong><br><strong>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</strong><br><strong>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</strong></p>
<h3 id="Redis-发布-订阅机制为什么不可以作为消息队列？"><a href="#Redis-发布-订阅机制为什么不可以作为消息队列？" class="headerlink" title="Redis 发布&#x2F;订阅机制为什么不可以作为消息队列？"></a>Redis 发布&#x2F;订阅机制为什么不可以作为消息队列？</h3><ol>
<li>发布&#x2F;订阅机制没有基于任何数据类型实现，所以不具备「数据持久化」的能力，也就是发布&#x2F;订阅机制的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，发布&#x2F;订阅机制的数据也会全部丢失。</li>
<li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li>
<li>当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是<code>client-output-buffer-limit pubsub 32mb 8mb 60</code></li>
</ol>
<p>数据结构实现</p>
<p><img data-src="/mybook.github.io/images/161783909246759.png"></p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li>
<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， key 指向的是 String 对象，而 value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</li>
</ul>
<p><img data-src="/mybook.github.io/images/539934514259594.png"></p>
<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，并写入.rdb格式的二进制文件保存在磁盘，这样如果服务器崩溃内存内数据丢失，重新连接后redis会自动读取默认名称为dump.rdb（可以在redis.conf内修改为其他名称）的rdb备份文件，恢复其上次备份时redis存在的所有数据。</p>
<ul>
<li>save命令：会在主线程生成 RDB 文件，阻塞当前Redis，直到RDB持久化过程完成为止，若内存实例比较大会造成长时间阻塞，线上环境不建议用它</li>
<li>bgsave命令：redis进程执行fork操作创建子线程，由子线程完成持久化，阻塞时间很短（微秒级），是save的优化, 在执行redis-cli shutdown关闭redis服务时，如果没有开启AOF持久化，自动执行bgsave;</li>
</ul>
<p>Redis 的快照是全量快照，执行的频率不能太频繁，否则会影响 Redis 性能，</p>
<h3 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h3><p>写时复制技术</p>
<p>如果主线程（父进程）要修改共享数据里的某一块数据（比如键值对 A）时，就会发生写时复制，于是这块数据的物理内存就会被复制一份（键值对 A’），然后主线程在这个数据副本（键值对 A’）进行修改操作。与此同时，bgsave 子进程可以继续把原来的数据（键值对 A）写入到 RDB 文件。</p>
<p>注意：<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的</strong>，只能交由下一次的 bgsave 快照。</p>
<p>快照的频率不好把握：</p>
<ul>
<li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li>
<li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li>
</ul>
<h2 id="AOF日志持久化"><a href="#AOF日志持久化" class="headerlink" title="AOF日志持久化"></a>AOF日志持久化</h2><p><img data-src="/mybook.github.io/images/217274914256149.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3</span></span><br><span class="line">set</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4</span></span><br><span class="line">name</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7</span></span><br><span class="line">xiaolin</span><br></pre></td></tr></table></figure>
<p>「*3」表示当前命令有三个部分，每部分都是以「$+数字」开头，后面紧跟着具体的命令、键或值。然后，这里的「数字」表示这部分中的命令、键或值一共有多少字节。例如，「$3 set」表示这部分有 3 个字节，也就是「set」命令这个字符串的长度。</p>
<p>先执行写操作命令后，才记录到 AOF 日志<br>好处：</p>
<ol>
<li>避免额外的检查开销。</li>
<li>不会阻塞当前写操作命令的执行</li>
</ol>
<p>坏处：</p>
<ol>
<li>服务器发生宕机，这个数据就会有丢失的风险</li>
<li>可能会给「下一个」命令带来阻塞风险</li>
</ol>
<h3 id="AOF何时写回磁盘？"><a href="#AOF何时写回磁盘？" class="headerlink" title="AOF何时写回磁盘？"></a>AOF何时写回磁盘？</h3><p>此操作在主进程中，是同步的</p>
<p><img data-src="/mybook.github.io/images/144465514251903.png"></p>
<p><img data-src="/mybook.github.io/images/523995614269783.png"></p>
<p>在 redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<p>Always，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；<br>Everysec，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；<br>No，意味着不由 Redis 控制写回硬盘的时机，<strong>转交给操作系统控制写回的时机</strong>，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</p>
<p><img data-src="/mybook.github.io/images/281445814267387.png"></p>
<p>这三种策略控制的是fsync()系统调用的时机，详情参照《操作系统》</p>
<p><img data-src="/mybook.github.io/images/29525914264889.png"></p>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用最新的命令值记录到新的 AOF 文件，最终也只需要根据这个「键值对」当前的最新状态，然后用一条命令去记录键值对，如果 AOF 重写过程中失败了，放弃新的AOF文件</p>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>写时复制技术</p>
<p>重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的<br>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；<br>为何使用子进程？不是线程？（考虑写时复制和共享数据）</p>
<p>修改的数据量比较大的 key-value 的时候，这时写时复制的物理内存数据的过程就会比较耗时，有阻塞主进程的风险。<br>所以Redis 设置了一个 AOF 重写缓冲区，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」。</p>
<p><img data-src="/mybook.github.io/images/403101515246130.png"></p>
<p>在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ol>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ol>
<p>AOF重写完成后：<br>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；（两个缓冲区的作用是一样的）<br>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件</p>
<p><strong>在整个 AOF 后台重写过程中，除了发生写时复制会对主进程造成阻塞，还有信号处理函数执行时也会对主进程造成阻塞，在其他时候，AOF 后台重写都不会阻塞主进程。</strong></p>
<p>针对RDB不适合实时持久化，redis提供了AOF持久化方式来解决</p>
<p>AOF持久化采取的是日志式添加记录每次修改操作的方式，每次执行修改后，AOF持久化只需要将新执行的操作添加到appendonly.aof文件的末尾，对文件进行简单的append操作的IO消耗很小，这种文件是可读的，也就意味着可以被手动修改，拥有更强的灵活性。</p>
<p>比如Redis不小心执行了flushall指令，清空了所有数据，只要是aof没有被rewrite，只需要复制一份aof文件，去掉最后的flushall命令，再重启redis，redis会自动读取aof文件进行恢复（即从头到尾依次执行记录的操作）。</p>
<p>AOF持久化默认不开启，需要在redis.conf配置文件中将appendonly no改为appendonly yes开启。可以设置为每秒进行一次，或每次修改都进行持久化。</p>
<p>相同数据产生的AOF文件比RDB文件更大，而且开启AOF持久化对Redis主线程的性能影响也比RDB更大，但是可以更好保证数据完整性。</p>
<h2 id="双剑合璧"><a href="#双剑合璧" class="headerlink" title="双剑合璧"></a>双剑合璧</h2><p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p>混合持久化工作在 AOF 日志重写过程。</p>
<p>当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>简单来说，如下图：其它与AOF重写一致<br>AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。</p>
<p><img data-src="/mybook.github.io/images/138633315268570.png"></p>
<h2 id="大key对持久化的影响"><a href="#大key对持久化的影响" class="headerlink" title="大key对持久化的影响"></a>大key对持久化的影响</h2><p>大 Key 对 AOF 日志的影响：参照 fsync() 系统调用函数<br>大 Key 对 AOF 重写的影响：考虑频繁触发重写，写时复制的性能<br>大 Key 对 RDB 快照的影响：考虑写时复制的性能</p>
<p><strong>如果 Linux 开启了内存大页，会影响 Redis 的性能的。</strong><br>常规的内存页分配是按 4KB 的粒度来执行的。内存大页机制支持 2MB 大小的内存页分配</p>
<p>禁用方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo never &gt;  /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>

<h1 id="Redis的内存策略"><a href="#Redis的内存策略" class="headerlink" title="Redis的内存策略"></a>Redis的内存策略</h1><h2 id="如何判定-key-已过期了？"><a href="#如何判定-key-已过期了？" class="headerlink" title="如何判定 key 已过期了？"></a>如何判定 key 已过期了？</h2><p>每当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</p>
<p>过期字典存储在 redisDb 结构中，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisDb</span> &#123;</span><br><span class="line">    dict *dict;    <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span></span><br><span class="line">    dict *expires; <span class="comment">/* 键的过期时间 */</span></span><br><span class="line">    ....</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>过期字典数据结构结构如下：</p>
<p><img data-src="/mybook.github.io/images/170314415263706.png"></p>
<p>过期字典的 key 是一个指针，指向某个键对象；<br>过期字典的 value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间；</p>
<h2 id="过期删除策略有哪些？"><a href="#过期删除策略有哪些？" class="headerlink" title="过期删除策略有哪些？"></a>过期删除策略有哪些？</h2><p>定时删除：在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。<strong>对内存友好，对CPU不友好</strong><br>惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。<strong>对CPU友好，对内存不友好</strong><br>定期删除：隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。<strong>减少对CPU影响，难以确定删除操作执行的时长和频率</strong></p>
<h2 id="Redis-过期删除策略是什么？"><a href="#Redis-过期删除策略是什么？" class="headerlink" title="Redis 过期删除策略是什么？"></a>Redis 过期删除策略是什么？</h2><p> Redis 选择「惰性删除+定期删除」这两种策略配和使用</p>
<p>惰性删除：<br>Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 lazyfree_lazy_expire 参数配置决定，然后返回 null 客户端；如果没有过期，不做任何处理，然后返回正常的键值对给客户端；<br>定期删除：<br>1、这个间隔检查的时间是多长呢？<br>在 Redis 中，默认每秒进行 10 次过期检查一次数据库<br>2、随机抽查的数量是多少呢？<br>定期删除的实现在 expire.c 文件下的 activeExpireCycle 函数中，其中随机抽查的数量由 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 定义的，它是写死在代码中的，数值是 20。</p>
<p> Redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
<li>定期删除是一个循环的流程。Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</li>
</ol>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>1、不进行数据淘汰的策略<br>noeviction（Redis3.0之后，默认的内存淘汰策略） ：</p>
<p>2、进行数据淘汰的策略<br>针对「进行数据淘汰」这一类策略，又可以细分为「在设置了过期时间的数据中进行淘汰」和「在所有数据范围内进行淘汰」这两类策略。</p>
<p>在设置了过期时间的数据中进行淘汰：</p>
<ol>
<li>volatile-random：随机淘汰设置了过期时间的任意键值；</li>
<li>volatile-ttl：优先淘汰更早过期的键值。</li>
<li>volatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；</li>
<li>volatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ol>
<p>在所有数据范围内进行淘汰：</p>
<ol>
<li>allkeys-random：随机淘汰任意键值;</li>
<li>allkeys-lru：淘汰整个键值中最久未使用的键值；</li>
<li>allkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line">1) &quot;maxmemory-policy&quot;</span><br><span class="line">2) &quot;noeviction&quot;</span><br></pre></td></tr></table></figure>
<h2 id="LRU和LFU"><a href="#LRU和LFU" class="headerlink" title="LRU和LFU"></a>LRU和LFU</h2><p><strong>Redis 实现的是一种近似 LRU 算法</strong>，目的是为了更好的节约内存，它的实现方式是在 Redis 的对象结构体中<strong>添加一个额外的字段，用于记录此数据的最后一次访问时间。</strong><br>当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，它是随机取 5 个值（此值可配置），然后淘汰最久没有使用的那个。<strong>但无法解决缓存污染问题</strong></p>
<p>LFU 全称是 Least Frequently Used 翻译为最近最不常用，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“<strong>如果数据过去被访问多次，那么将来被访问的频率也更高</strong>”。<br><strong>LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数</strong>。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。<br>在 LRU 算法中，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。<br>在 LFU 算法中，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p>
<p><img data-src="/mybook.github.io/images/587813417257252.png"></p>
<p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 logc 会随时间推移而衰减的。</p>
<p>在每次 key 被访问时，<strong>会先对 logc 做一个衰减操作</strong>，衰减的值跟前后访问时间的差距有关系，<strong>如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大</strong>，这样实现的 LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p>
<p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是<strong>根据概率增加</strong>，如果 logc 越大的 key，它的 logc 就越难再增加。</p>
<p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：<br>lfu-decay-time 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time 值越大，衰减越慢；<br>lfu-log-factor 用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</p>
<h1 id="Redis的高可用"><a href="#Redis的高可用" class="headerlink" title="Redis的高可用"></a>Redis的高可用</h1><h2 id="主从结构"><a href="#主从结构" class="headerlink" title="主从结构"></a>主从结构</h2><p><img data-src="/mybook.github.io/images/488184417250386.png"></p>
<p>在服务器 B 上执行下面这条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>
<p>接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。</p>
<p>主从服务器间的第一次同步的过程可分为三个阶段：</p>
<p><img data-src="/mybook.github.io/images/150742911246842.png"></p>
<h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><ol>
<li>第一阶段是建立链接、协商同步</li>
</ol>
<p>从服务器会给主服务器发送 psync 命令，表示要进行数据同步。psync 命令包含两个参数，分别是<strong>主服务器的 runID <strong>和</strong>复制进度 offset</strong>。</p>
<ul>
<li>runID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当从服务器和主服务器第一次同步时，因为不知道主服务器的 run ID，所以将其设置为 “?”。</li>
<li>offset，表示复制的进度，第一次同步时，其值为 -1。</li>
</ul>
<p>主服务器收到 psync 命令后，会用 FULLRESYNC 作为响应命令返回给对方。并且这个响应命令会带上这两个参数。从服务器收到响应后，会记录这两个值。FULLRESYNC 响应命令的意图是<strong>采用全量复制的方式</strong></p>
<ol start="2">
<li>第二阶段是主服务器同步数据给从服务器；</li>
</ol>
<p>主服务器会执行 bgsave 命令（异步）来生成 RDB 文件，然后把文件发送给从服务器。从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。<br>但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。<br>为了保证主从服务器的数据一致性，主服务器在下面这三个时间间隙中将收到的写操作命令，写入到<strong>replication buffer 缓冲区</strong>里：</p>
<ul>
<li>主服务器生成 RDB 文件期间；</li>
<li>主服务器发送 RDB 文件给从服务器期间；</li>
<li>「从服务器」加载 RDB 文件期间；</li>
</ul>
<ol start="3">
<li>第三阶段是主服务器发送新写操作命令给从服务器。</li>
</ol>
<p>从服务器完成 RDB 的载入后，会回复一个确认消息给主服务器。主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行来自主服务器 replication buffer 缓冲区里发来的命令，这时主从服务器的数据就一致了。</p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接，而且这个连接是长连接的，<strong>目的是避免频繁的 TCP 连接和断开带来的性能开销</strong>。</p>
<h3 id="分摊主服务器的压力"><a href="#分摊主服务器的压力" class="headerlink" title="分摊主服务器的压力"></a>分摊主服务器的压力</h3><p>主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：</p>
<ol>
<li>bgsave生成 RDB文件的，主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据很大，在执行 fork() 函数时会阻塞主线程，从而使得 Redis 无法正常处理请求</li>
<li>传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。</li>
</ol>
<p>从服务器可以有自己的从服务器，可以把拥有从服务器的从服务器当作<strong>经理角色</strong>，它不仅可以接收主服务器的同步数据，自己也可以同时作为主服务器的形式将数据同步给从服务器，<strong>主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器</strong></p>
<p><img data-src="/mybook.github.io/images/49241511240549.png"></p>
<p>在「从服务器」上执行下面这条命令，使其作为目标服务器的从服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">replicaof &lt;目标服务器的IP&gt; 6379</span><br></pre></td></tr></table></figure>



<h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据。<br>从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用增量复制的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p>
<p><img data-src="/mybook.github.io/images/252172211258975.png"></p>
<ol>
<li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1；</li>
<li>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li>
<li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li>
</ol>
<p><strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong><br>repl_backlog_buffer，是一个「环形」缓冲区，用于主从服务器断连后，从中找到差异的数据；<br>replication offset，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。</p>
<p>从Redis完成初始化后，每一个对主Redis的操作会被发送到从Redis执行相同操作，这被称为增量同步，以保证主从Redis数据一致性。<br>默认情况下，slave只读不写，所以一般对Redis的读操作都在slave上进行，以达到分担master压力的目的，master上只进行写操作。</p>
<p><strong>repl_backlog_buffer 缓冲区是什么时候写入的呢？</strong></p>
<p>在主服务器<strong>进行命令传播时</strong>，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令。</p>
<p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用增量同步的方式；相反，主服务器将采用全量同步的方式。</p>
<p>repl_backlog_buffer 缓行缓冲区的默认大小是 1M，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，应该调整repl_backlog_buffer 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。<br><img data-src="/mybook.github.io/images/554712018267008.png"></p>
<h3 id="主从同步策略"><a href="#主从同步策略" class="headerlink" title="主从同步策略"></a>主从同步策略</h3><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p>
<h3 id="如何应对主从数据不一致？"><a href="#如何应对主从数据不一致？" class="headerlink" title="如何应对主从数据不一致？"></a><font color="red">如何应对主从数据不一致？</font></h3><p>主从节点间的命令复制是异步进行的，所以会主从数据不一致</p>
<ol>
<li><p>保证主从节点间的网络连接状况良好，避免主从节点在不同的机房。</p>
</li>
<li><p>可以开发一个外部程序来监控主从节点间的复制进度。具体做法：<br>Redis 的 INFO replication 命令可以查看主节点接收写命令的进度信息（master_repl_offset）和从节点复制写命令的进度信息（slave_repl_offset），所以，我们就可以开发一个监控程序，先用 INFO replication 命令查到主、从节点的进度，这样就能得到从节点和主节点间的复制进度差值了。<br>如果某个从节点的进度差值大于我们预设的阈值，我们可以让客户端不再和这个从节点连接进行数据读取，这样就可以减少读到不一致数据的情况。不过，为了避免出现客户端和所有从节点都不能连接的情况，我们需要把复制进度差值的阈值设置得大一些。</p>
</li>
</ol>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h3 id="哨兵的职责"><a href="#哨兵的职责" class="headerlink" title="哨兵的职责"></a>哨兵的职责</h3><p>哨兵节点主要负责三件事情：监控、通知、选主。</p>
<ol>
<li>检测主从节点是否运转正常</li>
<li>收集主从节点信息，出错的时候可以通过API通知系统管理员</li>
<li>自动failover：当一个master节点出现了问题，多个哨兵需要沟通是否真的确认出现问题，确认出现问题要检查其他slave节点的情况，自动选举新的适合充当master节点的slave，改变其状态成为新的master，继续提供服务并管理其他slave</li>
</ol>
<p><mark>第三个职责自动failover是哨兵最重要的职责，配合主从架构很好的保证了系统的高可用性，</mark>前面讲过主从架构中所有master和slave的数据都是一致的，所以当提供主要服务的master宕机，可以立刻把拥有相同数据的slave推举为新的master继续提供服务，而不会造成业务的不可用。</p>
<p>注：一个哨兵可以设置监测多个redis节点，但是没必要设置监测slave节点，监测master节点时会自动获取到slave节点的信息。</p>
<h3 id="如何判断主节点真的故障了？"><a href="#如何判断主节点真的故障了？" class="headerlink" title="如何判断主节点真的故障了？"></a>如何判断主节点真的故障了？</h3><p><img data-src="/mybook.github.io/images/460293209259679.png"></p>
<ol>
<li>主管下线<br>如果主节点或者从节点没有在规定的时间内发送PONG，响应哨兵的 PING 命令，哨兵就会将它们标记为<strong>「主观下线」</strong>（sdown状态）。这个「规定的时间」是配置项 down-after-milliseconds 参数设定的</li>
<li>客观下线<br>可能只是因为主节点的系统压力比较大或者网络发送了拥塞，当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令（is-master-down-by-addr），其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。<br>如果超过规定数量的哨兵将该Redis节点标注成了sdown状态，即可确定这个服务确实成为了不可用状态，将该状态改为odown，也就是客观的不可用状态，准备进行新master节点的推举来代替该redis节点继续提供服务。</li>
</ol>
<p><img data-src="/mybook.github.io/images/425823609256234.png"></p>
<h3 id="由哪个哨兵进行主从故障转移？"><a href="#由哪个哨兵进行主从故障转移？" class="headerlink" title="由哪个哨兵进行主从故障转移？"></a>由哪个哨兵进行主从故障转移？</h3><p>需要在哨兵集群中选出一个 leader，让 leader 来执行主从切换。哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者。</p>
<p>任何一个「候选者」，要满足两个条件：</p>
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
<p><strong>如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线？</strong><br>每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。投票者先收到谁的投票请求，就会先投票给它，如果投票者用完投票机会后，就会拒绝投票。</p>
<h3 id="三个哨兵原则"><a href="#三个哨兵原则" class="headerlink" title="三个哨兵原则"></a>三个哨兵原则</h3><p>哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成哨兵集群（最少需要三台机器来部署哨兵集群），通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p>一个高可用的架构应该至少包括三个部署在不同服务器上的哨兵，因为如果只有两个哨兵，有一台服务器挂了，哨兵也就只剩下了一个，即使能确定服务器上redis服务的odown状态，也没有超过半数（超过2&#x2F;2 &#x3D; 1个哨兵）的哨兵来选举出哨兵执行failover，因此一个合理的系统至少有三台服务器，三个哨兵来保证系统的高可用性</p>
<p><strong>Redis 1 主 4 从，5 个哨兵，quorum 设置为 3，如果 2 个哨兵故障，当主节点宕机时，哨兵能否判断主节点“客观下线”？主从能否自动切换？</strong><br>哨兵集群可以判定主节点“客观下线”。哨兵集群还剩下 3 个哨兵，当一个哨兵判断主节点“主观下线”后，询问另外 2 个哨兵后，<strong>有可能能拿到 3 张赞同票，这时就达到了 quorum 的值</strong>，因此，哨兵集群可以判定主节点为“客观下线”。</p>
<p>哨兵集群可以完成主从切换。当有个哨兵标记主节点为「客观下线」后，就会进行选举 Leader 的过程，因为此时哨兵集群还剩下 3 个哨兵，<strong>那么还是可以拿到半数以上（5&#x2F;2+1&#x3D;3）的票，而且也达到了 quorum 值</strong>，满足了选举 Leader 的两个条件，所以就能选举成功，因此哨兵集群可以完成主从切换。</p>
<p>如果 quorum 设置为 2，并且如果有 3 个哨兵故障的话。此时哨兵集群还是可以判定主节点为“客观下线”，但是哨兵不能完成主从切换了，大家可以自己推演下。</p>
<p>如果 quorum 设置为 3，并且如果有 3 个哨兵故障的话，哨兵集群即不能判定主节点为“客观下线”，也不能完成主从切换了。</p>
<p><strong>quorum 的值建议设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且哨兵节点的数量应该是奇数。</strong></p>
<h3 id="脑裂现象"><a href="#脑裂现象" class="headerlink" title="脑裂现象"></a>脑裂现象</h3><p>如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的。<br>这个客户端并不知道 Redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据，此时这些数据被主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。<br>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在从节点中选举出一个 leeder 作为主节点，这时集群就有两个主节点了 —— 脑裂出现了。</p>
<h3 id="主从切换如何减少数据丢失？"><a href="#主从切换如何减少数据丢失？" class="headerlink" title="主从切换如何减少数据丢失？"></a><font color="red">主从切换如何减少数据丢失？</font></h3><ol>
<li><p>异步复制同步丢失<br>当客户端发送写请求给主节点的时候，客户端会返回 ok，接着主节点将写请求异步同步给各个从节点，但是如果此时主节点还没来得及同步给从节点时发生了断电，那么主节点内存中的数据会丢失。<br>Redis 配置里有一个参数 min-slaves-max-lag，表示一旦所有的从节点数据复制和同步的延迟都超过了 min-slaves-max-lag 定义的值，那么主节点就会拒绝接收任何请求，即使 master 宕机也只是这未复制的 10s 数据。<br>当客户端发现 master 不可写后，可以采取降级措施，将数据暂时写入本地缓存、磁盘、kafka 消息队列中，在一段时间（等 master 恢复正常）后重新写入 master 来保证数据不丢失。</p>
</li>
<li><p>集群产生脑裂数据丢失<br>脑裂现象产生后，这时候网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，因为第一次同步是全量同步的方式，<strong>此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步</strong>。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题。<br>解决方案：<br>当主节点发现「从节点下线的数量太多」，或者「网络延迟太大」的时候，那么主节点会禁止写操作，直接把错误返回给客户端。</p>
</li>
</ol>
<p>在 Redis 的配置文件中有两个参数我们可以设置：</p>
<ol>
<li>min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</li>
<li>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果主从同步的延迟超过 x 秒，主节点会禁止写数据。<br>分别给它们设置一定的阈值，假设为 N 和 T。这两个配置项组合后的要求是，<strong>主节点连接的从节点中至少有 N 个从节点，「并且」主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主节点就不会再接收客户端的写请求了</strong>。</li>
</ol>
<p>等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。</p>
<h2 id="高可用架构"><a href="#高可用架构" class="headerlink" title="高可用架构"></a>高可用架构</h2><h3 id="主从故障转移的过程是怎样的？"><a href="#主从故障转移的过程是怎样的？" class="headerlink" title="主从故障转移的过程是怎样的？"></a>主从故障转移的过程是怎样的？</h3><p>主从故障转移操作包含以下四个步骤：</p>
<ol>
<li>在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li>
<li>让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li>
<li>继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ol>
<h4 id="选出新主节点"><a href="#选出新主节点" class="headerlink" title="选出新主节点"></a>选出新主节点</h4><p>故障转移操作第一步要做的就是在已下线主节点属下的所有「从节点」中，挑选出一个状态良好、数据完整的从节点，然后向这个「从节点」发送 SLAVEOF no one 命令，将这个「从节点」转换为「主节点」。</p>
<p><strong>那么多「从节点」，到底选择哪个从节点作为新主节点的？</strong></p>
<p>先进行网络过滤<br>Redis 有个叫 down-after-milliseconds * 10 配置项，其 down-after-milliseconds 是主从节点断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从节点的网络状况不好，不适合作为新主节点。</p>
<p>再进行三轮考察：优先级、复制进度、ID 号。</p>
<ol>
<li><p>哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前，<br>Redis 有个叫 slave-priority 配置项，可以给从节点设置优先级。如果「A 从节点」的物理内存是所有从节点中最大的，那么我们可以把「A 从节点」的优先级设置成最高。</p>
</li>
<li><p>如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。<br>如果某个从节点的 slave_repl_offset 最接近 master_repl_offset，说明它的复制进度是最靠前的，于是就可以将它选为新主节点。</p>
</li>
<li><p>如果优先级和下标都相同，就选择从节点 ID 较小的那个。<br>每个从节点都有一个编号，这个编号就是 ID 号，是用来唯一标识从节点的。</p>
</li>
</ol>
<p>如下图，哨兵 leader 向被选中的从节点 server2 发送 SLAVEOF no one 命令，将该从节点升级为新主节点。</p>
<p><img data-src="/mybook.github.io/images/99025809251988.png"></p>
<p>在发送 SLAVEOF no one 命令之后，哨兵 leader 会以每秒一次的频率向被升级的从节点发送 INFO 命令（没进行故障转移之前，INFO 命令的频率是每十秒一次），并观察命令回复中的角色信息，当被升级节点的角色信息从原来的 slave 变为 master 时，哨兵 leader 就知道被选中的从节点已经顺利升级为主节点了。</p>
<h4 id="将从节点指向新主节点"><a href="#将从节点指向新主节点" class="headerlink" title="将从节点指向新主节点"></a>将从节点指向新主节点</h4><p>向「从节点」发送 SLAVEOF 命令来实现。</p>
<p><img data-src="/mybook.github.io/images/493510010269868.png"></p>
<h4 id="通知客户的主节点已更换"><a href="#通知客户的主节点已更换" class="headerlink" title="通知客户的主节点已更换"></a>通知客户的主节点已更换</h4><p>通过 Redis 的发布者&#x2F;订阅者机制来实现，主从切换完成后，哨兵就会向 +switch-master 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了。</p>
<p><img data-src="/mybook.github.io/images/414930110267472.png"></p>
<h4 id="将旧主节点变为从节点"><a href="#将旧主节点变为从节点" class="headerlink" title="将旧主节点变为从节点"></a>将旧主节点变为从节点</h4><p>继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 SLAVEOF 命令，让它成为新主节点的从节点</p>
<p><img data-src="/mybook.github.io/images/443500610264974.png"></p>
<h3 id="哨兵集群是如何组成的？"><a href="#哨兵集群是如何组成的？" class="headerlink" title="哨兵集群是如何组成的？"></a>哨兵集群是如何组成的？</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; </span><br></pre></td></tr></table></figure>

<p><strong>为什么只需要执行命令设置主节点名字、主节点的 IP 地址和端口号以及 quorum 值，就能搭建哨兵集群？</strong></p>
<p>在主从集群中，主节点上有一个名为__sentinel__:hello的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p>
<p>哨兵 A 把自己的 IP 地址和端口的信息发布到__sentinel__:hello 频道上，哨兵 B 和 C 订阅了该频道。那么此时，哨兵 B 和 C 就可以从这个频道直接获取哨兵 A 的 IP 地址和端口号。然后，哨兵 B、C 可以和哨兵 A 建立网络连接。</p>
<p><img data-src="/mybook.github.io/images/53561010246215.png"></p>
<p><strong>那哨兵集群如何知道「从节点」的信息？</strong></p>
<p>主节点知道所有「从节点」的信息，所以哨兵会每 10 秒一次的频率向主节点发送 INFO 命令来获取所有「从节点」的信息。</p>
<h1 id="Redis的缓存机制"><a href="#Redis的缓存机制" class="headerlink" title="Redis的缓存机制"></a>Redis的缓存机制</h1><h2 id="缓存污染和预读失效"><a href="#缓存污染和预读失效" class="headerlink" title="缓存污染和预读失效"></a>缓存污染和预读失效</h2><p>详情请见操作系统–内存篇</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><ol>
<li>大量缓存数据在同一时间过期（失效）</li>
<li>Redis 故障宕机<br>此时如果有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，<strong>从而导致数据库的压力骤增，严重的会造成数据库宕机</strong>，从而形成一系列连锁反应，造成整个系统崩溃。</li>
</ol>
<h3 id="大量数据同时过期"><a href="#大量数据同时过期" class="headerlink" title="大量数据同时过期"></a>大量数据同时过期</h3><h4 id="均匀设置过期时间"><a href="#均匀设置过期时间" class="headerlink" title="均匀设置过期时间"></a>均匀设置过期时间</h4><p>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里）</strong>，当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</p>
<p><strong>实现互斥锁的时候，最好设置超时时间，</strong>不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</p>
<h4 id="后台更新缓存"><a href="#后台更新缓存" class="headerlink" title="后台更新缓存"></a>后台更新缓存</h4><p>业务线程不再负责更新缓存，缓存也不设置有效期，而是<strong>让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新。</strong></p>
<p>事实上，缓存数据不设置有效期，<strong>并不是意味着数据一直能在内存里，因为当系统内存紧张的时候，有些缓存数据会被淘汰</strong>，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了。</p>
<ol>
<li><strong>后台线程不仅负责定时更新缓存，而且也负责频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</li>
</ol>
<p>这种方式的检测时间间隔不能太长，太长也导致用户获取的数据是一个空值而不是真正的数据，所以检测的间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般。</p>
<ol start="2">
<li>在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</li>
</ol>
<h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p>在业务刚上线的时候，我提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的缓存预热，后台更新缓存的机制刚好也适合干这个事情。<br>Redis自带缓存预读，注意甄别区别</p>
<h3 id="Redis-故障宕机"><a href="#Redis-故障宕机" class="headerlink" title="Redis 故障宕机"></a>Redis 故障宕机</h3><h4 id="服务熔断或请求限流机制"><a href="#服务熔断或请求限流机制" class="headerlink" title="服务熔断或请求限流机制"></a>服务熔断或请求限流机制</h4><ul>
<li><p>可以启动服务熔断机制，<strong>暂停业务应用对缓存服务的访问</strong>，直接返回错误，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。</p>
</li>
<li><p>为了减少对业务的影响，可以<strong>启用请求限流机制</strong>，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。</p>
</li>
</ul>
<h4 id="构建-Redis-缓存高可靠集群"><a href="#构建-Redis-缓存高可靠集群" class="headerlink" title="构建 Redis 缓存高可靠集群"></a>构建 Redis 缓存高可靠集群</h4><p>主从节点的方式构建 Redis 缓存高可靠集群。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>热点数据过期，大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮。<br>可以认为缓存击穿是缓存雪崩的一个子集。应对缓存击穿可以采取前面说到两种方案：</p>
<ol>
<li>互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ol>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>当用户访问的数据，既不在缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，<strong>没办法构建缓存数据</strong>，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。</p>
<p>缓存穿透的发生一般有这两种情况：</p>
<ol>
<li>业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据；</li>
<li>黑客恶意攻击，故意大量访问某些读取不存在数据的业务；</li>
</ol>
<p>应对缓存穿透的方案，常见的方案有三种。</p>
<h3 id="非法请求的限制"><a href="#非法请求的限制" class="headerlink" title="非法请求的限制"></a>非法请求的限制</h3><p>在入口处进行参数校验，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p>
<h3 id="缓存空值或者默认值"><a href="#缓存空值或者默认值" class="headerlink" title="缓存空值或者默认值"></a>缓存空值或者默认值</h3><p>可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库。</p>
<h3 id="布隆过滤器快速判断数据是否存在"><a href="#布隆过滤器快速判断数据是否存在" class="headerlink" title="布隆过滤器快速判断数据是否存在"></a>布隆过滤器快速判断数据是否存在</h3><p>可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在。<br>即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器由「初始值都为 0 的位图数组」和「 N 个哈希函数」两部分组成。</p>
<p>布隆过滤器会通过 3 个操作完成标记：</p>
<ol>
<li>使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；</li>
<li>将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。</li>
<li>将每个哈希值在位图数组的对应位置的值设置为 1；</li>
</ol>
<p>假设有一个位图数组长度为 8，哈希函数 3 个的布隆过滤器。</p>
<p><img data-src="/mybook.github.io/images/41684310268655.png"></p>
<p>当应用要查询数据 x 是否数据库时，通过布隆过滤器只要查到位图数组的第 1、4、6 位置的值是否全为 1，只要有一个为 0，就认为数据 x 不在数据库中。</p>
<p>布隆过滤器由于是基于哈希函数实现查找的，高效查找的同时<strong>存在哈希冲突的可能性</strong>，比如数据 x 和数据 y 可能都落在第 1、4、6 位置，而事实上，可能数据库中并不存在数据 y，存在误判的情况。</p>
<p><strong>查询布隆过滤器查询到数据不存在，数据库中一定就不存在这个数据，数据存在，并不一定证明数据库中存在这个数据。</strong></p>
<h1 id="Redis的系统设计"><a href="#Redis的系统设计" class="headerlink" title="Redis的系统设计"></a>Redis的系统设计</h1><h2 id="数据库和缓存的数据如何保持一致性"><a href="#数据库和缓存的数据如何保持一致性" class="headerlink" title="数据库和缓存的数据如何保持一致性"></a>数据库和缓存的数据如何保持一致性</h2><h3 id="先更新数据库，再更新缓存？"><a href="#先更新数据库，再更新缓存？" class="headerlink" title="先更新数据库，再更新缓存？"></a>先更新数据库，再更新缓存？</h3><p>并发问题导致：</p>
<p><img data-src="/mybook.github.io/images/241604910263791.png"></p>
<h3 id="先更新缓存，再更新数据库？"><a href="#先更新缓存，再更新数据库？" class="headerlink" title="先更新缓存，再更新数据库？"></a>先更新缓存，再更新数据库？</h3><p><img data-src="/mybook.github.io/images/376975010257337.png"></p>
<p>如果业务对缓存命中率有很高的要求，可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。<br>在更新缓存前先加个分布式锁，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。<br>在更新完缓存时，给缓存加上较短的过期时间，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。</p>
<h3 id="所以先更新数据库，还是先删除缓存？"><a href="#所以先更新数据库，还是先删除缓存？" class="headerlink" title="所以先更新数据库，还是先删除缓存？"></a>所以先更新数据库，还是先删除缓存？</h3><p>是否可以借用cpu三级缓存失效策略？可以，详情请见操作系统–cpu篇</p>
<p>Cache Aside 策略(旁路缓存策略):不更新缓存，而是删除缓存中的数据。然后，到读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。</p>
<p><img data-src="/mybook.github.io/images/304165210250471.png"></p>
<p>这样的话在写时又会带来两个问题</p>
<h4 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库?"></a>先删除缓存，再更新数据库?</h4><p><img data-src="/mybook.github.io/images/470005410241001.png"></p>
<p>先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题。</p>
<p>解决方法可以使用延迟双删，延迟双删实现的伪代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">#删除缓存</span><br><span class="line">redis.delKey(X)</span><br><span class="line">#更新数据库</span><br><span class="line">db.update(X)</span><br><span class="line">#睡眠</span><br><span class="line">Thread.sleep(N)</span><br><span class="line">#再删除缓存</span><br><span class="line">redis.delKey(X)</span><br></pre></td></tr></table></figure>
<p>请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。但是具体睡眠多久其实是个玄学，</p>
<h4 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存?"></a>先更新数据库，再删除缓存?</h4><p><img data-src="/mybook.github.io/images/318075510243505.png"></p>
<p>先更新数据库，再删除缓存也是会出现数据不一致性的问题</p>
<p><strong>但是：</strong><br>redis运行在内存中，数据库实例在磁盘中，内存的速度远大于磁盘，所以上述的情况基本不存在，<strong>「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的</strong>。<br>为了确保万无一失，还可以给缓存数据加上了「过期时间」，就算在这期间存在缓存数据不一致，有过期时间来兜底，这样也能达到最终一致。</p>
<p>问题：<br><strong>明明更新了数据，但是数据要过一段时间才生效，客户接受不了。</strong><br>如果在删除缓存（第二个操作）的时候失败了，会导致缓存中的数据是旧值。加上了过期时间，所以才会出现客户说的过一段时间才更新生效的现象，假设如果没有这个过期时间的兜底，那后续的请求读到的就会一直是缓存中的旧数据，这样问题就更大了。</p>
<p><img data-src="/mybook.github.io/images/525772711245337.png"></p>
<p><strong>如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功</strong>？<br>其实不管是先操作数据库，还是先操作缓存，只要第二个操作失败都会出现数据一致的问题。有两种方法：都是采用异步操作缓存。</p>
<ul>
<li><p>重试机制。<br>可以引入消息队列，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。<br>如果应用删除缓存失败，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是重试机制。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。<br>如果删除缓存成功，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。</p>
</li>
<li><p>订阅 MySQL binlog，再操作缓存。<br>第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。<br>Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p>
</li>
</ul>
<p><img data-src="/mybook.github.io/images/19073311245946.png"></p>
<h1 id="Redis常见面试题和总结"><a href="#Redis常见面试题和总结" class="headerlink" title="Redis常见面试题和总结"></a>Redis常见面试题和总结</h1><h2 id="Redis-和-Memcached-有什么区别？"><a href="#Redis-和-Memcached-有什么区别？" class="headerlink" title="Redis 和 Memcached 有什么区别？"></a>Redis 和 Memcached 有什么区别？</h2><ul>
<li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li>
</ul>
<h2 id="为什么用-Redis-作为-MySQL-的缓存？"><a href="#为什么用-Redis-作为-MySQL-的缓存？" class="headerlink" title="为什么用 Redis 作为 MySQL 的缓存？"></a>为什么用 Redis 作为 MySQL 的缓存？</h2><ol>
<li><p>Redis 具备高性能<br>运行在内存中</p>
</li>
<li><p>Redis 具备高并发<br>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。</p>
</li>
</ol>
<h2 id="Redis-6-0-之前为什么使用单线程？"><a href="#Redis-6-0-之前为什么使用单线程？" class="headerlink" title="Redis 6.0 之前为什么使用单线程？"></a>Redis 6.0 之前为什么使用单线程？</h2><p>CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络I&#x2F;O的限制，</p>
<h2 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h2><p>Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上。Redis 6.0 版本引入的多线程 I&#x2F;O 特性对性能提升至少是一倍以上。</p>
<p>默认情况下 I&#x2F;O 多线程只针对发送响应数据（write client socket），并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//读请求也使用io多线程</span><br><span class="line">io-threads-do-reads yes </span><br></pre></td></tr></table></figure>



<p>同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// io-threads N，表示启用 N-1 个 I/O 多线程（主线程也算一个 I/O 线程）</span><br><span class="line">io-threads 4 </span><br></pre></td></tr></table></figure>

<p>默认情况下会额外创建 6 个线程（这里的线程数不包括主线程）：</p>
<ul>
<li>Redis-server ： Redis的主线程，主要负责执行命令；</li>
<li>bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；</li>
<li>io_thd_1、io_thd_2、io_thd_3：三个 I&#x2F;O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I&#x2F;O 多线程，用来分担 Redis 网络 I&#x2F;O 的压力。</li>
</ul>
<h2 id="怎么判断-Redis-某个节点是否正常工作？"><a href="#怎么判断-Redis-某个节点是否正常工作？" class="headerlink" title="怎么判断 Redis 某个节点是否正常工作？"></a>怎么判断 Redis 某个节点是否正常工作？</h2><p>Redis 判断节点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p>
<p>Redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：</p>
<p>Redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。<br>Redis 从节点每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：<br>实时监测主从节点网络状态；<br>上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。</p>
<h2 id="主从复制架构中，过期key如何处理？"><a href="#主从复制架构中，过期key如何处理？" class="headerlink" title="主从复制架构中，过期key如何处理？"></a>主从复制架构中，过期key如何处理？</h2><p>主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。</p>
<h2 id="主从复制中两个Buffer有什么区别？"><a href="#主从复制中两个Buffer有什么区别？" class="headerlink" title="主从复制中两个Buffer有什么区别？"></a>主从复制中两个Buffer有什么区别？</h2><p>replication buffer 、repl backlog buffer 区别如下：</p>
<ul>
<li><p>出现的阶段不一样：<br>repl backlog buffer 是在增量复制阶段出现，<strong>一个主节点只分配一个 repl backlog buffer</strong>；<br>replication buffer 是在全量复制阶段和增量复制阶段都会出现，<strong>主节点会给每个新连接的从节点，分配一个 replication buffer</strong>；</p>
</li>
<li><p>这两个 Buffer 都有大小限制的，当缓冲区满了之后，发生的事情不一样：<br>当 repl backlog buffer 满了，因为是环形结构，<strong>会直接覆盖起始位置数据</strong>;<br>当 replication buffer 满了，会导致连接断开，删除缓存，从节点重新连接，<strong>重新开始全量复制</strong>。</p>
</li>
</ul>
<h2 id="Redis-主从模式中，对过期键会如何处理？"><a href="#Redis-主从模式中，对过期键会如何处理？" class="headerlink" title="Redis 主从模式中，对过期键会如何处理？"></a>Redis 主从模式中，对过期键会如何处理？</h2><p>当 Redis 运行在主从模式下时，从库不会进行过期扫描，从库对过期的处理是被动的。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。</p>
<p>从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p>
<h2 id="Redis-内存满了，会发生什么？"><a href="#Redis-内存满了，会发生什么？" class="headerlink" title="Redis 内存满了，会发生什么？"></a>Redis 内存满了，会发生什么？</h2><p>在 Redis 的运行内存达到了某个阀值，就会触发内存淘汰机制(OOM)，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。</p>
<h2 id="如何设计一个缓存策略，可以动态缓存热点数据呢？"><a href="#如何设计一个缓存策略，可以动态缓存热点数据呢？" class="headerlink" title="如何设计一个缓存策略，可以动态缓存热点数据呢？"></a>如何设计一个缓存策略，可以动态缓存热点数据呢？</h2><p>由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，<strong>而只是将其中一部分热点数据缓存起来</strong>，所以我们要设计一个热点数据动态缓存的策略。</p>
<p>热点数据动态缓存的策略总体思路：<strong>通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据</strong>。</p>
<p>以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：</p>
<p>先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；<br>同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；<br>这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。<br>在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作。</p>
<h2 id="Redis-如何实现延迟队列？"><a href="#Redis-如何实现延迟队列？" class="headerlink" title="Redis 如何实现延迟队列？"></a>Redis 如何实现延迟队列？</h2><p>延迟队列是指把当前要做的事情，往后推迟一段时间再做。延迟队列的常见使用场景有以下几种：</p>
<ul>
<li>在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消；</li>
<li>打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单；</li>
<li>点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单；</li>
</ul>
<p>在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，<strong>ZSet 有一个 Score 属性可以用来存储延迟执行的时间</strong>。</p>
<p>使用 zadd score1 value1 命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务， 通过循环执行队列任务即可。</p>
<p><img data-src="/mybook.github.io/images/199813014258977.png"></p>
<h2 id="Redis-的大-key-如何处理？"><a href="#Redis-的大-key-如何处理？" class="headerlink" title="Redis 的大 key 如何处理？"></a>Redis 的大 key 如何处理？</h2><p>key 对应的 value 很大。String 类型的值大于 10 KB；Hash、List、Set、ZSet 类型的元素的个数超过 5000个；<br>大 key 会带来以下四种影响：</p>
<ul>
<li>客户端超时阻塞。<br>由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li>引发网络阻塞。<br>每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li>阻塞工作线程。<br>如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
<li>内存分布不均。<br>集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li>
</ul>
<h3 id="如何查找大key"><a href="#如何查找大key" class="headerlink" title="如何查找大key"></a>如何查找大key</h3><h4 id="redis-cli-–bigkeys-查找大key"><a href="#redis-cli-–bigkeys-查找大key" class="headerlink" title="redis-cli –bigkeys 查找大key"></a>redis-cli –bigkeys 查找大key</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p6379 -a &quot;password&quot; -- bigkeys</span><br></pre></td></tr></table></figure>

<p>注意事项：<br><strong>最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点</strong>；<br>如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。</p>
<p>该方式的不足之处：</p>
<p>这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；<br>对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，<strong>一个集合中的元素个数多，并不一定占用的内存就多</strong>。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；</p>
<h4 id="使用-SCAN-命令查找大-key"><a href="#使用-SCAN-命令查找大-key" class="headerlink" title="使用 SCAN 命令查找大 key"></a>使用 SCAN 命令查找大 key</h4><p>使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。</p>
<p>对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。</p>
<p>对于集合类型来说，有两种方法可以获得它占用的内存大小：</p>
<p>如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：LLEN 命令；Hash 类型：HLEN 命令；Set 类型：SCARD 命令；Sorted Set 类型：ZCARD 命令；<br>如果不能提前知道写入集合的元素大小，可以使用 MEMORY USAGE 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。</p>
<h4 id="使用-RdbTools-工具查找大-key"><a href="#使用-RdbTools-工具查找大-key" class="headerlink" title="使用 RdbTools 工具查找大 key"></a>使用 RdbTools 工具查找大 key</h4><p>使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。<br>比如，下面这条命令，将大于 10 kb 的  key  输出到一个表格文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rdb dump.rdb -c memory --bytes 10240 -f redis.csv</span><br></pre></td></tr></table></figure>


<h3 id="如何删除大key？"><a href="#如何删除大key？" class="headerlink" title="如何删除大key？"></a>如何删除大key？</h3><p>在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。</p>
<p>如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，<strong>相应地就会造成 Redis 主线程的阻塞</strong>，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>
<h4 id="分批次删除"><a href="#分批次删除" class="headerlink" title="分批次删除"></a>分批次删除</h4><p>对于删除大 Hash，使用 hscan 命令，每次获取 100 个字段，再用 hdel 命令，每次删除 1 个字段。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_hash</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">    large_hash_key =<span class="string">&quot;xxx&quot;</span> <span class="comment">#要删除的大hash键名</span></span><br><span class="line">    cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 使用 hscan 命令，每次获取 100 个字段</span></span><br><span class="line">        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data.items():</span><br><span class="line">                <span class="comment"># 再用 hdel 命令，每次删除1个字段</span></span><br><span class="line">                r.hdel(large_hash_key, item[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>对于删除大 List，通过 ltrim 命令，每次删除少量元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_list</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_list_key = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment">#要删除的大list的键名</span></span><br><span class="line">  <span class="keyword">while</span> r.llen(large_list_key)&gt;<span class="number">0</span>:</span><br><span class="line">      <span class="comment">#每次只删除最右100个元素</span></span><br><span class="line">      r.ltrim(large_list_key, <span class="number">0</span>, -<span class="number">101</span>) </span><br></pre></td></tr></table></figure>

<p>对于删除大 Set，使用 sscan 命令，每次扫描集合中 100 个元素，再用 srem 命令每次删除一个键。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_set</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;redis-host1&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_set_key = <span class="string">&#x27;xxx&#x27;</span>   <span class="comment"># 要删除的大set的键名</span></span><br><span class="line">  cursor = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> cursor != <span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 sscan 命令，每次扫描集合中 100 个元素</span></span><br><span class="line">    cursor, data = r.sscan(large_set_key, cursor=cursor, count=<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">      <span class="comment"># 再用 srem 命令每次删除一个键</span></span><br><span class="line">      r.srem(large_size_key, item)</span><br></pre></td></tr></table></figure>

<p>对于删除大 ZSet，使用 zremrangebyrank 命令，每次删除 top 100个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">del_large_sortedset</span>():</span><br><span class="line">  r = redis.StrictRedis(host=<span class="string">&#x27;large_sortedset_key&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line">  large_sortedset_key=<span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">  <span class="keyword">while</span> r.zcard(large_sortedset_key)&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="comment"># 使用 zremrangebyrank 命令，每次删除 top 100个元素</span></span><br><span class="line">    r.zremrangebyrank(large_sortedset_key,<span class="number">0</span>,<span class="number">99</span>) </span><br></pre></td></tr></table></figure>

<h4 id="异步删除"><a href="#异步删除" class="headerlink" title="异步删除"></a>异步删除</h4><p>用 unlink 命令代替 del 来删除。这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。</p>
<ul>
<li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li>
<li>slave-lazy-flush：针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li>
</ul>
<p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p>
<h2 id="Redis-事务支持回滚吗？"><a href="#Redis-事务支持回滚吗？" class="headerlink" title="Redis 事务支持回滚吗？"></a>Redis 事务支持回滚吗？</h2><p>Redis 中并没有提供回滚机制，Redis 并不一定保证原子性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取name原本的值</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;xiaolin&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置新值</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SET name xialincoding</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意，这条命令是错误的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">expire 过期时间正确来说是数字，并不是‘10s’字符串，但是还是入队成功了</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXPIRE name 10s</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提交事务，执行报错</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到 <span class="built_in">set</span> 执行成功，而 expire 执行错误。</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以看到，name 还是被设置为新值了</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;xialincoding&quot;</span><br></pre></td></tr></table></figure>

<p>作者不支持事务回滚的原因有以下两个：</p>
<ol>
<li>他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；</li>
<li>不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚。</li>
</ol>
<h2 id="如何用-Redis-实现分布式锁的？"><a href="#如何用-Redis-实现分布式锁的？" class="headerlink" title="如何用 Redis 实现分布式锁的？"></a>如何用 Redis 实现分布式锁的？</h2><p>Redis 的 SET 命令有个 NX 参数可以实现「key不存在才插入」，所以可以用它来实现分布式锁：</p>
<p>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；<br>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET lock_key unique_value NX PX|EX 10000</span><br></pre></td></tr></table></figure>

<p>解锁的时候，要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</strong>，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>
<h3 id="Redis-如何解决集群情况下分布式锁的可靠性？"><a href="#Redis-如何解决集群情况下分布式锁的可靠性？" class="headerlink" title="Redis 如何解决集群情况下分布式锁的可靠性？"></a>Redis 如何解决集群情况下分布式锁的可靠性？</h3><p>分布式锁算法 Redlock（红锁）,官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p>
<p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。<br>条件一：客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁；<br>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</p>
<p>Redlock 算法加锁三个过程：</p>
<ol>
<li>客户端获取当前时间（t1）。</li>
<li>客户端按顺序依次向 N 个 Redis 节点执行加锁操作：<br>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，需要给「加锁操作」设置一个超时时间（<strong>不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间</strong>），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li>
<li>一旦客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li>
</ol>
<p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p>
<p>加锁失败后，客户端向所有 Redis 节点发起释放锁的操作，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</p>
<p><img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>系统设计</title>
    <url>/mybook.github.io/2024/05/22/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p>
<ul>
<li>最终一致性：这个是弱一致性的一种，不保证在任意时刻同一份数据在所有节点上都是一致的，但是在一段时间之后时间会最终一致。对于我们互联网的应用来说大多数是采用这种策略。</li>
<li>强一致性：在任意时刻同一份数据在所有节点上都是一致的。对于银行、金融行业来说基本采用这种策略。</li>
</ul>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p>
<p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p>
<h3 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h3><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p>
<p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h3><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p>
<p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p>
<p>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；<br>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</p>
<h2 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h2><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p>
<p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p>
<p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p>
<h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
<p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。<br>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p>
<h2 id="分布式锁的场景"><a href="#分布式锁的场景" class="headerlink" title="分布式锁的场景"></a>分布式锁的场景</h2><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p>
<p>阻塞锁通常使用互斥量来实现：<br>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；<br>互斥量为 1 表示未锁定状态。<br>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p>
<h3 id="数据库的唯一索引"><a href="#数据库的唯一索引" class="headerlink" title="数据库的唯一索引"></a>数据库的唯一索引</h3><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p>
<p>存在以下几个问题：</p>
<ul>
<li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li>
<li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li>
<li>不可重入，已经获得锁的进程也必须重新获取锁。</li>
</ul>
<h3 id="Redis-的-SETNX-指令"><a href="#Redis-的-SETNX-指令" class="headerlink" title="Redis 的 SETNX 指令"></a>Redis 的 SETNX 指令</h3><ul>
<li><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p>
</li>
<li><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p>
</li>
<li><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p>
</li>
</ul>
<h3 id="Zookeeper-的有序节点"><a href="#Zookeeper-的有序节点" class="headerlink" title="Zookeeper 的有序节点"></a>Zookeeper 的有序节点</h3><ol>
<li>Zookeeper 抽象模型<br>Zookeeper 提供了一种树形结构的命名空间，&#x2F;app1&#x2F;p_1 节点的父节点为 &#x2F;app1。</li>
</ol>
<p><img data-src="/mybook.github.io/images/2064125869957.png"></p>
<ol start="2">
<li>节点类型<br>永久节点：不会因为会话结束或者超时而消失；<br>临时节点：如果会话结束或者超时就会消失；<br>有序节点：会在节点名的后面加一个数字后缀，并且是有序的.</li>
<li>监听器<br>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</li>
<li>分布式锁实现</li>
</ol>
<ul>
<li><p>创建一个锁目录 &#x2F;lock,当一个客户端需要获取锁时，在 &#x2F;lock 下创建临时的且有序的子节点；</p>
</li>
<li><p>客户端获取 &#x2F;lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</p>
</li>
<li><p>执行业务代码，完成后，删除对应的子节点。</p>
</li>
</ul>
<ol start="5">
<li><p>会话超时<br>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。</p>
</li>
<li><p>羊群效应<br>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。</p>
</li>
</ol>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p>
<p>分布式锁和分布式事务区别：</p>
<ul>
<li><strong>锁问题的关键在于进程操作的互斥关系</strong>，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li>
<li><strong>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性</strong>，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li>
</ul>
<h2 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h2><h3 id="二阶段提交协议（2PC）"><a href="#二阶段提交协议（2PC）" class="headerlink" title="二阶段提交协议（2PC）"></a>二阶段提交协议（2PC）</h3><p>两阶段提交，通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<ol>
<li>准备阶段<br>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。</li>
</ol>
<p><img data-src="/mybook.github.io/images/1800919756710.png"></p>
<ol start="2">
<li>提交阶段<br>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。<br>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</li>
</ol>
<p><img data-src="/mybook.github.io/images/1185629545802.png"></p>
<h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。<br>主要有三类节点：<br>提议者（Proposer）：提议一个值；<br>接受者（Acceptor）：对每个提议进行投票；<br>告知者（Learner）：被告知投票的结果，不参与投票过程。</p>
<p><img data-src="/mybook.github.io/images/5367027659123.png"></p>
<h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><h4 id="单个-Candidate-的竞选"><a href="#单个-Candidate-的竞选" class="headerlink" title="单个 Candidate 的竞选"></a>单个 Candidate 的竞选</h4><ul>
<li><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p>
</li>
<li><p>一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</p>
</li>
<li><p>此时 Node A 发送投票请求给其它所有节点。</p>
</li>
<li><p>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</p>
</li>
<li><p>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</p>
</li>
</ul>
<h4 id="多个-Candidate-竞选"><a href="#多个-Candidate-竞选" class="headerlink" title="多个 Candidate 竞选"></a>多个 Candidate 竞选</h4><ul>
<li><p>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。</p>
</li>
<li><p>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</p>
</li>
</ul>
<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><ul>
<li><p>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</p>
</li>
<li><p>Leader 会把修改复制到所有 Follower。</p>
</li>
<li><p>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</p>
</li>
<li><p>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</p>
</li>
</ul>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>一致性哈希算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。</p>
<p>一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算，是一个固定的值。</p>
<p>我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为哈希环，如下图：</p>
<p><img data-src="/mybook.github.io/images/84610117267373.png"></p>
<p>一致性哈希要进行两步哈希：</p>
<p>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；<br>第二步：当对数据进行存储或访问时，对数据进行哈希映射；<br>所以，一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上。</p>
<h1 id="高可用系统设计"><a href="#高可用系统设计" class="headerlink" title="高可用系统设计"></a>高可用系统设计</h1><h2 id="高可用系统设计要点"><a href="#高可用系统设计要点" class="headerlink" title="高可用系统设计要点"></a>高可用系统设计要点</h2><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>单点是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。</p>
<p>保证高可用的主要手段是使用冗余，或者叫“集群化”，当某个服务器故障时就请求其它服务器。</p>
<ul>
<li>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</li>
<li>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</li>
</ul>
<p>有了冗余之后还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务时间。所以，往往是通过“自动故障转移”来实现系统的高可用。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>扩展是最常见的提升系统可靠性的方法，系统的扩展可以避免单点故障。一个容易扩展的系统，能够通过扩展来成倍的提升系统能力，轻松应对系统访问量的提升。</p>
<h4 id="垂直扩展"><a href="#垂直扩展" class="headerlink" title="垂直扩展"></a>垂直扩展</h4><p>比如，当机器内存不够时，我们可以帮机器增加内存,垂直扩展能够提升系统处理能力，但不能解决单点故障问题。我</p>
<h4 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h4><p>通过增加一个或多个逻辑单元，并使得它们像整体一样的工作。水平扩展，通过冗余部署解决了单点故障，同时又提升了系统处理能力。</p>
<p>在实际应用中，水平扩展最常见：</p>
<ol>
<li>通常我们在部署应用服务器的时候，都会部署多台，然后使用 nginx 来做负载均衡，nginx 使用心跳机制来检测服务器的正常与否，无响应的服务就从集群中剔除。这样的集群中每台服务器的角色是相同的，同时提供一样的服务。</li>
<li>在数据库的部署中，为了防止单点故障，一般会使用一主多从，通常写操作只发生在主库。不同数据库之间角色不同。当主机宕机时，一台从库可以自动切换为主机提供服务。</li>
</ol>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>在软件工程中，对象之间的耦合度就是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此对象的设计应使模块之间的耦合度尽量小。在软件架构设计中，模块之间的解耦或者说松耦合有两种，</p>
<p><mark>1. 使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。</mark><br>新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。<br><mark>2. 将同步调用转换成异步消息交互。使用消息队列进行解耦，应用之间通过消息传递进行通信.</mark><br>如果我们将同步调用替换成异步消息，机票支付系统发送机票支付成功的消息到消息中间件，出票系统、代金券系统从消息中间件订阅消息。这样一来，出票系统、代金券系统的宕机也就不会对机票支付系统造成任何影响了。</p>
<p>异步消息解耦，适合那些信息流单向流动（类似发布-订阅这样的），实时性要求不高的系统。常见的开源消息队列框架有：Kafka、RabbitMQ、RocketMQ。</p>
<h3 id="请求幂等"><a href="#请求幂等" class="headerlink" title="请求幂等"></a>请求幂等</h3><p>幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用<br>用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。</p>
<p>一般保证幂等的判断是从数据库查询有没有相同id的记录，但是在分布式系统环境下，可能有主从问题：request1请求过来的时候，查询从库发现没有对应记录，则request1开始操作插入主库record1，但是还没有同步到从库；此时request2查询从库也发现没有相同id的记录，准备插入有相同id的记录record2，这个时候request1成功插入record1，request2开始插入record2,数据库报错.</p>
<p>解决这个问题有两种方法：1、读写都强制走主库；2、采用分布式锁，考虑性能问题，一般都选2</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式系统一般都有多台机器，常规的多线程锁已经无法解决问题；最简单用redis实现：思路很简单，主要用到的redis函数是setnx()。首先是将某一任务标识名UniqueKey（能唯一识别一个请求的标识）作为键存到redis里，并为其设个过期时间，如果是同样的请求过来，先是通过setnx()看看是否能将UniqueKey插入到redis里，可以的话就返回true，不可以就返回false。</p>
<p>分布式锁设计原则：</p>
<ol>
<li>互斥性，同一时间只有一个线程持有锁</li>
<li>容错性，即使某一个持有锁的线程，异常退出，其他线程仍可获得锁</li>
<li>隔离性，线程只能解自己的锁，不能解其他线程的锁</li>
</ol>
<h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><p>是对系统、业务所占有的资源进行隔离，避免一个业务占用整个系统资源，对其他业务造成影响,即发生故障后不会出现滚雪球效应，从而保证只有出问题的服务不可用，其他服务还是可用的。</p>
<ol>
<li><strong>线程池隔离：</strong> 不同的业务使用不同的线程池，避免低优先级的任务阻塞高优先级的任务。或者高优先级的任务过多，导致低优先级任务永远不会执行。</li>
<li><strong>进程隔离：</strong> Linux 中有用于进程资源隔离的 Linux CGroup，通过物理限制的方式为进程间资源控制提供了简单的实现方式，为 Linux Container 技术、虚拟化技术的发展奠定了技术基础。</li>
<li><strong>模块隔离、应用隔离：</strong> 很多线上故障的发生源于代码修改后，测试不到位导致。按照代码或业务的易变程度来划分模块或应用，把变化较少的划分到一个模块或应用中，变化较多的划分到另一个模块或应用中。减少代码修改影响的范围，也就减少了测试的工作量，减少了故障出现的概率。</li>
<li><strong>机房隔离：</strong> 主要是为了避免单个机房网络问题或断电。</li>
<li><strong>读写分离：</strong> 一方面，将对实时性要求不高的读操作，放到 DB 从库上执行，有利于减轻 DB 主库的压力。另一方面，将一些耗时离线业务 sql 放到 DB 从库上执行，能够减少慢 sql 对 DB 主库的影响，保证线上业务的稳定可靠。</li>
</ol>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>这种方式在服务端平均处理请求时间过长的业务场景下很好用，不需要关心最后的结果，用户请求完成之后就立即返回结果，具体处理可以后续再做。<br>除了可以在程序中实现异步之外，常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p>
<h3 id="可伸缩性（有-无状态的服务）"><a href="#可伸缩性（有-无状态的服务）" class="headerlink" title="可伸缩性（有&#x2F;无状态的服务）"></a>可伸缩性（有&#x2F;无状态的服务）</h3><p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p>
<ul>
<li><p>伸缩性与性能<br>如果系统存在性能问题，那么单个用户的请求总是很慢的；<br>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p>
</li>
<li><p>实现伸缩性<br>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。<br>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。<br>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p>
</li>
</ul>
<h3 id="一致性（补偿事务、重试）"><a href="#一致性（补偿事务、重试）" class="headerlink" title="一致性（补偿事务、重试）"></a>一致性（补偿事务、重试）</h3><p>强一致性（ACID）和高可用性（BASE）是对立，顾此失彼；因此，为了可用性，我们要讲业务中需要强一致性的动作和不需要强一致性的动作剥离开，对于非强一致性需求的动作，可以做补偿事务；我们应尽量设计更多非强一致性的业务</p>
<h3 id="模块级自动化测试"><a href="#模块级自动化测试" class="headerlink" title="模块级自动化测试"></a>模块级自动化测试</h3><p>解决上述问题可以使用模块级自动化测试。具体方案是：针对某一模块，收集模块线上的输入、输出、运行时环境等信息，在离线测试环境通过数据mock模块线上场景，回放收集的线上输入，相同的输入比较测试场景与线上收集的输出作为测试结果。<br>模块级自动化测试通过简化复杂系统中的不变因素（mock），将系统的测试边界收拢到改动模块，将复杂系统的整体测试转化为改动模块的单元测试。主要适用于系统业务回归，对系统内部重构场景尤其适用。</p>
<p>具体如何收集线上数据呢？有两种方法：</p>
<ol>
<li>AOP：面向切面编程，动态地织入代码，对原有代码的侵入性较小。</li>
<li>埋点：很多公司都开发了一下基础组件，可以在这些基础组件中嵌入数据收集的代码。</li>
</ol>
<h3 id="灰度发布-回滚"><a href="#灰度发布-回滚" class="headerlink" title="灰度发布 &amp; 回滚"></a>灰度发布 &amp; 回滚</h3><ul>
<li>发布之前必须制定详细的回滚步骤，回滚是解决发布引起的故障的最快的方法。</li>
<li>在线上出现故障后，第一个要考虑的就是刚刚有没有代码发布、配置发布，如果有的话就先回滚。</li>
<li>即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。</li>
<li>灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</li>
</ul>
<h3 id="超时和重试机制设置"><a href="#超时和重试机制设置" class="headerlink" title="超时和重试机制设置"></a>超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。<br>使用一些 RPC  框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。重试的次数一般设为3次，再多次的重试没有好处，反而会加重服务器压力</p>
<h3 id="应对大流量的能力（熔断、降级、限流）"><a href="#应对大流量的能力（熔断、降级、限流）" class="headerlink" title="应对大流量的能力（熔断、降级、限流）"></a>应对大流量的能力（熔断、降级、限流）</h3><h4 id="熔断（慎用）"><a href="#熔断（慎用）" class="headerlink" title="熔断（慎用）"></a>熔断（慎用）</h4><p>如果系统中，某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用；熔断主要是应对流量引起的问题，使服务处于关闭、半关闭状态，以保证部分业务成功，或者舍弃次要业务使主业务运行通畅；</p>
<p>在熔断器中有三种状态：<br>关闭：让请求通过的默认状态。如果请求成功&#x2F;失败但低于阈值，则状态保持不变。<br>打开：当熔断器打开的时候，所有的请求都会被标记为失败；这是故障快速失败机制，而不需要等待超时时间完成。<br>半开：定期的尝试发起请求来确认系统是否恢复。如果恢复了，熔断器将转为关闭状态或者保持打开</p>
<p>下面这张图，就是熔断器的基本原理，包含三个状态：</p>
<ol>
<li>服务正常运行时的 Closed 状态，当服务调用失败量达到阈值时，熔断器进入 Open 状态</li>
<li>在 Open 状态，服务调用不会真正去请求外部资源，会快速失败。</li>
<li>当进入 Open 状态一段时间后，进入 Half-Open状态，需要去尝试调用几次服务，检查故障的服务是否恢复。如果成功则熔断器关闭，如果失败，则再次进入 Open 状态。</li>
</ol>
<p><img data-src="/mybook.github.io/images/712816119290.png"></p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>熔断的一种，半开状态，只允许少部分的请求，其他的都拒绝，如果设计得当，被拒绝的请求，客户端会通过重试、补偿操作来完成；</p>
<p>限流策略：</p>
<ol>
<li>计数器算法：<br>设置一个计数器统计单位时间内某个请求的访问量，在进入下一个单位时间内把计数器清零，对于单位时间内超过计数器的访问，可以放入等待队列、直接拒接访问等策略</li>
<li>漏斗算法：<br>一个固定容量的漏桶，按照常量固定速率流出水滴；可以以任意速率流入水滴到漏桶；如果流入水滴超出了桶的容量，则流入的水滴溢出了，而漏桶容量是不变的。</li>
<li>令牌桶算法：<br>令牌将按照固定的速率被放入令牌桶中。比如每秒放10个。每次请求调用需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择等待可用的令牌、或者直接拒绝。当令牌桶满时，新添加的令牌被丢弃或拒绝</li>
<li>滑动窗口计数法<br>计数法是限流算法里最容易理解的一种，该方法统计最近一段时间的请求量，如果超过一定的阈值，就开始限流。在 TCP 网络协议中，也用到了滑动窗口来限制数据传输速率。<br>滑动窗口计数有两个关键的因素：窗口时长、滚动时间间隔。滚动时间间隔一般等于上图中的一个桶 bucket，窗口时长除以滚动时间间隔，就是一个窗口所包含的 bucket 数目。</li>
<li>动态限流<br>一般情况下的限流，都需要我们手动设定限流阈值，不仅繁琐，而且容易因系统的发布升级而过时。为此，我们考虑根据系统负载来动态决定是否限流，动态计算限流阈值。可以参考的系统负载参数有：Load、CPU、接口响应时间等。</li>
</ol>
<p>漏桶算法与令牌桶算法的区别在于:<br><strong>漏桶算法能够强行限制数据的传输速率，令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输</strong>。需要注意的是，在某些情况下，漏桶算法不能够有效地使用网络资源，因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。</p>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><ul>
<li><p>业务降级，是指牺牲非核心的业务功能，保证核心功能的稳定运行。</p>
</li>
<li><p>要实现优雅的业务降级，需要将功能实现拆分到相对独立的不同代码单元，分优先级进行隔离。在后台通过开关控制，降级部分非主流程的业务功能，减轻系统依赖和性能损耗，从而提升集群的整体吞吐率。</p>
</li>
<li><p>业务降级通常需要通过开关工作，开关一般做成配置放在专门的配置系统，配置的修改最好能够实时生效。开源的配置系统有阿里的diamond、携程的Apollo、百度的disconf。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="center">技术</th>
<th align="center">解决问题</th>
</tr>
</thead>
<tbody><tr>
<td align="center">扩展</td>
<td align="center">通过冗余部署，避免单点故障</td>
</tr>
<tr>
<td align="center">隔离</td>
<td align="center">避免业务之间的相互影响，机房隔离避免单点故障</td>
</tr>
<tr>
<td align="center">解耦</td>
<td align="center">减少依赖，减少相互间的影响</td>
</tr>
<tr>
<td align="center">限流</td>
<td align="center">遇到突发流量时，保证系统稳定</td>
</tr>
<tr>
<td align="center">降级</td>
<td align="center">牺牲非核心业务，保证核心业务的高可用</td>
</tr>
<tr>
<td align="center">熔断</td>
<td align="center">减少不稳定的外部依赖对核心服务的影响</td>
</tr>
<tr>
<td align="center">自动化测试</td>
<td align="center">通过完善的测试，减少发布引起的故障</td>
</tr>
<tr>
<td align="center">灰度发布</td>
<td align="center">灰度发布是速度与安全性作为妥协，能够有效减少发布故障</td>
</tr>
</tbody></table>
<h2 id="分层高可用架构实践"><a href="#分层高可用架构实践" class="headerlink" title="分层高可用架构实践"></a>分层高可用架构实践</h2><h3 id="常见的互联网分层架构"><a href="#常见的互联网分层架构" class="headerlink" title="常见的互联网分层架构"></a>常见的互联网分层架构</h3><p><img data-src="/mybook.github.io/images/3557521175650.png"></p>
<p>常见互联网分布式架构如上，分为：</p>
<p>（1）客户端层：典型调用方是浏览器browser或者手机应用APP</p>
<p>（2）反向代理层：系统入口，反向代理</p>
<p>（3）站点应用层：实现核心应用逻辑，返回html或者json</p>
<p>（4）服务层：如果实现了服务化，就有这一层</p>
<p>（5）数据-缓存层：缓存加速访问存储</p>
<p>（6）数据-数据库层：数据库固化数据存储</p>
<p>整个系统的高可用，又是通过每一层的冗余+自动故障转移来综合实现的。</p>
<h3 id="【客户端层-反向代理层】的高可用"><a href="#【客户端层-反向代理层】的高可用" class="headerlink" title="【客户端层-&gt;反向代理层】的高可用"></a>【客户端层-&gt;反向代理层】的高可用</h3><p><img data-src="/mybook.github.io/images/5586822176259.png"></p>
<p>【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p>
<p><img data-src="/mybook.github.io/images/3570223203214.png"></p>
<p>自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p>
<h3 id="【反向代理层-站点层】的高可用"><a href="#【反向代理层-站点层】的高可用" class="headerlink" title="【反向代理层-&gt;站点层】的高可用"></a>【反向代理层-&gt;站点层】的高可用</h3><p><img data-src="/mybook.github.io/images/414224185427.png"></p>
<p>【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。</p>
<p><img data-src="/mybook.github.io/images/4036524174725.png"></p>
<p>自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。</p>
<h3 id="【站点层-服务层】的高可用"><a href="#【站点层-服务层】的高可用" class="headerlink" title="【站点层-&gt;服务层】的高可用"></a>【站点层-&gt;服务层】的高可用</h3><p><img data-src="/mybook.github.io/images/1439825170976.png"></p>
<p>【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。</p>
<p><img data-src="/mybook.github.io/images/3445325171115.png"></p>
<p>自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。</p>
<h3 id="【服务层-缓存层】的高可用"><a href="#【服务层-缓存层】的高可用" class="headerlink" title="【服务层&gt;缓存层】的高可用"></a>【服务层&gt;缓存层】的高可用</h3><p><img data-src="/mybook.github.io/images/279926183205.png"></p>
<p>【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。<br>缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。</p>
<p><img data-src="/mybook.github.io/images/2601226188244.png"></p>
<p>缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。<br>以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。</p>
<p><img data-src="/mybook.github.io/images/994127189539.png"></p>
<p>自动故障转移：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。</p>
<p>说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。</p>
<p>这类允许“cache miss”的业务场景，缓存架构的建议是：</p>
<p><img data-src="/mybook.github.io/images/3868627190541.png"></p>
<p>将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。</p>
<p><img data-src="/mybook.github.io/images/5835127190718.png"></p>
<p>缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。</p>
<h3 id="【服务层-数据库层】的高可用"><a href="#【服务层-数据库层】的高可用" class="headerlink" title="【服务层&gt;数据库层】的高可用"></a>【服务层&gt;数据库层】的高可用</h3><p>大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。</p>
<h4 id="【服务层-数据库层“读”】的高可用"><a href="#【服务层-数据库层“读”】的高可用" class="headerlink" title="【服务层&gt;数据库层“读”】的高可用"></a>【服务层&gt;数据库层“读”】的高可用</h4><p><img data-src="/mybook.github.io/images/4102128176270.png"></p>
<p>【服务层】到【数据库读】的高可用，是通过读库的冗余来实现的。<br>既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。</p>
<p><img data-src="/mybook.github.io/images/1059729192549.png"></p>
<p>自动故障转移：当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。</p>
<h4 id="【服务层-数据库层“写”】的高可用"><a href="#【服务层-数据库层“写”】的高可用" class="headerlink" title="【服务层&gt;数据库层“写”】的高可用"></a>【服务层&gt;数据库层“写”】的高可用</h4><p><img data-src="/mybook.github.io/images/4051929185594.png"></p>
<p>【服务层】到【数据库写】的高可用，是通过写库的冗余来实现的。<br>以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。</p>
<p><img data-src="/mybook.github.io/images/1152330182361.png"></p>
<p>自动故障转移：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。<br>方法论上，高可用是通过冗余+自动故障转移来实现的。<br>整个互联网分层系统架构的高可用，又是通过每一层的冗余+自动故障转移来综合实现的，具体的：</p>
<ol>
<li><p>【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p>
</li>
<li><p>【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移</p>
</li>
<li><p>【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移</p>
</li>
<li><p>【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性</p>
</li>
<li><p>【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移</p>
</li>
<li><p>【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移</p>
</li>
</ol>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>总结一下高可用的设计原理：</p>
<ol>
<li>要做到数据不丢，就必需要持久化</li>
<li>要做到服务高可用，就必需要有备用（复本），无论是应用结点还是数据结点</li>
<li>要做到复制，就会有数据一致性的问题。</li>
</ol>
<h4 id="如何实现高可用"><a href="#如何实现高可用" class="headerlink" title="如何实现高可用"></a>如何实现高可用</h4><h5 id="入口层"><a href="#入口层" class="headerlink" title="入口层"></a>入口层</h5><p>入口层，通常指Nginx和Apache等层面的东西，负责应用（不管是Web应用还是移动应用）的服务入口。我们通常会将服务定位在一个IP，如果这个IP对应的服务器当机了，那么用户的访问肯定会中断。此时，可以用keepalived来实现入口层的高可用。例如，机器A 的IP是 1.2.3.4，机器 B 的 IP 是 1.2.3.5, 那么再申请一个 IP 1.2.3.6（称为⼼跳IP）, 平时绑定在机器A上,如果A当机，IP会自动绑定在机器B上；如果B当机，IP会自动绑定在机器A上。对于这种形式，我们将DNS绑定到心跳IP上，即可实现入口层的高可用。</p>
<p>这里要注意，keepalived在使用上会有一些限制。但这个方案有一点小问题。<br>第一，它的切换可能会有一到两秒的中断，也就是说，如果不是要求到非常严格的毫秒级就不会有问题。<br>第二，对入口的机器会有些浪费，因为买了两台机器的入口，可能就只有一台机器用上。对一些长连接的应用可能会导致服务中断，这时候就需要客户端做配合做一些重新创建连接的工作。简单来说，对于比较普通的业务来说，这个方案就能解决一部分问题。</p>
<p>两台机器必须在同一个网段，不是在同一个网段，没有办法实现互相抢IP。<br>内网服务也可以做心跳，但需要注意的是，以前为了安全我们会把内网服务绑定在内网IP上，避免出现安全问题。但为了使用keepalived，必须监听在所有IP上（如果监听在心跳IP上，那么机器没有持有该IP时，服务无法启动），简单的方案是启用 iptables, 避免内网服务被外网访问。<br>服务器利用率下降，这时可以考虑做混合部署来改善这一点。<br>比较常见的一个错误是，如果有两台机器，两个公网IP，DNS上把域名同时定位到两个IP，就觉得已经做了高可用了。这完全不是高可用，因为如果一台机器当机,那么就有一半左右的用户无法访问。</p>
<p>除了keepalive，lvs也能用来解决入口层的高可用问题。不过，与keepalived相比，lvs会更复杂一些，门槛也会高一些。</p>
<h5 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h5><p>业务层通常是由PHP、Java、Python、Go等写的逻辑代码构成的，需要依赖于后台数据库及一些缓存层面的东西。如何实现业务层的高可用呢？最核心的就是，业务层不要有状态,将状态分散到缓存层和数据库。目前大家通常喜欢将以下几种数据放入业务层。</p>
<p>第一个是session，即用户登录相关的数据，但好的做法是将session放在数据库里，或者一个比较稳定的缓存系统中。</p>
<p>第二个是缓存，在访问数据库时，如果一个查询很慢，就希望将这些结果暂时放到进程里，下次再做查询时就不用再访问数据库了。这种做法带来的问题是，当业务层服务器不只一台时，数据很难做到一致，从缓存拿到的数据就可能是错误的。。</p>
<p>一个简单的原则就是业务层不要有状态。在业务层没有状态时，一台业务层服务器当掉了之后，Nginx&#x2F;Apache会自动将所有的请求打到另外一台业务层的服务器上。由于没有状态，两台服务器没有任何差异，所以用户完全感受不到。如果把session放在业务层里面的话，那么面临的问题是，这个用户以前是登录在一台机器上的，这个进程死掉后，用户就会被登出了。</p>
<p>友情提醒：有一段时间比较流行cookie session，就是将session中的数据加密之后放在客户的cookie里，然后下发到客户端，这样也能做到与服务端完全无状态。但这里面有很多坑，如果能绕过这些坑就可以这样使用。第一个坑是怎么保证加密的密钥不泄露，一旦泄露就意味着攻击者可以伪造任何人的身份。第二个坑是重放攻击，如何避免别人通过保存 cookie 去不停地尝试的验证码，当然也还有其他一些攻击手段。如果没有好办法解决这两方面的问题，那么cookie session尽量慎用。最好是将session放在一个性能比较好的数据库中。如果数据库性能不行，那么将session放在缓存中也比放在cookie里要好一点。</p>
<h5 id="缓存层"><a href="#缓存层" class="headerlink" title="缓存层"></a>缓存层</h5><p>非常简单的架构里是没有缓存这个概念的。但在访问量上来之后，MySQL之类的数据库扛不住了，比如在SATA盘里跑MySQL，QPS到达200、300甚至500时，MySQL的性能会大幅下降，这时就可以考虑用缓存层来挡住绝大部分服务请求，提升系统整体的容量。</p>
<p>缓存层做高可用一个简单的方法就是，将缓存层分得细一点儿。比如说，缓存层就一台机器的话，那么这台机器当了以后，所有应用层的压力就会往数据库里压，数据库扛不住的话，整个网站（或应用）就会随之当掉。而如果缓存层分在四台机器上的话，每台只有四分之一，这台机器当掉了以后，也只有总访问量的四分之一会压在数据库上面，数据库能扛住的话，网站就能很稳定地等到缓存层重新起来。在实践中，四分之一显然是不够的，我们会将它分得更细，以保证单台缓存当机后数据库还能撑得住即可。在中小规模下，缓存层和业务层可以混合部署,这样可以节省机器。</p>
<h5 id="数据库层"><a href="#数据库层" class="headerlink" title="数据库层"></a>数据库层</h5><p>在数据库层面实现高可用，通常是在软件层面来做。例如，MySQL有主从模式(Master-Slave)，还有主主模式(Master-Master)都能满足需求。MongoDB也有ReplicaSet的概念,基本都能满足大家的需求。</p>
<p>总之，要想实现高可用，需要做到这几点：入口层做心跳，业务层服务器无状态，缓存层减小粒度，数据库做一个主从模式。对于这种模式来讲，我们做的高可用不需要太多服务器，这些东西都可以同时部署在两台服务器上。这时，两台服务器就能满足早期的高可用需求了。任何一台服务器当机用户完全无感知。</p>
<h4 id="如何实现可伸缩"><a href="#如何实现可伸缩" class="headerlink" title="如何实现可伸缩"></a>如何实现可伸缩</h4><h5 id="入口层-1"><a href="#入口层-1" class="headerlink" title="入口层"></a>入口层</h5><p>在入口层实现伸缩性，可以通过直接水平扩机器，然后DNS加IP来实现。但需要注意，尽管一个域名解析到几十个IP没有问题,但是很多浏览器客户端只会使用前几个IP,部分域名供应商对此有优化(如每次返回的IP顺序随机),但这个优化效果不稳定。</p>
<p>推荐的做法是使用少量的Nginx机器作为入口,业务服务器隐藏在内网(HTTP类型的业务这种方式居多)。另外,也可以把所有IP下发到客户端，然后在客户端做一些调度(特别是非HTTP型的业务,如游戏、直播)。</p>
<h5 id="业务层-1"><a href="#业务层-1" class="headerlink" title="业务层"></a>业务层</h5><p>业务层的伸缩性如何实现?与做高可用时的解决方案一样,要实现业务层的伸缩性，保证无状态是很好的手段。此外，加机器继续水平部署即可。</p>
<h5 id="缓存层-1"><a href="#缓存层-1" class="headerlink" title="缓存层"></a>缓存层</h5><p>比较麻烦的是缓存层的伸缩性，最简单粗暴的方式是什么呢？趁着半夜量比较低的时候，把整个缓存层全部下线，然后上线新的缓存层。新的缓存层启动起来之后，再等这些缓存慢慢预热。当然这里一个要求，你的数据库能抗住低估期的请求量。如果扛不住呢？取决于缓存类型，下面我们先可以将缓存的类型区分一下。</p>
<p>强一致性缓存：无法接受从缓存拿到错误的数据 (比如用户余额，或者会被下游继续缓存这种情形)<br>弱一致性缓存：能接受在一段时间内从缓存拿到错误的数据 (比如微博的转发数)。<br>不变型缓存：缓存key对应的value不会变更 (比如从SHA1推出来的密码, 或者其他复杂公式的计算结果)。<br>那什么缓存类型伸缩性比较好呢？弱一致性和不变型缓存的扩容很方便,用一致性Hash即可；强一致性情况稍微复杂一些，稍后再讲。使用一致性Hash，而不用简单Hash的原因是缓存的失效率。如果缓存从9台扩容到10台,简单Hash 情况下90%的缓存会马上失效,而如果使用一致性Hash情况,只有10%的缓存会失效。</p>
<p>那么，强一致性缓存会有什么问题？第一个问题是，缓存客户端的配置更新时间会有微小的差异,在这个时间窗内有可能会拿到过期的数据。第二个问题是，如果扩容之后再裁撤节点,会拿到脏数据。比如 a 这个key之前在机器1，扩容后在机器2，数据更新了，但裁撤节点后key回到机器1，这时候就会拿到脏数据。</p>
<p>要解决问题2比较简单，要么保持永不减少节点,要么节点调整间隔大于数据的有效时间。问题1可以用如下的步骤来解决：</p>
<p>两套hash配置都更新到客户端，但仍然使用旧配置；<br>逐个客户端改为只有两套hash结果一致的情况下会使用缓存，其余情况从数据库读，但写入缓存；<br>逐个客户端通知使用新配置。<br>Memcache 设计得比较早，导致在伸缩性高可用方面的考虑得不太周到。Redis 在这方面有不少改进，特别是 @ngaut 团队基于 redis 开发了 codis 这个软件，一次性地解决了缓存层的绝大部分问题。推荐大家考察一下。</p>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><p>在数据库层面实现伸缩，方法很多，文档也很多，此处不做过多赘述。大致方法为：水平拆分、垂直拆分和定期滚动。</p>
<p>总之，我们可以在入口层、业务层面、缓存层和数据库层四个层面，使用刚才介绍的方法和技术实现系统高可用和可伸缩性。具体为：在入口层用心跳来做到高可用，用平行部署来伸缩；在业务层做到服务无状态；在缓存层，可以减小一些粒度，以方便实现高可用，使用一致性Hash将有助于实现缓存层的伸缩性；数据库层的主从模式能解决高可用问题，拆分和滚动能解决可伸缩问题。</p>
<h1 id="容灾设计"><a href="#容灾设计" class="headerlink" title="容灾设计"></a>容灾设计</h1><h2 id="一：逻辑层容灾"><a href="#一：逻辑层容灾" class="headerlink" title="一：逻辑层容灾"></a>一：逻辑层容灾</h2><p>逻辑层服务一般都设计从无状态服务，客户端当前请求和下次请求在逻辑层没有任何的关联，因此客户端可以在在多次请求中分别到不同的机器上，而返回的结果和一直在同一台机器上一样。由于这种特性的存在使得逻辑层可以通过多级备份来实现容灾。<br><strong>备份可以有 ：主备(1+1), 一主多备（1+n），多主一备（n+1）， 无备（1+0），互相备份（n）</strong></p>
<p>切换的策略可以为：</p>
<ol>
<li>冷切：即主完全承担所有业务，当主不可服务时再启用备，该方式由于备机一直处于不服务状态，会出现当要切换到备的时候，备也不可服务，可信度低。</li>
<li>热切：主和备一起分担所有请求，主备只承担部分业务请求（总和为100%）。这样可以解决之前的冷切遇到的信任度低的问题。同时业务由主备共同分担，节约成本。但是在主完全不可服务时，备有过载的风险。这里可以没有主备之分，在我们的实践中常用多台机器组成的集群来实现互为备份。</li>
<li>双在线：主备各跑100%的任务。这个可以同时解决上面的遇到的问题。但是成本高（带宽、电力、机房维护成本等）</li>
</ol>
<h2 id="二：数据层容灾"><a href="#二：数据层容灾" class="headerlink" title="二：数据层容灾"></a>二：数据层容灾</h2><p>相对于逻辑层是无状态的服务，数据层服务需要存储和用户相关的数据，用户的多次请求之间的数据是有关联的。因此如何在多机容灾备份的情况下保证数据一致性成为一个关键问题。</p>
<h3 id="数据一致性的问题："><a href="#数据一致性的问题：" class="headerlink" title="数据一致性的问题："></a>数据一致性的问题：</h3><p>中心化备份策略：<br>在传统的数据库、数据服务器设计中往往采用中心化的的模型。每台机器中存储全量的数据，其中有只有一台可写的主机，有一台或多台机器可读的备机去同步主机的数据。当主机不可服务时，其中一台备机升级为主机。</p>
<p>数据增量同步：只对有更新的数据进行同步， 当主机有数据更新时， 会先在本地生成Binlog及同步相关的信息，主机与备机之间通过一定的协议将数据同步到备机。<br>数据全量同步： 每次都全量同步主机的数据。一般会一段时间内做一次，是增量同步的一个补充。可以一块一数据计算MD5值进行比较，只同步MD5值不相等的数 据快。</p>
<p>问题：只有一台可写容易出现单点问题（虽然可以切换，但是还是会在一定时间内不可服务）、由于网络问题可能出现多主。</p>
<p>去中心化备份策略：<br>相对于中心化只有一个主可写，其他备机都只是同步主机的数据，去中心化没有主备之分， 所有的机器都可读可写，这样写的性能会有很大的提高，但是要做到数据的一致性比较复杂。目前主要的设计方案有： RNW协议、2pc、3pc协议、paxos协议等。</p>
<h2 id="三：容灾判定"><a href="#三：容灾判定" class="headerlink" title="三：容灾判定"></a>三：容灾判定</h2><ul>
<li><p>中心主动探测：该方法是中心主动和其他子系统或服务定时发送消息（可用私有协议或ping消息等），根据回包来判定服务是否可用。</p>
</li>
<li><p>等待服务上报：该方法是子系统或者服务，又或者是专门agent主动的将服务的运行状态上报给中心系统，中心系统通过上报消息来判定服务是否运行正常。</p>
</li>
<li><p>请求者判定：即服务的使用方将根据请求的服务状态（延迟、是否成功等信息）来判定服务是否正常，请求者在本地记录这些信息，只将请求发送到那些正常的服务。这种方式相对于中央判定可以防止中心和其他子服务之间由于网络问题而导致误判。</p>
</li>
</ul>
<h2 id="四：异地部署"><a href="#四：异地部署" class="headerlink" title="四：异地部署"></a>四：异地部署</h2><p>某些重要的服务为了在局部的网络不可用、自然灾害等问题时也能保证服务的可用性，需要将服务部署在不同的城市、机房。这样一方面可以保证服务的可靠性，也可以让不同地区的用户就近访，提高服务质量。</p>
<h2 id="五、负载均衡"><a href="#五、负载均衡" class="headerlink" title="五、负载均衡"></a>五、负载均衡</h2><ul>
<li><p>接入负载：通过代理服务将服务分发到不同的机器上，这个可以通过单独部署负载均衡服务器、LVS、DNS、http重定向、nginx方向代理、NAT等实现。</p>
</li>
<li><p>号段负载：通过请求自身的特殊性将不同的请求分发到固定的服务上进行处理。如通过一致性hash将hash值相关的请求路由到固定的服务，也可以将固定号段的qq号路由到固定的服务。如何分配不够离散化，可能会导致某些热点请求都集中在同一台服务，从而导致负载不均衡。</p>
</li>
<li><p>用户自助负载：这种类似于游戏服务器中用户选择不同的服来分配不同的机器，达到将不同的请求分配到不同的机器的目的。</p>
</li>
</ul>
<h2 id="六：过载保护"><a href="#六：过载保护" class="headerlink" title="六：过载保护"></a>六：过载保护</h2><p>当负载达到系统处理能力的上限时，系统的处理能力将随着负载的增加急剧下降，俗称滚雪球。在系统设计的时候做好过载保护是一项很重要的工作。过载保护的方法有:</p>
<ol>
<li><p>轻重分离、隔离部署：将系统、业务、功能隔离部署（可以分不同的set），确保系统过载状态不会扩散到其他业务系统，对其他业务系统造成影响，使得影响最小化。</p>
</li>
<li><p>频率控制：控制单位时间内的请求量（可以是总的请求量也可以是单个用户的请求量），这样可以保证系统在过载的时候不会被压垮，保证部分用户的请求可以被处理。</p>
</li>
<li><p>设置请求的有效时间： 用户的请求都期望在一定时间范围内返回结果。如果没有返回则会当做超时出错处理。如果服务端一直在处理这样的请求，那么其实是在无用功，对用户没有如何意义。因此我们需要对每个请求做超时限制，在一定的时间内没有处理完则丢弃该请求，理想的状态是从收到请求开始计时，这样可以防止数据包在队列中已经超时。</p>
</li>
<li><p>有损服务：服务做好有损处理，当系统过载时，可以将某些非关键性的服务下掉，从而保证关键业务可以正常服务。如果是底层非关键性的服务过载，则可以不去请求该服务的数据而直接反回给前端。同时前端也可以做相应的有损策略，防止后台服务过载时给用户不好的体验。</p>
</li>
</ol>
<h2 id="七：常见的互联网事故及解决策略"><a href="#七：常见的互联网事故及解决策略" class="headerlink" title="七：常见的互联网事故及解决策略"></a>七：常见的互联网事故及解决策略</h2><table>
<thead>
<tr>
<th align="center">事故</th>
<th align="center">解决策略</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务器硬件故障死机：</td>
<td align="center">集群部署、多机备份、自动检测并切换</td>
</tr>
<tr>
<td align="center">网络丢包、光钎断：</td>
<td align="center">异地部署、自动检测故障并切换</td>
</tr>
<tr>
<td align="center">服务器雪崩：</td>
<td align="center">负载均衡、过载保护、容量告警</td>
</tr>
<tr>
<td align="center">外部依赖故障：</td>
<td align="center">柔性逻辑、降级服务、限制重试</td>
</tr>
<tr>
<td align="center">DNS故障 ：</td>
<td align="center">自搭建类DNS服务、使用IP列表替代DNS</td>
</tr>
<tr>
<td align="center">程序CORE：</td>
<td align="center">自动拉起、实时告警</td>
</tr>
<tr>
<td align="center">操作失望：</td>
<td align="center">灰度、保护逻辑、人员备份确认</td>
</tr>
</tbody></table>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡，意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。</p>
<p><img data-src="/mybook.github.io/images/3061934156547.png"></p>
<p>应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。<br>负载均衡设备：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</p>
<p>负载均衡的作用（解决的问题）：</p>
<ol>
<li>解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；</li>
<li>提供故障转移，实现高可用；</li>
<li>通过添加或减少服务器数量，提供网站伸缩性（扩展性）；</li>
<li>安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）</li>
</ol>
<h2 id="负载均衡实现"><a href="#负载均衡实现" class="headerlink" title="负载均衡实现"></a>负载均衡实现</h2><h3 id="http重定向协议实现负载均衡"><a href="#http重定向协议实现负载均衡" class="headerlink" title="http重定向协议实现负载均衡"></a>http重定向协议实现负载均衡</h3><p>原理：根据用户的http请求计算出一个真实的web服务器地址，并将该web服务器地址写入http重定向响应中返回给浏览器，由浏览器重新进行访问。</p>
<p><img data-src="/mybook.github.io/images/272621174104.png"></p>
<p>优点：比较简单<br>缺点：<br>浏览器需要零次请求服务器才能完成一次访问，性能较差。<br>http重定向服务器自身的处理能力可能成为瓶颈。<br>使用http302响应重定向，有可能使搜索引擎判断为SEO作弊，降低搜索排名。</p>
<h3 id="【协议层】DNS负载均衡"><a href="#【协议层】DNS负载均衡" class="headerlink" title="【协议层】DNS负载均衡"></a>【协议层】DNS负载均衡</h3><p>原理：在DNS服务器上配置多个域名对应IP的记录。例如一个域名<a href="http://www.baidu.com对应一组web服务器ip地址,域名解析时经过dns服务器的算法将一个域名请求分配到合适的真实服务器上./">www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。</a></p>
<p><img data-src="/mybook.github.io/images/5181921160784.png"></p>
<p>优点：<br>使用简单：负载均衡工作，交给DNS服务器处理，省掉了负载均衡服务器维护的麻烦<br>提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能；<br>缺点：<br>可用性差：DNS解析是多级解析，新增&#x2F;修改DNS后，解析时间较长；解析过程中，用户访问网站将失败；http重定向服务器自身的处理能力可能成为瓶颈。<br>扩展性低：DNS负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</p>
<p>将DNS作为第一级负载均衡，A记录对应着内部负载均衡的IP地址，通过内部负载均衡将请求分发到真实的Web服务器上。一般用于互联网公司，复杂的业务系统不合适使用。</p>
<p><img data-src="/mybook.github.io/images/4278339152301.png"></p>
<h3 id="【网络层】IP负载均衡"><a href="#【网络层】IP负载均衡" class="headerlink" title="【网络层】IP负载均衡"></a>【网络层】IP负载均衡</h3><p>在网络层通过修改请求目标地址进行负载均衡。<br>用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然后将请求目的地址修改为，获得的真实ip地址，不需要经过用户进程处理。<br>真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器，再将数据包源地址修改为自身的ip地址，发送给用户浏览器。如下图：</p>
<p><img data-src="/mybook.github.io/images/4541627153818.png"></p>
<p>IP负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式：</p>
<ol>
<li>负载均衡服务器在修改目的的IP地址的同时修改源地址，将数据源地址设为自身IP，即源地址转换(SNAT),这样Web服务器的响应会再回到负载均衡服务器。</li>
<li>将负载均衡服务器同时作为物理服务器集群的网关服务器，这样所有响应数据都会到达负载均衡服务器。</li>
</ol>
<p>优点：在内核进程完成数据分发，比在应用层分发性能更好；<br>缺点：所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽；</p>
<h3 id="【协议层】反向代理负载均衡"><a href="#【协议层】反向代理负载均衡" class="headerlink" title="【协议层】反向代理负载均衡"></a>【协议层】反向代理负载均衡</h3><p>原理：在部署位置上，<mark>反向代理服务器处于Web服务器前面</mark>（这样才可能缓存Web响应，加速访问），反向代理服务器同时提供负载均衡的功能，管理一组Web服务器，将请求根据负载均衡算法转发到不同的Web服务器上。Web服务器处理完成的响应也需要通过反向代理服务器返回给用户。由于Web服务器不直接对外提供访问，因此Web服务器不需要使用外部 IP地址，而反向代理服务器则需要配置双网卡和内部外部两套IP地址。</p>
<p><img data-src="/mybook.github.io/images/5875522151314.png"></p>
<p>例如：浏览器访问请求的地址是反向代理服务器的地址114.100.80.10，反向代理服务器收到请求后，根据负载均衡算法计算得到一台真实物理服务器的地址10.0.0.3，并将请求转发给服务器。10.0.0.3处理完请求后将响应返回给反向代理服务器，反向代理服务器再将该响应返回给用户。<br>优点：部署简单，处于http协议层面。<br>缺点：使用了反向代理服务器后，web 服务器地址不能直接暴露在外，因此web服务器不需要使用外部IP地址，而反向代理服务作为沟通桥梁就需要配置双网卡、外部内部两套IP地址。</p>
<h3 id="【链路层】链路层负载均衡"><a href="#【链路层】链路层负载均衡" class="headerlink" title="【链路层】链路层负载均衡"></a>【链路层】链路层负载均衡</h3><p>在通信协议的数据链路层修改mac地址，进行负载均衡。</p>
<p><img data-src="/mybook.github.io/images/3177729162765.png"></p>
<p>数据分发时，不修改ip地址，指修改目标mac地址，配置真实物理服务器集群所有机器虚拟ip和负载均衡服务器ip地址一致，达到不修改数据包的源地址和目标地址，进行数据分发的目的。<br>实际处理服务器ip和数据请求目的ip一致，不需要经过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。也称为直接路由模式（DR模式），DR模式是目前使用最广泛的一种负载均衡方式。<br>优点：性能好；<br>缺点：配置复杂；</p>
<h3 id="基于NAT的负载均衡技术（如Linux-VirtualServer，简称LVS）"><a href="#基于NAT的负载均衡技术（如Linux-VirtualServer，简称LVS）" class="headerlink" title="基于NAT的负载均衡技术（如Linux VirtualServer，简称LVS）"></a>基于NAT的负载均衡技术（如Linux VirtualServer，简称LVS）</h3><p>该技术通过一个地址转换网关<mark>将每个外部连接均匀转换为不同的内部服务器地址</mark>，因此外部网络中的计算机就各自与自己转换得到的地址上的服务器进行通信，从而达到负载均衡的目的。其中网络地址转换网关位于外部地址和内部地址之间，不仅可以实现当外部客户机访问转换网关的某一外部地址时可以转发到某一映射的内部的地址上，还可使内部地址的计算机能访问外部网络。 </p>
<h3 id="混合型负载均衡"><a href="#混合型负载均衡" class="headerlink" title="混合型负载均衡"></a>混合型负载均衡</h3><p>由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。</p>
<p>此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。</p>
<ol>
<li>适合有动静分离的场景<br>反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。</li>
</ol>
<p><img data-src="/mybook.github.io/images/4836047165287.png"></p>
<ol start="2">
<li>适合动态请求场景：</li>
</ol>
<p><img data-src="/mybook.github.io/images/5791948146528.png"></p>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>将所有请求，依次分发到每台服务器上，适合服务器硬件同相同的场景。<br>优点：服务器请求数目相同；<br>缺点：服务器压力不一样，不适合服务器配置不同的情况；</p>
<h3 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h3><p>请求随机分配到各个服务器。<br>优点：使用简单；<br>缺点：不适合机器配置不同的场景；</p>
<h3 id="最少链接"><a href="#最少链接" class="headerlink" title="最少链接"></a>最少链接</h3><p>将请求分配到连接数最少的服务器（目前处理请求最少的服务器）。<br>优点：根据服务器当前的请求处理情况，动态分配；<br>缺点：算法实现相对复杂，需要监控服务器请求连接数；</p>
<h3 id="Hash（源地址散列）"><a href="#Hash（源地址散列）" class="headerlink" title="Hash（源地址散列）"></a>Hash（源地址散列）</h3><p>根据IP地址进行Hash计算，得到IP地址。<br>优点：将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。<br>缺点：目标服务器宕机后，会话会丢失；</p>
<h3 id="加权"><a href="#加权" class="headerlink" title="加权"></a>加权</h3><p>在轮询，随机，最少链接，Hash等算法的基础上，通过加权的方式，进行负载服务器分配。<br>优点：根据权重，调节转发服务器的请求数目；<br>缺点：使用相对复杂；</p>
<h1 id="消息队列的应用"><a href="#消息队列的应用" class="headerlink" title="消息队列的应用"></a>消息队列的应用</h1><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><ol>
<li>点对点<br>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</li>
<li>发布&#x2F;订阅<br>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</li>
<li>发布与订阅模式和观察者模式有以下不同：<br>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。<br>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li>
</ol>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p>
<h3 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h3><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。<br>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p>
<p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p>
<h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。<br>日志采集客户端，负责日志数据采集，定时写入Kafka队列；Kafka消息队列，负责日志数据的接收，存储和转发；日志处理应用：订阅并消费kafka队列中的日志数据。</p>
<h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><p>消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等</p>
<center><font size="32">------赞助耶耶，加快更新！------</font></center>

<p><img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/mybook.github.io/2024/05/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式-以C-为例"><a href="#设计模式-以C-为例" class="headerlink" title="设计模式(以C++为例)"></a>设计模式(以C++为例)</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式：简单工厂模式、工厂方法模式、抽象工厂模式</p>
<h3 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1.  简单工厂模式"></a>1.  简单工厂模式</h3><p>主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    T80 = <span class="number">1</span>,</span><br><span class="line">    T99</span><br><span class="line">&#125;TankType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">message</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank80</span>:<span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tank80&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank99</span>:<span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tank99&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TankFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tank* <span class="title">createTank</span><span class="params">(TankType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tank80</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tank99</span>();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h3><p>是指定义一个创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到其子类。</p>
<p>主要解决：接口选择的问题。</p>
<p>何时使用：我们明确地计划不同条件下创建不同实例时。</p>
<p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p>关键代码：创建过程在其子类执行。</p>
<p>缺点：每增加一种产品，就需要增加一个对象工厂。相比简单工厂模式，工厂方法模式需要定义更多的类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">message</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank80</span>:<span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tank80&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank99</span>:<span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tank99&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TankFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Tank* <span class="title">createTank</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank80Factory</span>:<span class="keyword">public</span> TankFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tank* <span class="title">createTank</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tank80</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank99Factory</span>:<span class="keyword">public</span> TankFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tank* <span class="title">createTank</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tank99</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h3><p>提供一个创建一系列相关或相互依赖的对象接口，而无需指定它们的具体类。</p>
<p>主要解决：接口选择的问题。</p>
<p>何时使用：系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p>如何解决：在一个产品族里面，定义多个产品。</p>
<p>关键代码：在一个工厂里聚合多个同类产品。</p>
<p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">message</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank80</span>:<span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tank80&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank99</span>:<span class="keyword">public</span> Tank</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Tank99&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plain</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">message</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plain80</span>: <span class="keyword">public</span> Plain</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Plain80&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plain99</span>: <span class="keyword">public</span> Plain</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">message</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Plain99&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Tank* <span class="title">createTank</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Plain* <span class="title">createPlain</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory80</span>:<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tank* <span class="title">createTank</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tank80</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Plain* <span class="title">createPlain</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Plain80</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory99</span>:<span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Tank* <span class="title">createTank</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Tank99</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Plain* <span class="title">createPlain</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Plain99</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式是指定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。使得算法可以独立于使用它的客户而变化，也就是说这些算法所完成的功能是一样的，对外接口是一样的，只是各自现实上存在差异。</p>
<p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p>如何解决：将这些算法封装成一个一个的类，任意地替换。</p>
<p>关键代码：实现同一个接口。</p>
<p>缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统策略模式实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hurt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">redBuff</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AdcHurt</span>:<span class="keyword">public</span> Hurt</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">redBuff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Adc hurt&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApcHurt</span>:<span class="keyword">public</span> Hurt</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">redBuff</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Apc hurt&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法1：传入一个指针参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soldier</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Soldier</span>(Hurt* hurt):<span class="built_in">m_hurt</span>(hurt)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Soldier</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">beInjured</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_hurt-&gt;<span class="built_in">redBuff</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Hurt* m_hurt;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法2：传入一个参数标签</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    adc,</span><br><span class="line">    apc</span><br><span class="line">&#125;HurtType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Master</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Master</span>(HurtType type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> adc:</span><br><span class="line">            m_hurt = <span class="keyword">new</span> AdcHurt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> apc:</span><br><span class="line">            m_hurt = <span class="keyword">new</span> ApcHurt;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            m_hurt = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Master</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">beInjured</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_hurt != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_hurt-&gt;<span class="built_in">redBuff</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Not hurt&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Hurt* m_hurt;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法3：使用模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">beInjured</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_hurt.<span class="built_in">redBuff</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_hurt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//END</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用函数指针实现策略模式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adcHurt</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;adc hurt:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">apcHurt</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;apc hurt:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//普通函数指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aid</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HurtFun)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Aid</span>(HurtFun fun):<span class="built_in">m_fun</span>(fun)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">beInjured</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">m_fun</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HurtFun m_fun;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//使用std::function , 头文件：#include&lt;functional&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bowman</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; HurtFunc;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Bowman</span>(HurtFunc fun):<span class="built_in">m_fun</span>(fun)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">beInjured</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">m_fun</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HurtFunc m_fun;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//END</span></span><br></pre></td></tr></table></figure>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。</p>
<p>主要解决：主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p>何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
<p>如何解决：继承或依赖（推荐）。</p>
<p>关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p>缺点：1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用复合，对象模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>  <span class="comment">//双端队列，被适配类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque push_back:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque push_front:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque pop_back&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque pop_front&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sequence</span>  <span class="comment">//顺序类，目标类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:<span class="keyword">public</span> Sequence   <span class="comment">//栈, 适配类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Deque m_deque;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:<span class="keyword">public</span> Sequence  <span class="comment">//队列，适配类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_deque.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Deque m_deque;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//EN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用继承,类模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deque</span>  <span class="comment">//双端队列，被适配类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque push_back:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque push_front:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque pop_back&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Deque pop_front&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sequence</span>  <span class="comment">//顺序类，目标类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>:<span class="keyword">public</span> Sequence, <span class="keyword">private</span> Deque   <span class="comment">//栈, 适配类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>:<span class="keyword">public</span> Sequence, <span class="keyword">private</span> Deque  <span class="comment">//队列，适配类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//END</span></span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>主要解决：一个全局使用的类频繁地创建与销毁。</p>
<p>何时使用：想控制实例数目，节省系统资源的时候。</p>
<p>如何解决：判断系统是否已存在单例，如果有则返回，没有则创建。</p>
<p>关键代码：构造函数是私有的。</p>
<p>单例大约有两种实现方法：懒汉与饿汉。</p>
<p>懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化，所以上边的经典方法被归为懒汉实现；</p>
<p>饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。</p>
<p>特点与选择：由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。</p>
<p>在访问量较小时，采用懒汉实现。这是以时间换空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式一般实现：非线程安全，getInstance返回的实例指针需要delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* m_pSingleton;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;    </span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>;  <span class="comment">//明确拒绝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; obj) = <span class="keyword">delete</span>; <span class="comment">//明确拒绝</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Singleton* Singleton::m_pSingleton = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pSingleton == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pSingleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pSingleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//END</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//懒汉式：加lock，线程安全</span></span><br><span class="line">std::mutex mt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">//明确拒绝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">//明确拒绝</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">static</span> Singleton* m_pSingleton;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">Singleton* Singleton::m_pSingleton = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pSingleton == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mt.<span class="built_in">lock</span>();</span><br><span class="line">        m_pSingleton = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        mt.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_pSingleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//END</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//返回一个reference指向local static对象</span></span><br><span class="line"><span class="comment">//多线程可能存在不确定性：任何一种non-const static对象，不论它是local或non-local，在多线程环境下“等待某事发生”都会有麻烦。</span></span><br><span class="line"><span class="comment">//解决的方法：在程序的单线程启动阶段手工调用所有reference-returning函数。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">//明确拒绝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">//明确拒绝</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">Singleton&amp; <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//END</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//饿汉式：线程安全，注意delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;  <span class="comment">//明确拒绝</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">//明确拒绝</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">static</span> Singleton* m_pSingleton;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Singleton* Singleton::m_pSingleton = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"> </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_pSingleton;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//END</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>懒汉式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> CSingleton *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CSingleton *t = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    CSingleton *tt = CSingleton::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl &lt;&lt; tt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CSingleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> CSingleton *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CSingleton* CSingleton::p = <span class="keyword">new</span> <span class="built_in">CSingleton</span>();</span><br></pre></td></tr></table></figure>

<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>主要解决：在运行期建立和删除对象。</p>
<p>何时使用：1).当我们的对象类型不是开始就能确定的，而这个类型是在运行期确定的话，那么我们通过这个类型的对象克隆出一个新的对象比较容易一些；2).有的时候，我们需要一个对象在某个状态下的副本，此时，我们使用原型模式是最好的选择；例如：一个对象，经过一段处理之后，其内部的状态发生了变化；这个时候，我们需要一个这个状态的副本，如果直接new一个新的对象的话,但是它的状态是不对的，此时，可以使用原型模式，将原来的对象拷贝一个出来，这个对象就和之前的对象是完全一致的了；3).当我们处理一些比较简单的对象时，并且对象之间的区别很小，可能就几个属性不同而已，那么就可以使用原型模式来完成，省去了创建对象时的麻烦了；4).有的时候，创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，不必去理会创建的过程。</p>
<p>适当的时候考虑一下原型模式，能减少对应的工作量，减少程序的复杂度，提高效率。</p>
<p>如何解决：利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<p>关键代码：拷贝，return new className(*this);</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Clone</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Clone</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Clone* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span>:<span class="keyword">public</span> Clone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sheep</span>(<span class="type">int</span> id, string name):<span class="built_in">Clone</span>(),<span class="built_in">m_id</span>(id),<span class="built_in">m_name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sheep() id add:&quot;</span> &lt;&lt; &amp;m_id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sheep() name add:&quot;</span> &lt;&lt; &amp;m_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Sheep</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Sheep</span>(<span class="type">const</span> Sheep&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_id = obj.m_id;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_name = obj.m_name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sheep(const Sheep&amp; obj) id add:&quot;</span> &lt;&lt; &amp;m_id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Sheep(const Sheep&amp; obj) name add:&quot;</span> &lt;&lt; &amp;m_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Clone* <span class="title">clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sheep</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id  :&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_id;</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Clone* s1 = <span class="keyword">new</span> <span class="built_in">Sheep</span>(<span class="number">1</span>, <span class="string">&quot;abs&quot;</span>);</span><br><span class="line">    s1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    Clone* s2 = s1-&gt;<span class="built_in">clone</span>();</span><br><span class="line">    s2-&gt;<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">delete</span> s1;</span><br><span class="line">    <span class="keyword">delete</span> s2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><p>模板模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>主要解决：多个子类有相同的方法，并且逻辑相同，细节有差异。</p>
<p>如何解决：对重要，复杂的算法，将核心算法设计为模板方法，周边细节由子类实现，重构时，经常使用的方法，将相同的代码抽象到父类，通过钩子函数约束行为。</p>
<p>关键代码：在抽象类实现通用接口，细节变化在子类实现。</p>
<p>缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">product</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">installCpu</span>();</span><br><span class="line">        <span class="built_in">installRam</span>();</span><br><span class="line">        <span class="built_in">installGraphicsCard</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>    <span class="type">void</span> <span class="title">installCpu</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">installRam</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">installGraphicsCard</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerA</span>:<span class="keyword">public</span> Computer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">installCpu</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ComputerA install Inter Core i5&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">installRam</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ComputerA install 2G Ram&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">installGraphicsCard</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ComputerA install Gtx940 GraphicsCard&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerB</span>:<span class="keyword">public</span> Computer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">installCpu</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ComputerB install Inter Core i7&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">installRam</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ComputerB install 4G Ram&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">installGraphicsCard</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ComputerB install Gtx960 GraphicsCard&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式：将复杂对象的构建和其表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>主要解决：一个复杂对象的创建工作，由各个部分的子对象用一定的算法构成；由于需求变化，这个复杂对象的各个部分经常面临变化，但将它们组合在一起的算法却相对稳定。</p>
<p>如何解决：将变与不变分开</p>
<p>关键代码：建造者：创建和提供实例，Director：管理建造出来的实例的依赖关系。</p>
<p>缺点：1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    type1,</span><br><span class="line">    type2</span><br><span class="line">&#125;ProductType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span>   <span class="comment">//产品</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setNum</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setColor</span><span class="params">(string color)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setType</span><span class="params">(ProductType type)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showProduct</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;</span><br><span class="line">    string m_color;</span><br><span class="line">    ProductType m_type;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Product::setNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_num = num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Product::setColor</span><span class="params">(string color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_color = color;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Product::setType</span><span class="params">(ProductType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_type = type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Product::showProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Product: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;       num  : &quot;</span> &lt;&lt; m_num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;       color: &quot;</span> &lt;&lt; m_color.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;       type : &quot;</span> &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建造者父类，定义接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Builder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Builder</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Builder</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildNum</span><span class="params">(<span class="type">int</span> num)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildColor</span><span class="params">(string color)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">buildType</span><span class="params">(ProductType type)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">createProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">getProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建造者A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuilderA</span>:<span class="keyword">public</span> Builder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuilderA</span>()&#123;&#125;</span><br><span class="line">     ~<span class="built_in">BuilderA</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildNum</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildColor</span><span class="params">(string color)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildType</span><span class="params">(ProductType type)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">Product* <span class="title">getProduct</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Product* m_product;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderA::buildNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderA build Num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    m_product-&gt;<span class="built_in">setNum</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderA::buildColor</span><span class="params">(string color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderA build color: &quot;</span> &lt;&lt; color.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    m_product-&gt;<span class="built_in">setColor</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderA::buildType</span><span class="params">(ProductType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderA build type: &quot;</span> &lt;&lt; type &lt;&lt; endl;</span><br><span class="line">    m_product-&gt;<span class="built_in">setType</span>(type);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderA::createProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderA CreateProduct: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_product = <span class="keyword">new</span> <span class="built_in">Product</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Product* <span class="title">BuilderA::getProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_product;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderA::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_product-&gt;<span class="built_in">showProduct</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//建造者B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuilderB</span>:<span class="keyword">public</span> Builder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuilderB</span>()&#123;&#125;</span><br><span class="line">     ~<span class="built_in">BuilderB</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildNum</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildColor</span><span class="params">(string color)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildType</span><span class="params">(ProductType type)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createProduct</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">Product* <span class="title">getProduct</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Product* m_product;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderB::buildNum</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderB build Num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    m_product-&gt;<span class="built_in">setNum</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderB::buildColor</span><span class="params">(string color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderB build color: &quot;</span> &lt;&lt; color.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    m_product-&gt;<span class="built_in">setColor</span>(color);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderB::buildType</span><span class="params">(ProductType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderB build type: &quot;</span> &lt;&lt; type &lt;&lt; endl;</span><br><span class="line">    m_product-&gt;<span class="built_in">setType</span>(type);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderB::createProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;BuilderB CreateProduct: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_product = <span class="keyword">new</span> <span class="built_in">Product</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Product* <span class="title">BuilderB::getProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_product;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderB::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_product-&gt;<span class="built_in">showProduct</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//管理类，负责安排构造的具体过程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Director</span>(Builder* builder):<span class="built_in">m_builder</span>(builder)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(<span class="type">int</span> num, string color, ProductType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_builder-&gt;<span class="built_in">createProduct</span>();</span><br><span class="line">        m_builder-&gt;<span class="built_in">buildNum</span>(num);</span><br><span class="line">        m_builder-&gt;<span class="built_in">buildColor</span>(color);</span><br><span class="line">        m_builder-&gt;<span class="built_in">buildType</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Builder* m_builder;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式：为子系统中的一组接口定义一个一致的界面，外观模式提供了一个高层接口，这个接口使得这一子系统更加容易被使用；对于复杂的系统，系统为客户提供一个简单的接口，把复杂的实现过程封装起来，客户不需要了解系统内部的细节。</p>
<p>主要解决：客户不需要了解系统内部复杂的细节，只需要一个接口；系统入口。</p>
<p>如何解决：客户不直接与系统耦合，而是通过外观类与系统耦合。</p>
<p>关键代码：客户与系统之间加一个外观层，外观层处理系统的调用关系、依赖关系等。</p>
<p>缺点：需要修改时不易继承、不易修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cpu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">productCpu</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Product Cpu&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ram</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">productRam</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Product Ram&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graphics</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">productGraphics</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Product Graphics&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">productComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Cpu cpu;</span><br><span class="line">        cpu.<span class="built_in">productCpu</span>();</span><br><span class="line">        Ram ram;</span><br><span class="line">        ram.<span class="built_in">productRam</span>();</span><br><span class="line">        Graphics graphics;</span><br><span class="line">        graphics.<span class="built_in">productGraphics</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//客户直接调用computer生产函数，无需关心具体部件的生产过程。也可直接单独生产部件</span></span><br><span class="line">    Computer computer;   </span><br><span class="line">    computer.<span class="built_in">productComputer</span>();</span><br><span class="line"> </span><br><span class="line">    Cpu cpu;</span><br><span class="line">    cpu.<span class="built_in">productCpu</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>主要解决：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p>如何解决：树枝和树叶实现统一接口，树枝内部组合该接口。</p>
<p>关键代码：树枝内部组合该接口，并且含有内部属性list，里面放Component。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Company</span>(string name):<span class="built_in">m_name</span>(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Company</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(Company* company)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体的公司</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCompany</span>:<span class="keyword">public</span> Company   <span class="comment">//树枝</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteCompany</span>(string name):<span class="built_in">Company</span>(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">ConcreteCompany</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ConcreteCompany()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Company* company)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(string name)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;shared_ptr&lt;Company&gt;&gt; m_listCompany;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteCompany::add</span><span class="params">(Company* company)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Company&gt; <span class="title">temp</span><span class="params">(company)</span></span>;</span><br><span class="line">    m_listCompany.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteCompany::remove</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;shared_ptr&lt;Company&gt;&gt;::iterator iter = m_listCompany.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; iter != m_listCompany.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Company&gt; <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">        string strName = temp.<span class="built_in">get</span>()-&gt;<span class="built_in">getName</span>();</span><br><span class="line">        <span class="keyword">if</span>(name == strName)</span><br><span class="line">        &#123;</span><br><span class="line">            m_listCompany.<span class="built_in">erase</span>(iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteCompany::display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m_name.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    list&lt;shared_ptr&lt;Company&gt;&gt;::iterator iter = m_listCompany.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; iter != m_listCompany.<span class="built_in">end</span>(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;Company&gt; <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">        temp.<span class="built_in">get</span>()-&gt;<span class="built_in">display</span>(depth + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//公司下的部门</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FinanceDept</span>:<span class="keyword">public</span> Company    <span class="comment">//树叶</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FinanceDept</span>(string name):<span class="built_in">Company</span>(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">FinanceDept</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~FinanceDept()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Company* company)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(string name)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FinanceDept::add</span><span class="params">(Company* company)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FinanceDept add failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FinanceDept::remove</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;FinanceDept remove failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FinanceDept::display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m_name.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//公司下的部门</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HRDept</span>:<span class="keyword">public</span> Company  <span class="comment">//树叶</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HRDept</span>(string name):<span class="built_in">Company</span>(name)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~<span class="built_in">HRDept</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~HRDept()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(Company* company)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(string name)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> depth)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HRDept::add</span><span class="params">(Company* company)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;HRDept add failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HRDept::remove</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;HRDept remove failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HRDept::display</span><span class="params">(<span class="type">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; m_name.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Company* root = <span class="keyword">new</span> <span class="built_in">ConcreteCompany</span>(<span class="string">&quot;zong&quot;</span>);</span><br><span class="line">    Company* f1 = <span class="keyword">new</span> <span class="built_in">FinanceDept</span>(<span class="string">&quot;F1&quot;</span>);</span><br><span class="line">    Company* h1 = <span class="keyword">new</span> <span class="built_in">HRDept</span>(<span class="string">&quot;H1&quot;</span>);</span><br><span class="line">    root-&gt;<span class="built_in">add</span>(f1);</span><br><span class="line">    root-&gt;<span class="built_in">add</span>(h1);</span><br><span class="line">    Company* c1 = <span class="keyword">new</span> <span class="built_in">ConcreteCompany</span>(<span class="string">&quot;fen1&quot;</span>);</span><br><span class="line">    Company* f2 = <span class="keyword">new</span> <span class="built_in">FinanceDept</span>(<span class="string">&quot;F2&quot;</span>);</span><br><span class="line">    Company* h2 = <span class="keyword">new</span> <span class="built_in">HRDept</span>(<span class="string">&quot;H2&quot;</span>);</span><br><span class="line">    c1-&gt;<span class="built_in">add</span>(f2);</span><br><span class="line">    c1-&gt;<span class="built_in">add</span>(h2);</span><br><span class="line">    root-&gt;<span class="built_in">add</span>(c1);</span><br><span class="line">    root-&gt;<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式：为其它对象提供一种代理以控制对这个对象的访问。</p>
<p>主要解决：在直接访问对象时带来的问题，比如：要访问的对象在远程服务器上。在面向对象系统中，有些对象由于某些原因，直接访问会给使用者或系统带来很多麻烦，可以在访问此对象时加上一个对此对象的访问层。</p>
<p>如何解决：增加中间代理层。</p>
<p>关键代码：实现与被代理类组合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gril</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Gril</span>(string name = <span class="string">&quot;gril&quot;</span>):<span class="built_in">m_string</span>(name)&#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_string;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_string;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Profession</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Profession</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">profess</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YoungMan</span>:<span class="keyword">public</span> Profession</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">YoungMan</span>(Gril gril):<span class="built_in">m_gril</span>(gril)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">profess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Young man love &quot;</span> &lt;&lt; m_gril.<span class="built_in">getName</span>().<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Gril m_gril;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ManProxy</span>:<span class="keyword">public</span> Profession</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ManProxy</span>(Gril gril):<span class="built_in">m_man</span>(<span class="keyword">new</span> <span class="built_in">YoungMan</span>(gril))&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">profess</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Proxy&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_man-&gt;<span class="built_in">profess</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    YoungMan* m_man;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Gril <span class="title">gril</span><span class="params">(<span class="string">&quot;hei&quot;</span>)</span></span>; <span class="comment">//代理</span></span><br><span class="line">    Profession* proxy = <span class="keyword">new</span> <span class="built_in">ManProxy</span>(gril);</span><br><span class="line">    proxy-&gt;<span class="built_in">profess</span>();</span><br><span class="line">    <span class="keyword">delete</span> proxy;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式：运用共享技术有效地支持大量细粒度的对象。</p>
<p>主要解决：在有大量对象时，把其中共同的部分抽象出来，如果有相同的业务请求，直接返回内存中已有的对象，避免重新创建。</p>
<p>如何解决：用唯一标识码判断，如果内存中有，则返回这个唯一标识码所标识的对象。</p>
<p>关键代码：将内部状态作为标识，进行共享。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以Money的类别作为内部标识，面值作为外部状态。</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MoneyCategory</span>   <span class="comment">//类别，内在标识，作为标识码</span></span><br><span class="line">&#123;</span><br><span class="line">    Coin,</span><br><span class="line">    bankNote</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">FaceValue</span>      <span class="comment">//面值，外部标识，需要存储的对象</span></span><br><span class="line">&#123;</span><br><span class="line">    ValueOne = <span class="number">1</span>,</span><br><span class="line">    ValueTwo</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>      <span class="comment">//抽象父类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Money</span>(MoneyCategory cate):<span class="built_in">m_mCate</span>(cate)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Money</span>()&#123; cout &lt;&lt; <span class="string">&quot;~Money() &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">save</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MoneyCategory m_mCate;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoneyCoin</span>:<span class="keyword">public</span> Money    <span class="comment">//具体子类1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MoneyCoin</span>(MoneyCategory cate):<span class="built_in">Money</span>(cate)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">MoneyCoin</span>()&#123; cout &lt;&lt; <span class="string">&quot;~MoneyCoin()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Save Coin&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MoneyNote</span>:<span class="keyword">public</span> Money   <span class="comment">//具体子类2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MoneyNote</span>(MoneyCategory cate):<span class="built_in">Money</span>(cate)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">MoneyNote</span>()&#123; cout &lt;&lt; <span class="string">&quot;~MoneyNote()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Save BankNote&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bank</span>():<span class="built_in">m_coin</span>(<span class="literal">nullptr</span>),<span class="built_in">m_note</span>(<span class="literal">nullptr</span>),<span class="built_in">m_count</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Bank</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_coin != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_coin;</span><br><span class="line">            m_coin = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m_note != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_note;</span><br><span class="line">            m_note = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveMoney</span><span class="params">(MoneyCategory cate, FaceValue value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(cate)    <span class="comment">//以类别作为标识码</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> Coin:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_coin == <span class="literal">nullptr</span>)  <span class="comment">//内存中存在标识码所标识的对象，则直接调用，不再创建</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_coin = <span class="keyword">new</span> <span class="built_in">MoneyCoin</span>(Coin);</span><br><span class="line">            &#125;</span><br><span class="line">            m_coin-&gt;<span class="built_in">save</span>();</span><br><span class="line">            m_vector.<span class="built_in">push_back</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> bankNote:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m_note == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_note = <span class="keyword">new</span> <span class="built_in">MoneyNote</span>(bankNote);</span><br><span class="line">            &#125;</span><br><span class="line">            m_note-&gt;<span class="built_in">save</span>();</span><br><span class="line">            m_vector.<span class="built_in">push_back</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSave</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = m_vector.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(; iter != m_vector.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            m_count += *iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_count;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;FaceValue&gt; m_vector;</span><br><span class="line">    Money* m_coin;</span><br><span class="line">    Money* m_note;</span><br><span class="line">    <span class="type">int</span> m_count;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bank b1;</span><br><span class="line">    b1.<span class="built_in">saveMoney</span>(Coin, ValueOne);</span><br><span class="line">    b1.<span class="built_in">saveMoney</span>(Coin, ValueTwo);</span><br><span class="line">    b1.<span class="built_in">saveMoney</span>(Coin, ValueTwo);</span><br><span class="line">    b1.<span class="built_in">saveMoney</span>(bankNote, ValueOne);</span><br><span class="line">    b1.<span class="built_in">saveMoney</span>(bankNote, ValueTwo);</span><br><span class="line">    cout &lt;&lt; b1.<span class="built_in">sumSave</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式：将抽象部分与实现部分分离，使它们都可以独立变换。</p>
<p>主要解决：在有很多中可能会变化的情况下，用继承会造成类爆炸问题，不易扩展。</p>
<p>如何解决：把不同的分类分离出来，使它们独立变化，减少它们之间的耦合。</p>
<p>关键代码：将现实独立出来，抽象类依赖现实类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将各种App、各种手机全部独立分开，使其自由组合桥接</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">App</span>()&#123; cout &lt;&lt; <span class="string">&quot;~App()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GameApp</span>:<span class="keyword">public</span> App</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;GameApp Running&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TranslateApp</span>:<span class="keyword">public</span> App</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;TranslateApp Running&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MobilePhone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MobilePhone</span>()&#123; cout &lt;&lt; <span class="string">&quot;~MobilePhone()&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">appRun</span><span class="params">(App* app)</span> </span>= <span class="number">0</span>;  <span class="comment">//实现App与手机的桥接</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XiaoMi</span>:<span class="keyword">public</span> MobilePhone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appRun</span><span class="params">(App* app)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;XiaoMi: &quot;</span>;</span><br><span class="line">        app-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuaWei</span>:<span class="keyword">public</span> MobilePhone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appRun</span><span class="params">(App* app)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;HuaWei: &quot;</span>;</span><br><span class="line">        app-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    App* gameApp = <span class="keyword">new</span> GameApp;</span><br><span class="line">    App* translateApp = <span class="keyword">new</span> TranslateApp;</span><br><span class="line">    MobilePhone* mi = <span class="keyword">new</span> XiaoMi;</span><br><span class="line">    MobilePhone* hua = <span class="keyword">new</span> HuaWei;</span><br><span class="line">    mi-&gt;<span class="built_in">appRun</span>(gameApp);</span><br><span class="line">    mi-&gt;<span class="built_in">appRun</span>(translateApp);</span><br><span class="line">    hua-&gt;<span class="built_in">appRun</span>(gameApp);</span><br><span class="line">    hua-&gt;<span class="built_in">appRun</span>(translateApp);</span><br><span class="line">    <span class="keyword">delete</span> hua;</span><br><span class="line">    <span class="keyword">delete</span> mi;</span><br><span class="line">    <span class="keyword">delete</span> gameApp;</span><br><span class="line">    <span class="keyword">delete</span> translateApp;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式：动态地给一个对象添加一些额外的功能，就新增加功能来说，装饰器模式比生产子类更加灵活。</p>
<p>主要解决：通常我们为了扩展一个类经常使用继承的方式，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p>如何解决：将具体的功能划分，同时继承装饰者类。</p>
<p>关键代码：装饰类复合和继承组件类，具体的扩展类重写父类的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dumplings</span>    <span class="comment">//抽象类   饺子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Dumplings</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showDressing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MeatDumplings</span>:<span class="keyword">public</span> Dumplings    <span class="comment">//现实类  肉馅饺子</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     ~<span class="built_in">MeatDumplings</span>()&#123; cout &lt;&lt; <span class="string">&quot;~MeatDumplings()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Add Meat&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorDumpling</span>:<span class="keyword">public</span> Dumplings    <span class="comment">//装饰类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DecoratorDumpling</span>(Dumplings* d):<span class="built_in">m_dumpling</span>(d)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DecoratorDumpling</span>()&#123; cout &lt;&lt; <span class="string">&quot;~DecoratorDumpling()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_dumpling-&gt;<span class="built_in">showDressing</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Dumplings* m_dumpling;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaltDecorator</span>:<span class="keyword">public</span> DecoratorDumpling   <span class="comment">// 装饰类  加盐</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SaltDecorator</span>(Dumplings* d):<span class="built_in">DecoratorDumpling</span>(d)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">SaltDecorator</span>()&#123; cout &lt;&lt; <span class="string">&quot;~SaltDecorator()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DecoratorDumpling::<span class="built_in">showDressing</span>();   <span class="comment">//注意点</span></span><br><span class="line">        <span class="built_in">addDressing</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Add Salt&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OilDecorator</span>:<span class="keyword">public</span> DecoratorDumpling   <span class="comment">//装饰类  加油</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OilDecorator</span>(Dumplings* d):<span class="built_in">DecoratorDumpling</span>(d)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">OilDecorator</span>()&#123; cout &lt;&lt; <span class="string">&quot;~OilDecorator()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DecoratorDumpling::<span class="built_in">showDressing</span>(); <span class="comment">//注意点</span></span><br><span class="line">        <span class="built_in">addDressing</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Add Oil&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CabbageDecorator</span>:<span class="keyword">public</span> DecoratorDumpling  <span class="comment">//装饰类   加蔬菜</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CabbageDecorator</span>(Dumplings* d):<span class="built_in">DecoratorDumpling</span>(d)&#123;&#125;</span><br><span class="line">    ~<span class="built_in">CabbageDecorator</span>()&#123; cout &lt;&lt; <span class="string">&quot;~CabbageDecorator()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DecoratorDumpling::<span class="built_in">showDressing</span>(); <span class="comment">//注意点</span></span><br><span class="line">        <span class="built_in">addDressing</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDressing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Add Cabbage&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dumplings* d = <span class="keyword">new</span> MeatDumplings;       <span class="comment">//原始的肉饺子</span></span><br><span class="line">    Dumplings* d1 = <span class="keyword">new</span> <span class="built_in">SaltDecorator</span>(d);   <span class="comment">//加盐后的饺子</span></span><br><span class="line">    Dumplings* d2 = <span class="keyword">new</span> <span class="built_in">OilDecorator</span>(d1);   <span class="comment">//加油后的饺子</span></span><br><span class="line">    Dumplings* d3 = <span class="keyword">new</span> <span class="built_in">CabbageDecorator</span>(d2);  <span class="comment">//加蔬菜后的饺子</span></span><br><span class="line">    d3-&gt;<span class="built_in">showDressing</span>();</span><br><span class="line">    <span class="keyword">delete</span> d;</span><br><span class="line">    <span class="keyword">delete</span> d1;</span><br><span class="line">    <span class="keyword">delete</span> d2;</span><br><span class="line">    <span class="keyword">delete</span> d3;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原来保存的状态。</p>
<p>如何解决：通过一个备忘录类专门存储对象状态。</p>
<p>关键代码：备忘录类、客户类、备忘录管理类；客户类不与备忘录类耦合，而是与备忘录管理类耦合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>  <span class="comment">//需要保存的信息</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    string arm;</span><br><span class="line">    string corps;</span><br><span class="line">&#125;GameValue;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span>   <span class="comment">//备忘录类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Memento</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Memento</span>(GameValue value):<span class="built_in">m_gameValue</span>(value)&#123;&#125;</span><br><span class="line">    <span class="function">GameValue <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_gameValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GameValue m_gameValue;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>     <span class="comment">//客户类 游戏</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Game</span>(GameValue value):<span class="built_in">m_gameValue</span>(value)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addGrade</span><span class="params">()</span>  <span class="comment">//等级增加</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_gameValue.grade++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replaceArm</span><span class="params">(string arm)</span>  <span class="comment">//更换武器</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_gameValue.arm = arm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replaceCorps</span><span class="params">(string corps)</span>  <span class="comment">//更换工会</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_gameValue.corps = corps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Memento <span class="title">saveValue</span><span class="params">()</span>    <span class="comment">//保存当前信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Memento <span class="title">memento</span><span class="params">(m_gameValue)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">load</span><span class="params">(Memento memento)</span> <span class="comment">//载入信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_gameValue = memento.<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Grade: &quot;</span> &lt;&lt; m_gameValue.grade &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Arm  : &quot;</span> &lt;&lt; m_gameValue.arm.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Corps: &quot;</span> &lt;&lt; m_gameValue.corps.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    GameValue m_gameValue;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretake</span> <span class="comment">//备忘录管理类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(Memento memento)</span>  <span class="comment">//保存信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Memento <span class="title">load</span><span class="params">()</span>            <span class="comment">//读已保存的信息</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_memento;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Memento m_memento;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GameValue v1 = &#123;<span class="number">0</span>, <span class="string">&quot;Ak&quot;</span>, <span class="string">&quot;3K&quot;</span>&#125;;</span><br><span class="line">    <span class="function">Game <span class="title">game</span><span class="params">(v1)</span></span>;    <span class="comment">//初始值</span></span><br><span class="line">    game.<span class="built_in">addGrade</span>();</span><br><span class="line">    game.<span class="built_in">showValue</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Caretake care;</span><br><span class="line">    care.<span class="built_in">save</span>(game.<span class="built_in">saveValue</span>());  <span class="comment">//保存当前值</span></span><br><span class="line">    game.<span class="built_in">addGrade</span>();          <span class="comment">//修改当前值</span></span><br><span class="line">    game.<span class="built_in">replaceArm</span>(<span class="string">&quot;M16&quot;</span>);</span><br><span class="line">    game.<span class="built_in">replaceCorps</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    game.<span class="built_in">showValue</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    game.<span class="built_in">load</span>(care.<span class="built_in">load</span>());   <span class="comment">//恢复初始值</span></span><br><span class="line">    game.<span class="built_in">showValue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之前的交互。</p>
<p>主要解决：对象与对象之前存在大量的关联关系，这样势必会造成系统变得复杂，若一个对象改变，我们常常需要跟踪与之关联的对象，并做出相应的处理。</p>
<p>如何解决：将网状结构分离为星型结构。</p>
<p>关键代码：将相关对象的通信封装到一个类中单独处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>   <span class="comment">//抽象同事类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setMediator</span><span class="params">(Mediator* mediator)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">getMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Mediator* m_mediator;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span>    <span class="comment">//抽象中介类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mediator</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setBuyer</span><span class="params">(Person* buyer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setSeller</span><span class="params">(Person* seller)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> string&amp; message, Person* person)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buyer</span>:<span class="keyword">public</span> Person   <span class="comment">//买家类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mediator-&gt;<span class="built_in">send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Buyer Get: &quot;</span> &lt;&lt; message.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Seller</span>:<span class="keyword">public</span> Person  <span class="comment">//卖家类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sendMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mediator-&gt;<span class="built_in">send</span>(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getMessage</span><span class="params">(<span class="type">const</span> string&amp; message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Seller Get: &quot;</span> &lt;&lt; message.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HouseMediator</span>:<span class="keyword">public</span> Mediator  <span class="comment">//具体的中介类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HouseMediator</span>():<span class="built_in">m_buyer</span>(<span class="literal">nullptr</span>),<span class="built_in">m_seller</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBuyer</span><span class="params">(Person* buyer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_buyer = buyer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSeller</span><span class="params">(Person *seller)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_seller = seller;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> string&amp; message, Person* person)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(person == m_buyer)</span><br><span class="line">        &#123;</span><br><span class="line">            m_seller-&gt;<span class="built_in">getMessage</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(person == m_seller)</span><br><span class="line">        &#123;</span><br><span class="line">            m_buyer-&gt;<span class="built_in">getMessage</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person* m_buyer;</span><br><span class="line">    Person* m_seller;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* buyer = <span class="keyword">new</span> Buyer;</span><br><span class="line">    Person* seller = <span class="keyword">new</span> Seller;</span><br><span class="line">    Mediator* houseMediator = <span class="keyword">new</span> HouseMediator;</span><br><span class="line">    buyer-&gt;<span class="built_in">setMediator</span>(houseMediator);</span><br><span class="line">    seller-&gt;<span class="built_in">setMediator</span>(houseMediator);</span><br><span class="line">    houseMediator-&gt;<span class="built_in">setBuyer</span>(buyer);</span><br><span class="line">    houseMediator-&gt;<span class="built_in">setSeller</span>(seller);</span><br><span class="line">    buyer-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;1.5?&quot;</span>);</span><br><span class="line">    seller-&gt;<span class="built_in">sendMessage</span>(<span class="string">&quot;2!!!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之前的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p>
<p>主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无需关心请求的处理细节和请求的传递，所有职责链将请求的发送者和请求的处理者解耦了。</p>
<p>如何解决：职责链链扣类都现实统一的接口。</p>
<p>关键代码：Handler内指明其上级，handleRequest()里判断是否合适，不合适则传递给上级。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">RequestLevel</span></span><br><span class="line">&#123;</span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    Two,</span><br><span class="line">    Three</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Leader</span>(Leader* leader):<span class="built_in">m_leader</span>(leader)&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Leader</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handleRequest</span><span class="params">(RequestLevel level)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Leader* m_leader;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span>:<span class="keyword">public</span> Leader   <span class="comment">//链扣1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Monitor</span>(Leader* leader):<span class="built_in">Leader</span>(leader)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(RequestLevel level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &lt; Two)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Mointor handle request : &quot;</span> &lt;&lt; level &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_leader-&gt;<span class="built_in">handleRequest</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Captain</span>:<span class="keyword">public</span> Leader    <span class="comment">//链扣2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Captain</span>(Leader* leader):<span class="built_in">Leader</span>(leader)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(RequestLevel level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(level &lt; Three)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Captain handle request : &quot;</span> &lt;&lt; level &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_leader-&gt;<span class="built_in">handleRequest</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">General</span>:<span class="keyword">public</span> Leader   <span class="comment">//链扣3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">General</span>(Leader* leader):<span class="built_in">Leader</span>(leader)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">handleRequest</span><span class="params">(RequestLevel level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;General handle request : &quot;</span> &lt;&lt; level &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Leader* general = <span class="keyword">new</span> <span class="built_in">General</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    Leader* captain = <span class="keyword">new</span> <span class="built_in">Captain</span>(general);</span><br><span class="line">    Leader* monitor = <span class="keyword">new</span> <span class="built_in">Monitor</span>(captain);</span><br><span class="line">    monitor-&gt;<span class="built_in">handleRequest</span>(Three);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都要得到通知并自动更新。</p>
<p>主要解决：一个对象更新，其它对象也要更新。</p>
<p>如何解决：目标类通知函数通知所有观察者自动更新。</p>
<p>关键代码：在目标类中增加一个ArrayList来存放观察者们。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据模型为目标类，视图为观察者类。当数据模型发生改变时，通知视图类更新</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataModel</span>   <span class="comment">//目标抽象类   数据模型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DataModel</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">add</span><span class="params">(View* view)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">remove</span><span class="params">(View* view)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//通知函数</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">View</span>      <span class="comment">//观察者抽象类   视图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">View</span>()&#123; cout &lt;&lt; <span class="string">&quot;~View()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntModel</span>:<span class="keyword">public</span> DataModel   <span class="comment">//具体的目标类， 整数模型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">IntModel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(View* view)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(m_list.<span class="built_in">begin</span>(), m_list.<span class="built_in">end</span>(), view); <span class="comment">//判断是否重复添加</span></span><br><span class="line">        <span class="keyword">if</span>(iter == m_list.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_list.<span class="built_in">push_back</span>(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(View* view)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = m_list.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(;iter != m_list.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*iter == view)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> *iter;        <span class="comment">//释放内存</span></span><br><span class="line">                m_list.<span class="built_in">erase</span>(iter);  <span class="comment">//删除元素</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span>  <span class="comment">//通知观察者更新</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = m_list.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(; iter != m_list.<span class="built_in">end</span>(); iter++)</span><br><span class="line">        &#123;</span><br><span class="line">            (*iter)-&gt;<span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_list.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = m_list.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span>(;iter != m_list.<span class="built_in">end</span>(); iter++)  <span class="comment">//释放内存</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span> *iter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;View*&gt; m_list;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeView</span>:<span class="keyword">public</span> View  <span class="comment">//具体的观察者类   视图</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TreeView</span>(string name):<span class="built_in">m_name</span>(name),<span class="built_in">View</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">TreeView</span>()&#123; cout &lt;&lt; <span class="string">&quot;~TreeView()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_name.<span class="built_in">data</span>() &lt;&lt; <span class="string">&quot; : Update&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    View* v1 = <span class="keyword">new</span> <span class="built_in">TreeView</span>(<span class="string">&quot;view1&quot;</span>);</span><br><span class="line">    View* v2 = <span class="keyword">new</span> <span class="built_in">TreeView</span>(<span class="string">&quot;view2&quot;</span>);</span><br><span class="line">    View* v3 = <span class="keyword">new</span> <span class="built_in">TreeView</span>(<span class="string">&quot;view3&quot;</span>);</span><br><span class="line">    View* v4 = <span class="keyword">new</span> <span class="built_in">TreeView</span>(<span class="string">&quot;view4&quot;</span>);</span><br><span class="line">    DataModel* model = <span class="keyword">new</span> IntModel;</span><br><span class="line">    model-&gt;<span class="built_in">add</span>(v1);</span><br><span class="line">    model-&gt;<span class="built_in">add</span>(v2);</span><br><span class="line">    model-&gt;<span class="built_in">add</span>(v3);</span><br><span class="line">    model-&gt;<span class="built_in">add</span>(v2);</span><br><span class="line">    model-&gt;<span class="built_in">add</span>(v4);</span><br><span class="line">    model-&gt;<span class="built_in">notify</span>(); <span class="comment">//更新所有观察者对象(View指针指向的TreeView对象)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    model-&gt;<span class="built_in">remove</span>(v2);</span><br><span class="line">    model-&gt;<span class="built_in">notify</span>(); <span class="comment">//更新所有观察者对象(View指针指向的TreeView对象)</span></span><br><span class="line">    <span class="keyword">delete</span> model;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<center><font size="32">------赞助耶耶，加快更新！------</font></center>

<p><img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/mybook.github.io/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="伟大的原理：局部性原理"><a href="#伟大的原理：局部性原理" class="headerlink" title="伟大的原理：局部性原理"></a>伟大的原理：局部性原理</h1><p><strong>程序在执行时呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分；相应的它所访问的空间也局限于某个区域</strong><br>时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。<br>空间局部性：在最近的将来将用到的信息很可能与正在使用的信息在空间地址上是临近的。<br>顺序局部性：在典型程序中，除转移类指令外，大部分指令是顺序进行的。</p>
<h1 id="初识操作系统"><a href="#初识操作系统" class="headerlink" title="初识操作系统"></a>初识操作系统</h1><p>现代操作系统，内核⼀般会提供 4 个基本能⼒：<br>进程调度：决定哪个进程、线程使⽤ CPU，也就是进程调度的能⼒；<br>内存管理：决定内存的分配和回收，也就是内存管理的能⼒；<br>设管理备：为进程与硬件设备之间提供通信能⼒，也就是硬件通信能⼒；<br>系统调⽤：如果应⽤程序要运⾏更⾼权限运⾏的服务，那么就需要有系统调⽤，它是⽤户程序与操作系统之间的接⼝。</p>
<h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><p>对于内核的架构一般有这三种类型：</p>
<ul>
<li>宏内核，包含多个模块，一个完整的可执行程序，且拥有最高的权限；内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。</li>
<li>微内核，有一个最小版本的内核，一些模块和服务则由用户态管理；最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信</li>
<li>混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；</li>
</ul>
<p><strong>Window 的内核设计是混合型内核</strong>，<strong>Linux 的内核是宏内核</strong></p>
<h2 id="Linux内核体系结构"><a href="#Linux内核体系结构" class="headerlink" title="Linux内核体系结构"></a>Linux内核体系结构</h2><p>系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p>
<h3 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h3><p>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 .&#x2F;linux&#x2F;kernel 中您可以找到 SCI 的实现，并在 .&#x2F;linux&#x2F;arch 中找到依赖于体系结构的部分。</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</p>
<p>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 .&#x2F;linux&#x2F;kernel 中找到进程管理的源代码，在 .&#x2F;linux&#x2F;arch 中可以找到依赖于体系结构的源代码。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 .&#x2F;linux&#x2F;mm 中找到。</p>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图4）。</p>
<h2 id="Linux文件系统层次结构"><a href="#Linux文件系统层次结构" class="headerlink" title="Linux文件系统层次结构"></a>Linux文件系统层次结构</h2><p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 .&#x2F;linux&#x2F;fs 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<h3 id="网络堆栈"><a href="#网络堆栈" class="headerlink" title="网络堆栈"></a>网络堆栈</h3><p>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 .&#x2F;linux&#x2F;net 中找到。</p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 .&#x2F;linux&#x2F;drivers 中找到。</p>
<h3 id="依赖体系结构的代码"><a href="#依赖体系结构的代码" class="headerlink" title="依赖体系结构的代码"></a>依赖体系结构的代码</h3><p>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。.&#x2F;linux&#x2F;arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 .&#x2F;linux&#x2F;arch 中找到。</p>
<p>如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP&#x2F;IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。</p>
<p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p>
<p>Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft Windows也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="CPU三级缓存"><a href="#CPU三级缓存" class="headerlink" title="CPU三级缓存"></a>CPU三级缓存</h2><p>cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cache&#x2F;index3&#x2F;size</p>
<h2 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h2><p><img data-src="/mybook.github.io/images/63874010246117.png"></p>
<h2 id="CPU读取数据方式"><a href="#CPU读取数据方式" class="headerlink" title="CPU读取数据方式"></a>CPU读取数据方式</h2><p><img data-src="/mybook.github.io/images/487145910246742.png"></p>
<h2 id="CPU的缓存写入"><a href="#CPU的缓存写入" class="headerlink" title="CPU的缓存写入"></a>CPU的缓存写入</h2><p>在什么时机才把 Cache 中的数据写回到内存？<br><strong>写直达：</strong><br>把数据同时写入内存和 Cache 中</p>
<p><img data-src="/mybook.github.io/images/519060711266908.png"></p>
<p><strong>写回</strong><br>写错时获取策略 ：当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中，减少了数据写回内存的频率</p>
<p><img data-src="/mybook.github.io/images/475621011259577.png"></p>
<p>内存读取？<br>保持独占机制</p>
<h2 id="CPU缓存一致性"><a href="#CPU缓存一致性" class="headerlink" title="CPU缓存一致性"></a>CPU缓存一致性</h2><p><img data-src="/mybook.github.io/images/227005311256132.png"></p>
<p>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播</strong>；<br>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串行化</strong>。</p>
<p><strong>解决方式</strong><br>写失效：当一个CPU修改了数据，如果其他CPU有该数据，则通知其为无效；<br>写更新：当一个CPU修改了数据，如果其他CPU有该数据，则通知其更新新数据，（写更新会导致大量的更新操作）。</p>
<h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><p><strong>属于写更新</strong><br>当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的<strong>广播事件</strong>，并检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache</p>
<h3 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h3><p><strong>属于写失效，写回</strong></p>
<ul>
<li>Modified，已修改<br>缓存行是脏的（dirty），与内存的值不同。如果别的CPU内核要读内存这块数据，该缓存行必须回写到内存，状态变为共享(S).</li>
<li>Exclusive，独占<br>缓存行只在当前缓存中，但是干净的——缓存数据相同于内存数据。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态。</li>
<li>Shared，共享<br>缓存行也存在于其它缓存中且是未修改的。缓存行可以在任意时刻抛弃。</li>
<li>Invalidated，已失效<br>缓存行是无效的</li>
</ul>
<p>当块标记为M（已修改）时，其他高速缓存中块的副本必须标记为I（无效）。</p>
<p><img data-src="/mybook.github.io/images/562890211252452.png"></p>
<ol>
<li>当一个处理器需要访问某个内存数据时，它首先会检查自己的缓存中是否有该数据的副本。如果缓存中没有该数据的副本，则会发出一个缓存不命中<strong>（miss）</strong>请求，从主内存中获取该数据的副本，并将该数据的副本存储到自己的缓存中。</li>
<li><strong>当一个处理器发出miss请求时</strong>，如果该数据的副本已经存在于另一个处理器或核心的缓存中（即处于共享状态），则该处理器可以<strong>从另一个处理器的缓存中复制该数据的副本</strong>。这个过程称为缓存到缓存复制（cache-to-cache transfer）。</li>
<li>如果两个缓存都处于修改状态，那么必须先将其中一个缓存的数据写回到主内存，然后才能进行缓存到缓存复制。</li>
</ol>
<h2 id="CPU软中断"><a href="#CPU软中断" class="headerlink" title="CPU软中断"></a>CPU软中断</h2><p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」。</p>
<p>上半部用来快速处理中断，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。<br>下半部用来延迟处理上半部未完成的工作，一般以「内核线程」的方式运行。</p>
<h2 id="用户态-内核态的方式"><a href="#用户态-内核态的方式" class="headerlink" title="用户态-&gt;内核态的方式"></a><font color="red">用户态-&gt;内核态的方式</font></h2><ol>
<li>系统调用<br>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现</li>
<li>异常<br>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。  </li>
<li>外围设备的中断<br>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li>
</ol>
<h1 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="为什么要有虚拟内存？"><a href="#为什么要有虚拟内存？" class="headerlink" title="为什么要有虚拟内存？"></a>为什么要有虚拟内存？</h2><p>局部性原理<br>单片机的 CPU 是直接操作内存的「物理地址」，要想在内存中同时运行两个程序是不可能的。如果第一个程序在某个位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容</p>
<p>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><p>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。</p>
<p><img data-src="/mybook.github.io/images/5213036139083.png"></p>
<p><img data-src="/mybook.github.io/images/1622019696606.png"></p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>存在内存碎⽚的问题<br>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开⼀个200MB 的程序。</li>
</ol>
<p><img data-src="/mybook.github.io/images/701232485698.png"></p>
<p>解决外部内存碎⽚的问题就是内存交换。这个内存交换空间，在 Linux 系统⾥，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，⽤于内存与硬盘的空间交换。<br>2. 可能内存交换的效率低的问题<br>如果内存交换的时候，交换的是⼀个占内存空间很⼤的程序，这样整个机器都会显得卡顿。</p>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，叫页。在 Linux 下，每一页的大小为 4KB。</p>
<p>虚拟地址与物理地址之间通过页表来映射，如下图：</p>
<p><img data-src="/mybook.github.io/images/592690815251886.png"></p>
<p><img data-src="/mybook.github.io/images/7861115269766.png"></p>
<p><strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址</p>
<p><img data-src="/mybook.github.io/images/4368924759853.png"></p>
<p>详细转换如下图：</p>
<p><img data-src="/mybook.github.io/images/2931454446495.png"></p>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>内存碎片：<br>当进程访问的虚拟地址在⻚表中查不到时，系统会产⽣⼀个<strong>缺⻚异常</strong>，进⼊系统内核空间分配物理内存、更新进程⻚表，最后再返回⽤户空间，恢复进程的运⾏采⽤了分⻚，那么释放的内存都是以⻚为单位释放的，也就不会产⽣⽆法给进程使⽤的⼩内存。<br>但是，因为内存分页机制分配内存的最小单位是一页，即使程序不足一页大小，我们最少只能分配一个页，所以页内会出现内存浪费，所以针对内存分页机制会有<strong>内部内存碎片</strong>的现象。</p>
<p>空间上的缺陷：<br>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），一个进程的页表需要装下 100 多万个「页表项」（2^20） ，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。</p>
<p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。那么，100 个进程的话，就需要 400MB 的内存来存储页表</p>
<h3 id="多级分页"><a href="#多级分页" class="headerlink" title="多级分页"></a>多级分页</h3><p>将页表（一级页表）分为 1024 个页表（二级页表），每个表（二级页表）中包含 1024 个「页表项」，形成二级分页。如下图所示：</p>
<p><img data-src="/mybook.github.io/images/40059992973.png"></p>
<p><strong>映射 4GB 地址空间需要 4KB（一级页表）+ 4MB（二级页表）的内存，更大的空间？（局部性原理的充分应用）</strong><br><strong>局部性原理：</strong><br>每个进程都有 4GB 的虚拟地址空间，对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，<br>对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p>
<p><strong>用时分配：</strong><br>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表了，即可以在需要时才创建二级页表。</strong><br>例如：假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）&#x3D; 0.804MB &lt; 4MB</p>
<p>总结：<br>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p>
<h4 id="TLB技术"><a href="#TLB技术" class="headerlink" title="TLB技术"></a>TLB技术</h4><p><strong>局部性原理的充分应用</strong><br>所以，把最常访问的几个页表项存储到访问速度更快的硬件，在CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB ，通常称为页表缓存、转址旁路缓存、快表等</p>
<p><img data-src="/mybook.github.io/images/576865409267371.png"></p>
<p>在CPU 中，封装了内存管理单元芯片，它用来完成地址转换和 TLB 的访问与交互。有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。<strong>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</strong></p>
<h3 id="段页式存储"><a href="#段页式存储" class="headerlink" title="段页式存储"></a>段页式存储</h3><p><strong>Linux内核的内存管理方式</strong></p>
<p>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护</p>
<p><img data-src="/mybook.github.io/images/5586609807317.png"></p>
<p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分</p>
<p>每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p>
<h3 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a><font color="red">伙伴算法</font></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> __init <span class="title">free_all_bootmem</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> __init <span class="title">free_all_bootmem_core</span><span class="params">(<span class="type">bootmem_data_t</span> *bdata)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>内部碎片是已经被分配出去的（能明确指出属于哪个进程）内存空间大于请求所需的内存空间，不能被利用的空间就是内部碎片。</li>
<li>外部碎片是指还没分配出去（不属于任何进程），但是由于大小无法分配给申请内存空间的新进程的内存空闲块。</li>
</ul>
<p>伙伴系统算法来解决<mark>内存外部碎片</mark>的问题。<mark>swap分区也为一种方法</mark>，把所有的空闲页框分组为 11 块链表，每一块链表分别包含大小为1，2，4，8，16，32，64，128，256，512 和 1024 个连续的页框。<br>假设系统中有 1MB 大小的内存需要动态管理，按照伙伴算法的要求：需要将这1M大小的内存进行划分。这里，我们将这1M的内存分为 64K、64K、128K、256K、和512K 共五个部分，如下图a所示</p>
<p><img data-src="/mybook.github.io/images/270111911240561.png"></p>
<ol>
<li>此时，如果有一个程序A想要申请一块45K大小的内存，则系统会将第一块64K的内存块分配给该程序（产生内部碎片为代价），如图b所示；</li>
<li>然后程序B向系统申请一块68K大小的内存，系统会将128K内存分配给该程序，如图c所示；</li>
<li>接下来，程序C要申请一块大小为35K的内存。系统将空闲的64K内存分配给该程序，如图d所示；</li>
<li>之后程序D需要一块大小为90K的内存。当程序提出申请时，系统本该分配给程序D一块128K大小的内存，但此时内存中已经没有空闲的128K内存块了，于是根据伙伴算法的原理，系统会将256K大小的内存块平分，将其中一块分配给程序D，另一块作为空闲内存块保留，等待以后使用，如图e所示；</li>
<li>紧接着，程序C释放了它申请的64K内存。在内存释放的同时，系统还负责检查与之相邻并且同样大小的内存是否也空闲，由于此时程序A并没有释放它的内存，所以系统只会将程序C的64K内存回收，如图f所示；</li>
<li>然后程序A也释放掉由它申请的64K内存，系统随机发现与之相邻且大小相同的一段内存块恰好也处于空闲状态。于是，将两者合并成128K内存，如图g所示；</li>
<li>之后程序B释放掉它的128k，系统也将这块内存与相邻的128K内存合并成256K的空闲内存，如图h所示；</li>
<li>最后程序D也释放掉它的内存，经过三次合并后，系统得到了一块1024K的完整内存，如图i所示。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，<strong>因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性</strong>，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。<br>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就<strong>解决了多进程之间地址冲突的问题。</strong><br>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</p>
<h2 id="内存进阶"><a href="#内存进阶" class="headerlink" title="内存进阶"></a>内存进阶</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Linux的用户空间和内核空间内存大小</p>
<p><img data-src="/mybook.github.io/images/107475909264873.png"></p>
<p>用户空间内存从低到高分别是 6 种不同的内存段：代表了不同的含义</p>
<p><img data-src="/mybook.github.io/images/416540910246114.png"></p>
<ul>
<li>代码段，包括<strong>二进制可执行代码</strong>；</li>
<li>数据段，包括<strong>已初始化的静态常量和全局变量</strong>；</li>
<li>BSS 段，包括<strong>未初始化的静态变量和全局变量</strong>；</li>
<li>堆段，包括动态分配的内存，<strong>从低地址开始向上增长</strong>；</li>
<li>文件映射段，包括动态库、共享内存等，<strong>从低地址开始向上增长</strong>（跟硬件和内核版本有关 (opens new window)）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。<strong>从低地址开始向下增长</strong>，栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><h4 id="malloc-是如何分配内存的？"><a href="#malloc-是如何分配内存的？" class="headerlink" title="malloc 是如何分配内存的？"></a>malloc 是如何分配内存的？</h4><ul>
<li>方式一：通过 brk() 系统调用从堆分配内存</li>
</ul>
<p><img data-src="/mybook.github.io/images/510461310268554.png"></p>
<ul>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存；也就是从文件映射区“偷”了一块内存</li>
</ul>
<p><img data-src="/mybook.github.io/images/598501410263690.png"></p>
<p>malloc() 源码里默认定义了一个阈值：</p>
<p>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；<br>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -i &quot;DEFAULT_MMAP_THRESHOLD_MIN&quot; malloc/malloc.c</span><br></pre></td></tr></table></figure>


<h4 id="malloc-1-会分配多大的虚拟内存？"><a href="#malloc-1-会分配多大的虚拟内存？" class="headerlink" title="malloc(1) 会分配多大的虚拟内存？"></a>malloc(1) 会分配多大的虚拟内存？</h4><p>132K</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用cat /proc/%d/maps查看内存分配\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请1字节的内存</span></span><br><span class="line">    <span class="type">void</span> *addr = <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此1字节的内存起始地址：%x\n&quot;</span>, addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用cat /proc/%d/maps查看内存分配\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将程序阻塞，当输入任意字符时才往下执行</span></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;释放了1字节的内存，但heap堆并不会释放\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；<br>malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//申请1字节的内存</span></span><br><span class="line">  <span class="type">void</span> *addr = <span class="built_in">malloc</span>(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;此128KB字节的内存起始地址：%x\n&quot;</span>, addr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;使用cat /proc/%d/maps查看内存分配\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将程序阻塞，当输入任意字符时才往下执行</span></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//释放内存</span></span><br><span class="line">  <span class="built_in">free</span>(addr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;释放了128KB字节的内存，内存也归还给了操作系统\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么不全部使用-mmap-来分配内存？"><a href="#为什么不全部使用-mmap-来分配内存？" class="headerlink" title="为什么不全部使用 mmap 来分配内存？"></a>为什么不全部使用 mmap 来分配内存？</h4><p>申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。<br>另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。</p>
<h4 id="为什么不全部使用-brk-来分配？"><a href="#为什么不全部使用-brk-来分配？" class="headerlink" title="为什么不全部使用 brk 来分配？"></a>为什么不全部使用 brk 来分配？</h4><p>随着系统频繁地 malloc 和 free ，尤其对于小块内存，堆内将产生越来越多不可用的碎片,<strong>导致“内存泄露”</strong></p>
<h4 id="free-函数只传入一个内存地址，为什么能知道要释放多大的内存？"><a href="#free-函数只传入一个内存地址，为什么能知道要释放多大的内存？" class="headerlink" title="free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？"></a>free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？</h4><p>运行上述脚本代码可发现：打印的地址比实际程序地址多出来 0x10 （16字节）<br>多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。</p>
<p><img data-src="/mybook.github.io/images/354790711257236.png"></p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>操作系统在数据读取的时候，其实并不是一字节一字节进行读取的，而是一段一段进行读取</li>
<li>我们假如是4bytes。假如我们要读取一个int，如果不对齐，这个int占用第1块的后3位和第2块的第1位，需要两次读取，将两次的数据组合起来。这样CPU将做出“多余操作”，严重影响处理速度。</li>
<li>因此需要进行内存对齐，从而提高CPU处理速率，而这项任务就交给编译器进行相应的地址分配和优化，编译器会根据提供参数或者目标环境进行相应的内存对齐。</li>
</ul>
<h4 id="结构体内存对齐的规则（未指定-pragma-pack时）"><a href="#结构体内存对齐的规则（未指定-pragma-pack时）" class="headerlink" title="结构体内存对齐的规则（未指定#pragma pack时）"></a>结构体内存对齐的规则（未指定#pragma pack时）</h4><ol>
<li>第一个成员起始于0偏移处；</li>
<li>每个成员按其类型大小和指定对齐参数n中较小的一个进行对齐；</li>
<li>结构体总长度必须为所有对齐参数的整数倍；</li>
<li>对于数组，可以拆开看做n个数组元素<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
sizeof(A) &#x3D; 8;sizeof(B) &#x3D; 12。</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">c</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A的内存布局：</td>
<td align="center">1111</td>
<td align="center">1*</td>
<td align="center">11</td>
</tr>
<tr>
<td align="center">B的内存布局：</td>
<td align="center">1***</td>
<td align="center">1111</td>
<td align="center">11**</td>
</tr>
<tr>
<td align="center">其中星号*表示填充的字节。A中，b后面为何要补充一个字节？因为c为short，其起始位置要为2的倍数，就是原则1。c的后面没有补充，因为b和c正好占用4个字节，整个A占用空间为4的倍数，也就是最大成员int类型的倍数，所以不用补充。B中，b是char为1，b后面补充了3个字节，因为a是int为4，根据原则1，起始位置要为4的倍数，所以b后面要补充3个字节。c后面补充两个字节，根据原则3，整个B占用空间要为4的倍数，c后面不补充，整个B的空间为10，不符，所以要补充2个字节。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> e[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> f;</span><br><span class="line">    <span class="type">double</span> g;</span><br><span class="line">    <span class="type">short</span> h;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">A</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sizeof(A) &#x3D; 24; 这个比较好理解，int为4，double为8，float为4，总长为8的倍数，补齐，所以整个A为24。<br>sizeof(B) &#x3D; 48; 看看B的内存布局。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">e</th>
<th align="center">f</th>
<th align="center">g</th>
<th align="center">h</th>
<th align="center">i</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B的内存布局</td>
<td align="center">11**</td>
<td align="center">1111</td>
<td align="center">11111111</td>
<td align="center">11 * * * * * *</td>
<td align="center">1111****, 11111111, 1111****</td>
</tr>
<tr>
<td align="center">i其实就是A的内存布局。i的起始位置要为24的倍数，所以h后面要补齐。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h3><ul>
<li>大端存储是指低字节存储在高地址</li>
<li>小端存储是指低字节存储在低地址<br>根据联合体来判断该系统是大端还是小端。<mark>因为联合体变量总是从低地址存储</mark><br>判断大小端的代码：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">test</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">    &#125;;</span><br><span class="line">    test t;</span><br><span class="line">    t.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.c == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><ol>
<li>后台内存回收：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</li>
<li>直接内存回收：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</li>
<li>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。</li>
</ol>
<p>OOM Killer 机制：<br>会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
<h3 id="哪些内存可以被回收？"><a href="#哪些内存可以被回收？" class="headerlink" title="哪些内存可以被回收？"></a>哪些内存可以被回收？</h3><ul>
<li><p>文件页：<strong>内核缓存的磁盘数据</strong>（Buffer）和<strong>内核缓存的文件数据</strong>（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。<strong>回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存</strong>。</p>
</li>
<li><p>匿名页：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们回收的方式是通过 Linux 的<strong>Swap 机制</strong>，Swap 会把不常访问的内存先写到磁盘中，然后”释放”这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。</p>
</li>
</ul>
<p>Linux 提供了一个 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness 选项，用来调整文件页和匿名页的回收倾向。数值越大，越积极使用 Swap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/swappiness</span><br></pre></td></tr></table></figure>


<h3 id="基于LRU算法"><a href="#基于LRU算法" class="headerlink" title="基于LRU算法"></a>基于LRU算法</h3><p>维护着 active 和 inactive 两个双向链表，其中：<br>active_list 活跃内存页链表，这里存放的是最近被访问过（活跃）的内存页；<br>inactive_list 不活跃内存页链表，这里存放的是很少被访问（非活跃）的内存页；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo | grep -i active | sort</span><br></pre></td></tr></table></figure>


<h3 id="如何保护一个进程不被-OOM-杀掉呢？"><a href="#如何保护一个进程不被-OOM-杀掉呢？" class="headerlink" title="如何保护一个进程不被 OOM 杀掉呢？"></a>如何保护一个进程不被 OOM 杀掉呢？</h3><p>Linux 内核里有一个 oom_badness() 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// points 代表打分的结果</span></span><br><span class="line"><span class="comment">// process_pages 代表进程已经使用的物理内存页面数</span></span><br><span class="line"><span class="comment">// oom_score_adj 代表 OOM 校准值</span></span><br><span class="line"><span class="comment">// totalpages 代表系统总的可用页面数</span></span><br><span class="line">points = process_pages + oom_score_adj*totalpages/<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p> oom_score_adj。它是可以通过 &#x2F;proc&#x2F;[pid]&#x2F;oom_score_adj 来配置的，设置 -1000 到 1000 之间的任意一个数值，-1000不会被杀死</p>
<h3 id="swap机制的作用"><a href="#swap机制的作用" class="headerlink" title="swap机制的作用"></a>swap机制的作用</h3><p><img data-src="/mybook.github.io/images/107475909264873.png"></p>
<p>在 32 位&#x2F;64 位操作系统环境下，申请的虚拟内存超过物理内存后会怎么样？</p>
<p>在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。<br>在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。<br>程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的。<strong>当访问这块虚拟内存后，操作系统才会进行物理内存分配。</strong></p>
<p>如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：<br>如果没有开启 Swap 机制，程序就会直接 OOM；<br>如果有开启 Swap 机制，程序可以正常运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free -m    #linux</span><br><span class="line">dir /A     #windows</span><br></pre></td></tr></table></figure>

<h2 id="内存的预读失效和缓存污染"><a href="#内存的预读失效和缓存污染" class="headerlink" title="内存的预读失效和缓存污染"></a>内存的预读失效和缓存污染</h2><p>预读失效：读磁盘多读了一些，但是没有用到<strong>（局部性原理的充分应用）</strong><br>缓存污染：批量读，把热点数据挤出去</p>
<p><strong>以上问题十分常见，包括操作系统，redis，mysql等</strong><br>Redis实现 LFU 算法，MySQL 和 Linux 操作系统是改进 LRU 算法<br>LRU算法是基于最近使用时间，其核心思想是<strong>淘汰最长时间未被使用的数据</strong>，这适用于访问模式具有时间局部性的场景；<br>LFU算法是基于访问频率，其核心思想是<strong>淘汰访问频率最低的数据</strong>，这适用于访问模式具有频率局部性的场景。</p>
<h3 id="Linux-的-Page-Cache-和-MySQL-的-Buffer-Pool"><a href="#Linux-的-Page-Cache-和-MySQL-的-Buffer-Pool" class="headerlink" title="Linux 的 Page Cache 和 MySQL 的 Buffer Pool"></a>Linux 的 Page Cache 和 MySQL 的 Buffer Pool</h3><p><img data-src="/mybook.github.io/images/321104711250370.png">                                    <img data-src="/mybook.github.io/images/439454711240900.png"></p>
<h3 id="解决预读失效"><a href="#解决预读失效" class="headerlink" title=" 解决预读失效"></a><font color="red"> 解决预读失效</font></h3><p>Linux 操作系统实现两个了 LRU 链表：活跃 LRU 链表（active_list）和非活跃 LRU 链表（inactive_list）；<br>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部。</p>
<p><img data-src="/mybook.github.io/images/200245111243404.png"></p>
<p>MySQL 的 Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：young 区域 和 old 区域。<br>预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。</p>
<p><img data-src="/mybook.github.io/images/26395211252351.png"></p>
<h3 id="解决缓存污染"><a href="#解决缓存污染" class="headerlink" title="解决缓存污染"></a><font color="red">解决缓存污染</font></h3><p>Linux 操作系统：在内存页<strong>被访问第二次</strong>的时候，才将页从 inactive list 升级到 active list 里。<br>MySQL Innodb：在内存页被访问第二次的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要<strong>进行停留在 old 区域的时间判断</strong></p>
<p>如果第二次的访问时间与第一次访问的时间在 1 秒内（默认值），那么该页就不会被从 old 区域升级到 young 区域；<br>如果第二次的访问时间与第一次访问的时间超过 1 秒，那么该页就会从 old 区域升级到 young 区域；</p>
<h2 id="深入内存"><a href="#深入内存" class="headerlink" title="深入内存"></a>深入内存</h2><p>32位系统，用户态空间划分为3g大小：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">/arch/x86/include/<span class="keyword">asm</span>/page_32_types.h        PAGE_OFFSET</span><br></pre></td></tr></table></figure>


<p><img data-src="/mybook.github.io/images/223035114245236.png"><img data-src="/mybook.github.io/images/507125114245845.png"></p>
<p>进程在内核中的描述符task_struct 结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;</span><br><span class="line">        <span class="comment">// 进程id</span></span><br><span class="line">	    <span class="type">pid_t</span>				pid;</span><br><span class="line">        <span class="comment">// 用于标识线程所属的进程 pid</span></span><br><span class="line">	    <span class="type">pid_t</span>				tgid;</span><br><span class="line">        <span class="comment">// 进程打开的文件信息</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">files_struct</span>		*files;</span><br><span class="line">        <span class="comment">// 内存描述符表示进程虚拟地址空间</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">mm_struct</span>		*mm;</span><br><span class="line"></span><br><span class="line">        .......... 省略 .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进程描述符 task_struct 结构中，有一个专门描述进程虚拟地址空间的内存描述符 mm_struct 结构，这个结构体中包含了进程虚拟内存空间的全部信息。</p>
<p>当我们调用 fork() 函数创建进程的时候，表示进程地址空间的 mm_struct 结构会随着进程描述符 task_struct 的创建而创建</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">do_fork</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title">copy_process</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">int</span> __user *child_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="keyword">struct</span> pid *pid,</span></span></span><br><span class="line"><span class="params"><span class="function">					<span class="type">int</span> trace)</span></span></span><br><span class="line"><span class="function">					</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span></span><br></pre></td></tr></table></figure>

<p>通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。<br>通过 vfork() 函数创建出的子进程，首先会设置 CLONE_VM 标识，这样来到 copy_mm 函数中就会进入 if (clone_flags &amp; CLONE_VM) 条件中，在这个分支中会将父进程的虚拟内存空间以及相关页表直接赋值给子进程。这样一来父进程和子进程的虚拟内存空间就变成共享的了。也就是说父子进程之间使用的虚拟内存空间是一样的，并不是一份拷贝。<br>vfork() ：进程-&gt;线程，Linux 内核并不区别对待</p>
<h3 id="内核如何布局进程虚拟内存空间"><a href="#内核如何布局进程虚拟内存空间" class="headerlink" title="内核如何布局进程虚拟内存空间"></a>内核如何布局进程虚拟内存空间</h3><p>在mm_struct中，定义了各个数据域的长度</p>
<p><img data-src="/mybook.github.io/images/431122815272800.png"></p>
<h3 id="内核如何管理虚拟内存区域"><a href="#内核如何管理虚拟内存区域" class="headerlink" title="内核如何管理虚拟内存区域"></a>内核如何管理虚拟内存区域</h3><p>新的结构体 vm_area_struct，正是这个结构体<strong>描述了</strong>这些虚拟内存区域</p>
<p><img data-src="/mybook.github.io/images/424744115244311.png"></p>
<p>include&#x2F;linux&#x2F;mm.h：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm_flags	访问权限</span><br><span class="line">VM_READ	可读</span><br><span class="line">VM_WRITE	可写</span><br><span class="line">VM_EXEC	可执行</span><br><span class="line">VM_SHARD	可多进程之间共享</span><br><span class="line">VM_IO	可映射至设备 IO 空间</span><br><span class="line">VM_RESERVED	内存区域不可被换出</span><br><span class="line">VM_SEQ_READ	内存区域可能被顺序访问</span><br><span class="line">VM_RAND_READ	内存区域可能被随机访问</span><br></pre></td></tr></table></figure>

<h3 id="虚拟内存区域在内核中是如何被组织的"><a href="#虚拟内存区域在内核中是如何被组织的" class="headerlink" title="虚拟内存区域在内核中是如何被组织的"></a>虚拟内存区域在内核中是如何被组织的</h3><p><img data-src="/mybook.github.io/images/295374815240562.png"></p>
<p>在进程虚拟内存空间中包含的内存区域 VMA 比较多的情况下，使用红黑树查找特定虚拟内存区域的时间复杂度是 O( logN ) ，可以显著减少查找所需的时间。<br>所以在内核中，同样的内存区域 vm_area_struct 会有两种组织形式，<strong>一种是双向链表用于高效的遍历，另一种就是红黑树用于高效的查找</strong>，每个 VMA 区域都是红黑树中的一个节点，通过 struct vm_area_struct 结构中的 vm_rb 将自己连接到红黑树中。</p>
<p>总结：mm_struct中的mmap为vm_area_struct类型，指向了每个域的开始和结束，并且同时以双向链表和红黑树存在，而mm_struct定义的start和end，标示了每个域的结束位置</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><h2 id="Linux的进程"><a href="#Linux的进程" class="headerlink" title="Linux的进程"></a>Linux的进程</h2><h3 id="0号进程"><a href="#0号进程" class="headerlink" title="0号进程"></a>0号进程</h3><p>0号进程称为 idle 进程，其 pid 等于0。</p>
<p>每个进程都有struct task_struct。idle进程对应的PCB是 struct task_struct init_task。<br>idle进程是唯一一个没有通过fork或者kernel_thread产生的进程，因为 init_task 是静态变量（初始化了的全局变量），其他进程的PCB都是fork或者kernel_thread动态申请内存创建的。<br>每个进程都有对应的一个函数，idle进程的函数是 start_kernel()，start_kernel() 最后会调用 cpu_startup_entry() ，其内部是 while(1) {}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage __visible <span class="type">void</span> __init <span class="title">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1号进程"><a href="#1号进程" class="headerlink" title="1号进程"></a>1号进程</h3><p>1号进程称为 init 进程，其 pid 等于1。</p>
<p>1号进程是0号进程通过调用 kernel_thread() 创建的，在运行 schedule_preempt_disabled() 内的 schedule() 后，就启动调度器进行进程切换，kernel_init() 也就得以运行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kernel_thread</span>(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br></pre></td></tr></table></figure>
<p>kernel_init() 最后会启动用户态的处于根文件系统存储的 init 进程，从而实现 init 内核态到 init 用户态的转化。<br>init进程完成系统的初始化，是系统中所有其它用户进程的祖先进程。</p>
<h3 id="2号进程"><a href="#2号进程" class="headerlink" title="2号进程"></a>2号进程</h3><p>2号进程称为 kthreadd 进程，其 pid 等于2。<br>kthreadd进程由idle进程通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的创建。</p>
<p>kthreadd利用for(;;)一直驻留在内存中运行：主要过程如下：<br>检查kthread_create_list为空时，kthreadd让出cpu的执行权<br>kthread_create_list不为空时，利用while循环遍历kthread_create_list链表<br>每取下一个链表节点后调用create_kthread，创建内核线程</p>
<p><img data-src="/mybook.github.io/images/547263518240701.png"></p>
<p>kernel_thread()函数<strong>是通过调用do_fork()函数创建的线程，而do_fork()则是在应用层fork(), vfork()和clone()函数的系统调用</strong>；此外还需要在其执行函数里调用daemonize()进行资源的释放；该线程挂接在init进程下。<br>kthread_create()函数是通过工作队列workqueue创建的线程，此线程挂在kthreadd线程下。<br>kthread_run()函数本质上是调用了kthread_create()和wake_up_process(), 就是除了挂在工作队列上后，便唤醒进行工作。<br>kthread_create()是比较推崇的创建内核线程的方式。</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a><font color="red">写时复制</font></h3><p>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是<strong>只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong><br>该技术是依赖硬件MMU的，没有MMU，就不支持 fork，只支持vfork。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARCH_WANT_SYS_FORK</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE0</span>(fork)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">do_fork</span>(SIGCHLD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">/* can not support in nommu mode */</span></span><br><span class="line">	<span class="keyword">return</span> -EINVAL;                    <span class="comment">//返回这个错误码需要被上层捕捉</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARCH_WANT_SYS_VFORK</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE0</span>(vfork)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">do_fork</span>(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>,</span><br><span class="line">			<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写时复制COW体现在这个函数中: copy_mm-&gt;dup_mm-&gt;dup_mmap-&gt;.......-&gt;copy_one_pte</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span></span></span><br><span class="line"><span class="function"><span class="title">copy_one_pte</span><span class="params">(<span class="keyword">struct</span> mm_struct *dst_mm, <span class="keyword">struct</span> mm_struct *src_mm,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">pte_t</span> *dst_pte, <span class="type">pte_t</span> *src_pte, <span class="keyword">struct</span> vm_area_struct *vma,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">int</span> *rss)</span></span></span><br></pre></td></tr></table></figure>

<p><img data-src="/mybook.github.io/images/95371510264876.png"></p>
<p><strong>exec函数(#include &lt;unistd.h&gt;)：</strong><br>装载一个新的程序（可执行映像）覆盖当前进程内存空间中的映像，从而执行不同的任务。exec系列函数在执行时会直接替换掉当前进程的地址空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char*)NULL*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char*)NULL*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg,...<span class="comment">/* (char*)NULL, char *const envp[]*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间</li>
<li>如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</li>
<li>如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。</li>
</ul>
<p><strong>写时复制的应用</strong></p>
<ol>
<li><p>虚拟内存管理中的写时复制<br>一般把这种被共享访问的页面标记为只读。当一个task试图向内存中写入数据时，内存管理单元（MMU）抛出一个异常，内核处理该异常时为该task分配一份物理内存并复制数据到此内存，重新向MMU发出执行该task的写操作。</p>
</li>
<li><p>Linux的文件管理系统使用了写时复制策略。</p>
</li>
<li><p>[数据库]服务器也一般采用了写时复制策略，为用户提供一份snapshot。</p>
</li>
<li><p>软件应用中的写时复制<br>[C++标准程序库]中的[std::string]类，在C++98&#x2F;C++03标准中是允许写时复制策略。但在[C++11]标准中为了提高并行性取消了这一策略。 GCC从版本5开始，std::string不再采用COW策略。</p>
</li>
</ol>
<h3 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h3><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作，所以孤儿进程并不会有什么危害。</p>
<p>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<ul>
<li>父进程只管生成新的子进程，对子进程退出之后的事情，则一概不闻不问，系统运行一段时间后，系统中就会存在很多的僵死进程，用ps命令查看的话，就会看到很多状态为Z的进程。</li>
<li>僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的父进程。答案就是把产生大量僵死进程的那个元凶枪毙掉<mark>（通过kill发送SIGTERM或者SIGKILL信号）</mark></li>
<li>枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程（daemon）是后台运行的、系统启动是就存在的、不与任何终端关联的，用于处理一些系统级别任务的特殊进程。</p>
<h4 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h4><ol>
<li>fork()创建子进程，父进程exit()退出；</li>
</ol>
<ul>
<li>由于守护进程是脱离控制终端的，完成这一步后就会在Shell终端里造成程序已经运行完毕的假象。之后的所有工作都在子进程中完成，而用户在Shell终端里则可以执行其他命令，从而在形式上做到了与控制终端的脱离，在后台工作。</li>
<li>由于父进程先于子进程退出，子进程就变为孤儿进程，并由 init 进程作为其父进程收养。</li>
</ul>
<ol start="2">
<li>在子进程调用setsid()创建新会话；<br>在调用了 fork() 函数后，子进程全盘拷贝了父进程的会话期、进程组、控制终端等，虽然父进程退出了，但会话期、进程组、控制终端等并没有改变。这还不是真正意义上的独立开来，而 setsid() 函数能够使进程完全独立出来，摆脱其他进程的控制。</li>
</ol>
<p>setsid()创建一个新会话，调用进程担任新会话的首进程，其作用有：</p>
<ul>
<li>使当前进程脱离原会话的控制</li>
<li>使当前进程脱离原进程组的控制</li>
<li>使当前进程脱离原控制终端的控制</li>
</ul>
<ol start="3">
<li><p>在子进程中调用chdir()改变当前目录为根目录；<br>使用fork创建的子进程继承了父进程的当前工作目录。由于守护进程在后台运行，开始于系统开启，终止于系统关闭，所以要将其目录改为系统的根目录下。进程在执行时，其文件系统不能被卸下。</p>
</li>
<li><p>在子进程中调用umask()重设文件权限掩码为0；</p>
</li>
</ol>
<ul>
<li>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，有个文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行权限</li>
<li>由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多的麻烦。因此把文件权限掩码重设为0即清除掩码（权限为777），这样可以大大增强该守护进程的灵活性。通常的使用方法为umask(0)。</li>
</ul>
<ol start="5">
<li>在子进程中close()不需要的文件描述符；</li>
</ol>
<ul>
<li>子进程从父进程那里继承了打开文件描述符。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸下。</li>
<li>在第二步之后，守护进程已经与控制终端失去了联系，终端输入的字符不可能达到守护进程，守护进程中用常规方法输出的字符也不可能在终端显示出来。所以，文件描述符为0、1和2 的3个文件（输入、输出和报错）已经失去了存在的价值，也应被关闭。</li>
</ul>
<ol start="6">
<li>守护进程退出处理<br>当用户需要外部停止守护进程运行时，往往会使用 kill 命令停止该守护进程。守护进程中需要编码来实现 kill 发出的signal信号处理，达到进程的正常退出。</li>
</ol>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p><strong>程序段：</strong> 存放程序代码；<br><strong>数据段：</strong> 存放程序运行时使用、产生的运算数据，如全局变量、局部变量、宏定义的常量；<br><strong>PCB（task_struct）：</strong> 存放操作系统对程序进行管理所需的各种信息，如进程描述信息、进程控制和管理信息、资源分配清单、处理机相关信息。</p>
<h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h4><p>详细信息如下图：</p>
<p><img data-src="/mybook.github.io/images/416540910246114.png"></p>
<ul>
<li>代码段，包括<strong>二进制可执行代码</strong>；</li>
<li>数据段，包括<strong>已初始化的静态常量和全局变量</strong>；</li>
<li>BSS 段，包括<strong>未初始化的静态变量和全局变量</strong>；</li>
<li>堆段，包括动态分配的内存，<strong>从低地址开始向上增长</strong>；</li>
<li>文件映射段，包括动态库、共享内存等，<strong>从低地址开始向上增长</strong>（跟硬件和内核版本有关 (opens new window)）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。<strong>从低地址开始向下增长</strong>，栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><p><img data-src="/mybook.github.io/images/468791310252792.png"></p>
<p>虽然单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是并发。</p>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><p><img data-src="/mybook.github.io/images/114001410257831.png"></p>
<ul>
<li>创建状态（new）：进程正在被创建时的状态；</li>
<li>结束状态（Exit）：进程正在从系统中消失时的状态；</li>
<li>运行状态（Running）：该时刻进程占用 CPU；</li>
<li>就绪状态（Ready）：可运行，由于其他进程处于运行状态而暂时停止运行；</li>
<li>阻塞状态（Blocked）：该进程正在等待某一事件发生（如等待输入&#x2F;输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li>
</ul>
<h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p><strong>线程是进程当中的一条执行流程</strong>****</p>
<p><img data-src="/mybook.github.io/images/254071810259126.png"></p>
<ul>
<li>同⼀个进程内多个线程之间可以共享代码段、数据段、打开的⽂件等资源，</li>
<li>但每个线程各自都有⼀套独⽴的寄存器和栈，这样可以确保线程的控制流是相对独⽴的</li>
</ul>
<h4 id="线程共享的环境"><a href="#线程共享的环境" class="headerlink" title="线程共享的环境"></a>线程共享的环境</h4><p>包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。</p>
<h4 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h4><ul>
<li>一个进程中可以同时存在多个线程；</li>
<li>各个线程之间可以并发执行；</li>
<li>各个线程之间可以共享地址空间和文件等资源；</li>
</ul>
<h4 id="线程的缺点"><a href="#线程的缺点" class="headerlink" title="线程的缺点"></a>线程的缺点</h4><p>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C&#x2F;C++ 语言，Java语言中的线程奔溃不会造成进程崩溃）。<br>举个例子，对于游戏的用户设计，则不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程。</p>
<h4 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h4><p>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；<br>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</p>
<h4 id="三种线程的实现⽅式"><a href="#三种线程的实现⽅式" class="headerlink" title="三种线程的实现⽅式"></a>三种线程的实现⽅式</h4><ul>
<li>⽤户线程（User Thread）：在⽤户空间实现的线程，不是由内核管理的线程，是由⽤户态的线程库来完成线程的管理；</li>
<li>内核线程（Kernel Thread）：在内核中实现的线程，是由内核管理的线程；</li>
<li>轻量级进程（LightWeight Process）：在内核中来⽀持⽤户线程；</li>
</ul>
<h5 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h5><p>用户线程的整个线程管理和调度，操作系统是不直接参与的，⽽是由⽤户级线程库函数来完成线程的管理，包括线程的创建、终⽌、同步和调度等。</p>
<p>⽤户线程的优点：</p>
<ul>
<li>每个进程都需要有它私有的线程控制块（TCB）列表，⽤来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由⽤户级线程库函数来维护，可⽤于不⽀持线程技术的操作系统</li>
<li>⽤户线程的切换也是由线程库函数来完成的，⽆需⽤户态与内核态的切换，所以速度特别快；</li>
</ul>
<p>⽤户线程的缺点：</p>
<ul>
<li>由于操作系统不参与线程的调度，如果⼀个线程发起了系统调⽤⽽阻塞，那进程所包含的⽤户线程都不能执⾏了。</li>
<li>当⼀个线程开始运⾏后，除⾮它主动地交出 CPU 的使⽤权，否则它所在的进程当中的其他线程⽆法运⾏，因为⽤户态的线程没法打断当前运⾏中的线程，它没有这个特权，只有操作系统才有，但是⽤户线程不是由操作系统管理的。</li>
<li>由于时间⽚分配给进程，故与其他进程⽐，在多线程执⾏时，每个线程得到的时间⽚较少，执⾏会⽐较慢；</li>
</ul>
<h5 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h5><p>内核线程是由操作系统管理的，线程对应的 TCB ⾃然是放在操作系统⾥的，这样线程的创建、终⽌和管理都是由操作系统负责。</p>
<p>内核线程的优点：</p>
<ul>
<li>在⼀个进程当中，如果某个内核线程发起系统调⽤⽽被阻塞，并不会影响其他内核线程的运⾏；</li>
<li>分配给线程，多线程的进程获得更多的 CPU 运⾏时间；</li>
</ul>
<p>内核线程的缺点：</p>
<ul>
<li>在⽀持内核线程的操作系统中，由内核来维护进程和线程的上下⽂信息，如 PCB 和TCB；</li>
<li>线程的创建、终⽌和切换都是通过系统调⽤的⽅式来进⾏，因此对于系统来说，系统开销⽐较⼤；</li>
</ul>
<h5 id="轻量级进程"><a href="#轻量级进程" class="headerlink" title="轻量级进程"></a>轻量级进程</h5><p>轻量级进程（LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。<br>轻量级进程通常共享相同的地址空间，但具有独立的堆栈和寄存器状态，从而实现了类似进程的隔离和并发执行。<br>LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息</p>
<h3 id="线程与进程的⽐较"><a href="#线程与进程的⽐较" class="headerlink" title="线程与进程的⽐较"></a>线程与进程的⽐较</h3><ol>
<li>进程是资源（包括内存、打开的⽂件等）分配的单位，线程是 CPU 调度的单位；</li>
<li>进程拥有⼀个完整的资源平台，⽽线程只独享必不可少的资源，如寄存器和栈；</li>
<li>线程同样具有就绪、阻塞、执⾏三种基本状态，同样具有状态之间的转换关系；</li>
<li>线程能减少并发执⾏的时间和空间开销；</li>
</ol>
<h3 id="线程相⽐进程能减少开销"><a href="#线程相⽐进程能减少开销" class="headerlink" title="线程相⽐进程能减少开销"></a>线程相⽐进程能减少开销</h3><ul>
<li>线程的创建时间⽐进程快，因为进程在创建的过程中，还需要资源管理信息，⽐如内存管理信息、⽂件管理信息，⽽线程在创建的过程中，不会涉及这些资源管理信息，⽽是共享它们；</li>
<li>线程的终⽌时间⽐进程快，因为线程释放的资源相⽐进程少很多；</li>
<li>同⼀个进程内的线程切换⽐进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同⼀个进程的线程都具有同⼀个⻚表，在切换的时候不需要切换⻚表。⽽进程之间切换的时候要把⻚表给切换掉，⻚表的切换过程开销是⽐较⼤的；</li>
<li>由于同⼀进程的各线程间共享内存和⽂件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更⾼了；</li>
</ul>
<h3 id="多线程和多进程的比较"><a href="#多线程和多进程的比较" class="headerlink" title="多线程和多进程的比较"></a>多线程和多进程的比较</h3><p><img data-src="/mybook.github.io/images/2429254083522.png"></p>
<ol>
<li>需要频繁创建销毁的优先用线程。<br>实例：web服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的。</li>
<li>需要进行大量计算的优先使用线程。<br>所谓大量计算，当然就是要消耗很多cpu，切换频繁了，这种情况先线程是最合适的。实例：图像处理、算法处理</li>
<li>强相关的处理用线程，若相关的处理用进程。<br>一般的server需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计。</li>
<li>可能扩展到多机分布的用进程，多核分布的用线程。</li>
</ol>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程可以理解为用户态的轻量级的非抢占式的线程。可以在程序的某个点挂起，并在稍后恢复执行</p>
<p><strong>原理：</strong></p>
<ul>
<li>我们知道操作系统在线程等待IO的时候，会阻塞当前线程，切换到其它线程，这样在当前线程等待IO的过程中，其它线程可以继续执行。</li>
<li>当线程数量非常多的时候，却产生了问题。一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</li>
<li>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<mark>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</mark>，</li>
</ul>
<p><strong>特点：</strong><br>用户态:协程是在用户态实现调度。<br>轻量级:协程不用内核调度，不被被操作系统内核所管理，不需要内核态与用户态之间切换。<br>非抢占:协程是由用户自己实现调度，并且同一时间只能有一个协程在执行，协程自己主动交出CPU的。</p>
<p><strong>优点：</strong><br>协程切换的时候开销小，用户态且轻量<br>非抢占式，不用加很多锁，减小复杂度，不用很复杂的处理线程同步问题。</p>
<p><strong>缺点：</strong><br>协程可以在单线程内处理高并发,但是协程不能同时使用单个CPU的多个核心，不能利用多核，只能使用单核。<br>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，操作系统会让线程进入阻塞状态，<mark>当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度</mark>，这往往是不能接受的。因此，<strong>协程只有和异步IO结合起来才能发挥出最大的威力。</strong></p>
<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>所谓的管道，就是内核里面的一串缓存，所谓的管道，就是内核里面的一串缓存</p>
<h4 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>fd[0]为读而打开，fd[1]为写而打开</p>
<p><img data-src="/mybook.github.io/images/312724210260128.png"></p>
<p>使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符，但是管道只能一端写入，另一端读出，所以这种模式容易造成混乱，需要：<br>父进程关闭读取的 fd[0]，只保留写入的 fd[1]；<br>子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</p>
<p><img data-src="/mybook.github.io/images/206554310260305.png">                   <strong>关闭后变为-&gt;</strong>        <img data-src="/mybook.github.io/images/345674310245857.png"></p>
<p><strong>执行A | B发生了什么</strong><br>A进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。<br><img data-src="/mybook.github.io/images/291044710262136.png"></p>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><p>也被叫做 FIFO ，因为数据是先进先出的传输⽅式。在使⽤命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkfifo</span> myPipe</span><br></pre></td></tr></table></figure>
<p>myPipe 就是这个管道的名称，基于 Linux ⼀切皆⽂件的理念，所以管道也是以⽂件的⽅式存在，我们可以⽤ ls 看⼀下，这个⽂件的类型是 p，也就是 pipe（管道） 的意思：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">prw-r--r--. 1 root root 0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure>

<p>管道传输数据是单向的，如果想相互通信，我们需要创建两个管道才⾏。管道这种通信⽅式效率低，不适合进程间频繁地交换数据。    </p>
<ul>
<li>对于匿名管道，<strong>它的通信范围是存在⽗⼦关系的进程</strong>。因为管道没有实体，也就是没有管道⽂件，只能通过 fork 来复制⽗进程 fd ⽂件描述符，来达到通信的⽬的。</li>
<li>对于命名管道，<strong>它可以在不相关的进程间也能相互通信</strong>。因为命令管道，提前创建了⼀个类型为管道的设备⽂件，在进程⾥只要使⽤这个设备⽂件，就可以相互通信。</li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">msgget</span>();</span><br></pre></td></tr></table></figure>
<p><mark>消息队列是保存在内核中的消息链表，</mark>消息队列不适合⽐较⼤数据的传输，<br><mark>消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销</mark>，因为进程写⼊数据到内核中的消息队列时，会发⽣从⽤户态拷⻉数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态拷⻉数据到⽤户态的过程。</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shmget</span>();</span><br></pre></td></tr></table></figure>
<p>多个进程将同一个文件（内存的匿名段）映射到它们的地址空间<br>共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中。<br><img data-src="/mybook.github.io/images/98108102469.png"></p>
<h4 id="存储映射I-O（mmap）"><a href="#存储映射I-O（mmap）" class="headerlink" title="存储映射I&#x2F;O（mmap）"></a><font color="red">存储映射I&#x2F;O（mmap）</font></h4><p>mmap将一个文件或者其它对象映射进内存上<br>mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。在要求高性能的应用中比较常用。mmap映射内存必须是页面大小的整数倍，面向流的设备不能进行mmap，mmap的实现和硬件有关。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> len,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> off)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="/mybook.github.io/images/4064114819868.png"></p>
<ul>
<li>两个进程中通信<br>两个程序映射同一个文件到自己的地址空间, 进程A先运行, 每隔两秒读取映射区域, 看是否发生变化. 进程B后运行, 它修改映射区域, 然后推出, 此时进程A能够观察到存储映射区的变化。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 100  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> fd, nread, i;  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sb;  </span><br><span class="line">    <span class="type">char</span> *mapped, buf[BUF_SIZE];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;  </span><br><span class="line">        buf[i] = <span class="string">&#x27;#&#x27;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 打开文件 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDWR)) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 获取文件的属性 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">fstat</span>(fd, &amp;sb)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fstat&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 将文件映射至进程的地址空间 */</span>  </span><br><span class="line">    <span class="keyword">if</span> ((mapped = (<span class="type">char</span> *)<span class="built_in">mmap</span>(<span class="literal">NULL</span>, sb.st_size, PROT_READ |   </span><br><span class="line">                    PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 文件已在内存, 关闭文件也可以操纵内存 */</span>  </span><br><span class="line">    <span class="built_in">close</span>(fd);  </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程A：每隔两秒查看存储映射区是否被修改 */</span>  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mapped);  </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程B：修改一个字符 */</span>  </span><br><span class="line">    mapped[<span class="number">20</span>] = <span class="string">&#x27;9&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">semget</span>();</span><br></pre></td></tr></table></figure>
<p>信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。</p>
<p>信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：</p>
<ul>
<li>⼀个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使⽤，进程可正常继续执⾏。</li>
<li>⼀个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将阻塞的进程唤醒运⾏；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p><img data-src="/mybook.github.io/images/595705014240451.png"></p>
<ul>
<li><strong>信号初始化为 1 ，就代表着是互斥信号量</strong>，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存<br>进程 A 在访问共享内存前，先执⾏了 P 操作，由于信号量的初始值为 1，故在进程 A 执 ⾏ P 操作后信号量变为 0，表示共享资源可⽤，于是进程 A 就可以访问共享内存。<br>若此时，进程 B 也想访问共享内存，执⾏了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占⽤，因此进程 B 被阻塞。<br>直到进程 A 访问完共享内存，才会执⾏ V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执⾏ V 操作，使信号量恢复到初始值 1。</li>
</ul>
<p><img data-src="/mybook.github.io/images/290185114258877.png"></p>
<ul>
<li><strong>信号初始化为 0 ，就代表着是同步信号量</strong>，它可以保证进程 A 应在进程 B 之前执⾏。<br>如果进程 B ⽐进程 A 先执⾏了，那么执⾏到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没⽣产数据，于是进程 B 就阻塞等待；<br>接着，当进程 A ⽣产完数据后，执⾏了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；<br>最后，进程 B 被唤醒后，意味着进程 A 已经⽣产了数据，于是进程 B 就可以正常读取数据了。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>对于异常情况下的⼯作模式，就需要⽤「信号」的⽅式来通知进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5)SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10)SIGUSR1</span><br><span class="line">11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15)SIGTERM</span><br><span class="line">16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20)SIGTSTP</span><br><span class="line">21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25)SIGXFSZ</span><br><span class="line">26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30)SIGPWR</span><br><span class="line">31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37)SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42)SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47)SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52)SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57)SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62)SIGRTMAX-2</span><br></pre></td></tr></table></figure>
<p>Ctrl+C 产⽣ SIGINT（2） （可被忽略）信号，表示终⽌该进程；<br>Ctrl+Z 产⽣ SIGTSTOP（19） 信号，表示挂起该进程，但还未结束；</p>
<p><strong>唯⼀的异步通信机制</strong>。进程有三种⽅式响应信号 1. 执⾏默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应⽤进程<mark>⽆法捕捉和忽略</mark>的，即<mark>SIGKILL（9） 和 SEGSTOP（19） </mark>，这是为了⽅便我们能在任何时候结束或停⽌某个进程</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>TCP网络编程<br><img data-src="/mybook.github.io/images/4171516095354.png"></p>
<ul>
<li>服务端和客户端初始化 socket ，得到⽂件描述符；</li>
<li>服务端调⽤ bind ，将绑定在 IP 地址和端⼝;</li>
<li>服务端调⽤ listen ，进⾏监听；</li>
<li>服务端调⽤ accept ，等待客户端连接；</li>
<li>客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；</li>
<li>服务端 accept 返回⽤于传输的 socket 的⽂件描述符；</li>
<li>客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；</li>
<li>客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭</li>
</ul>
<h2 id="线程的同步与互斥"><a href="#线程的同步与互斥" class="headerlink" title="线程的同步与互斥"></a>线程的同步与互斥</h2><p><strong>如果要访问共享资源（内存，变量等），必须考虑互斥</strong>，保证一个线程在临界区执行时，其他线程应该被阻止进入</p>
<h3 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h3><p>pthread_mutex_******<br>确保同一时间只有一个线程访问数据</p>
<h3 id="读写锁（共享互斥锁）"><a href="#读写锁（共享互斥锁）" class="headerlink" title="读写锁（共享互斥锁）"></a>读写锁（共享互斥锁）</h3><p>pthread_rwlock_******<br>一次只有一个线程可以占有写模式的读写锁，多个线程可以同时占有读模式的读写锁</p>
<ul>
<li>写加锁状态时，所有试图对这个锁加锁的线程都会被阻塞</li>
<li>读加锁状态时，所有试图以读模式对它加锁的线程都可以得到访问权，所有试图以写模式对它加锁的线程都会阻塞</li>
</ul>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>pthread_cond_******</p>
<ul>
<li>条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。</li>
<li>条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</li>
<li>传递给pthread_cond_wait的<mark>互斥量对条件变量进行保护</mark>。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。</li>
</ul>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>pthread_spin_******</p>
<ul>
<li>互斥锁加锁失败后，线程会释放 CPU ，给其他线程；</li>
<li>⾃旋锁加锁失败后，线程会忙等待，直到它拿到锁；</li>
<li>当加锁失败时，互斥锁⽤「线程切换」来应对，⾃旋锁则⽤「忙等待」来应对</li>
<li>在单核CPU 上，需要抢占式的调度器（即不断通过时钟中断⼀个线程，运⾏其他线程）。否则，⾃旋锁在单 CPU 上⽆法使⽤，因为⼀个⾃旋的线程永远不会放弃 CPU。</li>
</ul>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>pthread_barrier_******<br>是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。<br>但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。</p>
<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><p>P、V 操作，见上文信号量</p>
<h3 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h3><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><p>互斥条件；互斥条件是指多个线程不能同时使⽤同⼀个资源。<br>持有并等待条件； 一个进程本身占有资源（一种或多种），同时还有资源未得到满足，等待其他进程释放该资源。<br>不可剥夺条件；当线程已经持有了资源 ，在⾃⼰使⽤完之前不能被其他线程获取，<br>环路等待条件；在死锁发⽣的时候，两个线程获取资源的顺序构成了环形链。</p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>确保系统永远不会进入死锁状态<br><mark>a、破坏“占有且等待”条件</mark></p>
<ol>
<li>所有的进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。</li>
<li>允许进程只获得运行初期需要的资源，便开始运行，在运行过程中逐步释放掉分配到的已经使用完毕的资源，然后再去请求新的资源。</li>
</ol>
<p><mark>b、破坏“不可抢占”条件</mark><br>当一个已经持有了一些资源的进程在提出新的资源请求没有得到满足时，它必须释放已经保持的所有资源，待以后需要使用的时候再重新申请。</p>
<p><mark>c、破坏“循环等待”条件</mark><br> 可以通过定义资源类型的线性顺序来预防，可将每个资源编号，当一个进程占有编号为i的资源时，那么它下一次申请资源只能申请编号大于i的资源。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>在分配资源时判断是否会出现死锁，只在不会出现死锁的情况下才分配资源。<br>两种避免办法：<br>    1、如果一个进程的请求会导致死锁，则不启动该进程<br>    2、如果一个进程的增加资源请求会导致死锁 ，则拒绝该申请。</p>
<p>避免死锁的具体实现通常利用<strong>银行家算法</strong><br>可利用资源向量Available：用于表示系统里边各种资源剩余的数目。<br>最大需求矩阵Max：用于表示各个进程对各种资源的额最大需求量。<br>分配矩阵Allocation：就是用于表示已经分配给各个进程的各种资源的数目。也是一个nxm的矩阵。<br>需求矩阵Need：用于表示进程仍然需要的资源数目，用一个nxm的矩阵表示。</p>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>方案一：<br>让偶数编号的哲学家「先拿左边的叉⼦后拿右边的叉⼦」，奇数编号的哲学家「先拿右边的叉⼦后拿左边的叉⼦」。</p>
<p><img data-src="/mybook.github.io/images/2239037095963.png"></p>
<p>方案二：<br>用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。第 i 个哲学家的左邻右舍，则由宏 LEFT 和 RIGHT 定义：<br>LEFT : ( i + 5 - 1 ) % 5<br>RIGHT : ( i + 1 ) % 5<br>比如 i 为 2，则 LEFT 为 1，RIGHT 为 3。</p>
<p><img data-src="/mybook.github.io/images/283411416246744.png"></p>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><ol>
<li>悲观锁做事⽐较悲观，它认为多线程同时修改共享资源的概率⽐较⾼，于是很容易出现冲突，所以访问共享资源前，先要上锁。</li>
<li>乐观锁做事⽐较乐观，它假定冲突的概率很低，先修改完共享资源，再验证这段时间内有没有发⽣冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。<br>应用：在线文档多人编辑</li>
</ol>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="调度的原则"><a href="#调度的原则" class="headerlink" title="调度的原则"></a>调度的原则</h2><ul>
<li>CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；</li>
<li>系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；</li>
<li>周转时间：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；</li>
<li>等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；</li>
<li>响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。</li>
</ul>
<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><h3 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h3><h3 id="最短作业优先调度算法"><a href="#最短作业优先调度算法" class="headerlink" title="最短作业优先调度算法"></a>最短作业优先调度算法</h3><h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p><img data-src="/mybook.github.io/images/4947119118995.png"></p>
<p>如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应⽐」就越⾼，这样短作业的进程容易被选中运⾏；<br>如果两个进程「要求的服务时间」相同时，「等待时间」越⻓，「响应⽐」就越⾼，这就兼顾到了⻓作业进程，因为进程的响应⽐可以随时间等待的增加⽽提⾼，当其等待时间⾜够⻓时，其响应⽐便可以升到很⾼，从⽽获得运⾏的机会；</p>
<h3 id="时间⽚轮转调度算法"><a href="#时间⽚轮转调度算法" class="headerlink" title="时间⽚轮转调度算法"></a>时间⽚轮转调度算法</h3><p>如果时间⽚设得太短会导致过多的进程上下⽂切换，降低了 CPU 效率；如果设得太⻓⼜可能引起对短作业进程的响应时间变⻓。</p>
<h3 id="最⾼优先级调度算法"><a href="#最⾼优先级调度算法" class="headerlink" title="最⾼优先级调度算法"></a>最⾼优先级调度算法</h3><p>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运⾏时间优先级都不会变化；<br>动态优先级：根据进程的动态变化调整优先级，如果进程运⾏时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升⾼其优先级，也就是随着时间的推移增加等待进程的优先级。<br>⾮抢占式：当就绪队列中出现优先级⾼的进程，运⾏完当前进程，再选择优先级⾼的进程。<br>抢占式：当就绪队列中出现优先级⾼的进程，当前进程挂起，调度优先级⾼的进程运⾏。<br>但是依然有缺点，可能会导致低优先级的进程永远不会运⾏。</p>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p><img data-src="/mybook.github.io/images/5290937106862.png"></p>
<p>设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从⾼到低，同时优先级越⾼时间⽚越短；新的进程会被放⼊到第⼀级队列的末尾，按先来先服务的原则排队等待被调度，如果在第⼀级队列规定的时间⽚没运⾏完成，则将其转⼊到第⼆级队列的末尾，以此类推，直⾄完成；<br>当较⾼优先级的队列为空，才调度较低优先级的队列中的进程运⾏。如果进程运⾏时，有新进程进⼊较⾼优先级的队列，则停⽌当前运⾏的进程并将其移⼊到原队列末尾，接着让较⾼优先级的进程运⾏；</p>
<h2 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h2><h3 id="最佳⻚⾯置换算法"><a href="#最佳⻚⾯置换算法" class="headerlink" title="最佳⻚⾯置换算法"></a>最佳⻚⾯置换算法</h3><p>最佳⻚⾯置换算法基本思路是，置换在「未来」最⻓时间不访问的⻚⾯。</p>
<h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><p>既然我们⽆法预知⻚⾯在下⼀次访问前所需的等待时间，那我们可以选择在内存驻留时间很⻓的⻚⾯进⾏中置换，这个就是「先进先出置换」算法的思想</p>
<h3 id="最近最久未使⽤的置换算法"><a href="#最近最久未使⽤的置换算法" class="headerlink" title="最近最久未使⽤的置换算法"></a>最近最久未使⽤的置换算法</h3><p>最近最久未使⽤（LRU）的置换算法的基本思路是，发⽣缺⻚时，选择最⻓时间没有被访问的⻚⾯进⾏置换，</p>
<h4 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h4><p>像浏览器的缓存策略、memcached的缓存策略都是使用LRU这个算法，LRU算法会将近期最不会访问的数据淘汰掉。<br><img data-src="/mybook.github.io/images/1128100686625.png"></p>
<ul>
<li>新数据插入到链表头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>当链表满的时候，将链表尾部的数据丢弃</li>
</ul>
<p>LRU Cache具备的操作：<br>set(key,value)：如果key在hashmap中存在，则先重置对应的value值，然后获取对应的节点cur，将cur节点从链表删除，并移动到链表的头部；若果key在hashmap不存在，则新建一个节点，并将节点放到链表的头部。当Cache存满的时候，将链表最后一个节点删除即可。<br>get(key)：如果key在hashmap中存在，则把对应的节点放到链表头部，并返回对应的value值；如果不存在，则返回-1。</p>
<p>LRU的c++实现：<br>LRU实现采用双向链表 + Map 来进行实现。这里采用双向链表的原因是：如果采用普通的单链表，则删除节点的时候需要从表头开始遍历查找，效率为O(n)，采用双向链表可以直接改变节点的前驱的指针指向进行删除达到O(1)的效率。使用Map来保存节点的key、value值便于能在O(logN)的时间查找元素,对应get操作。</p>
<p>双链表节点的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CacheNode</span> &#123;</span><br><span class="line"> <span class="type">int</span> key;  <span class="comment">// 键</span></span><br><span class="line"> <span class="type">int</span> value; <span class="comment">// 值</span></span><br><span class="line"> CacheNode *pre, *next; <span class="comment">// 节点的前驱、后继指针</span></span><br><span class="line"> <span class="built_in">CacheNode</span>(<span class="type">int</span> k, <span class="type">int</span> v) : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">pre</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于LRUCache这个类而言，构造函数需要指定容量大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LRUCache</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"> size = capacity;  <span class="comment">// 容量</span></span><br><span class="line"> head = <span class="literal">NULL</span>;   <span class="comment">// 链表头指针</span></span><br><span class="line"> tail = <span class="literal">NULL</span>;   <span class="comment">// 链表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双链表的节点删除操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(CacheNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (node -&gt; pre != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> node -&gt; pre -&gt; next = node -&gt; next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> head = node -&gt; next;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (node -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> node -&gt; next -&gt; pre = node -&gt; pre;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> tail = node -&gt; pre;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将节点插入到头部的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setHead</span><span class="params">(CacheNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> node -&gt; next = head;</span><br><span class="line"> node -&gt; pre = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> head -&gt; pre = node;</span><br><span class="line"> &#125;</span><br><span class="line"> head = node;</span><br><span class="line"> <span class="keyword">if</span> (tail == <span class="literal">NULL</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> tail = head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(key)操作的实现比较简单，直接通过判断Map是否含有key值即可，如果查找到key，则返回对应的value，否则返回-1;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> map&lt;<span class="type">int</span>, CacheNode *&gt;::iterator it = mp.<span class="built_in">find</span>(key);</span><br><span class="line"> <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> CacheNode *node = it -&gt; second;</span><br><span class="line"> <span class="built_in">remove</span>(node);</span><br><span class="line"> <span class="built_in">setHead</span>(node);</span><br><span class="line"> <span class="keyword">return</span> node -&gt; value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>set(key, value)操作需要分情况判断。如果当前的key值对应的节点已经存在，则将这个节点取出来，并且删除节点所处的原有的位置，并在头部插入该节点；如果节点不存在节点中，这个时候需要在链表的头部插入新节点，插入新节点可能导致容量溢出，如果出现溢出的情况，则需要删除链表尾部的节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> map&lt;<span class="type">int</span>, CacheNode *&gt;::iterator it = mp.<span class="built_in">find</span>(key);</span><br><span class="line"> <span class="keyword">if</span> (it != mp.<span class="built_in">end</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> CacheNode *node = it -&gt; second;</span><br><span class="line"> node -&gt; value = value;</span><br><span class="line"> <span class="built_in">remove</span>(node);</span><br><span class="line"> <span class="built_in">setHead</span>(node);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> CacheNode *newNode = <span class="keyword">new</span> <span class="built_in">CacheNode</span>(key, value);</span><br><span class="line"> <span class="keyword">if</span> (mp.<span class="built_in">size</span>() &gt;= size)</span><br><span class="line"> &#123;</span><br><span class="line">  map&lt;<span class="type">int</span>, CacheNode *&gt;::iterator iter = mp.<span class="built_in">find</span>(tail -&gt; key);</span><br><span class="line">  <span class="built_in">remove</span>(tail);</span><br><span class="line">  mp.<span class="built_in">erase</span>(iter);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">setHead</span>(newNode);</span><br><span class="line"> mp[key] = newNode;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时钟⻚⾯置换算法"><a href="#时钟⻚⾯置换算法" class="headerlink" title="时钟⻚⾯置换算法"></a>时钟⻚⾯置换算法</h3><p><img data-src="/mybook.github.io/images/5742525189098.png"></p>
<p><img data-src="/mybook.github.io/images/1333708746621.png"></p>
<h3 id="最不常⽤算法"><a href="#最不常⽤算法" class="headerlink" title="最不常⽤算法"></a>最不常⽤算法</h3><p>当发⽣缺⻚中断时，选择「访问次数」最少的那个⻚⾯，并将其淘汰。</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><h3 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h3><h3 id="最短寻道时间优先算法"><a href="#最短寻道时间优先算法" class="headerlink" title="最短寻道时间优先算法"></a>最短寻道时间优先算法</h3><p>根据距离磁头最近的请求的算法</p>
<h3 id="扫描算法（电梯算法）"><a href="#扫描算法（电梯算法）" class="headerlink" title="扫描算法（电梯算法）"></a>扫描算法（电梯算法）</h3><p>磁头在⼀个⽅向上移动，访问所有未完成的请求，直到磁头到达该⽅向上的最后的磁道，才调换⽅向，这就是扫描（Scan）算法。<br><img data-src="/mybook.github.io/images/5363799515717.png"></p>
<h3 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h3><p>只有磁头朝某个特定⽅向移动时，才处理磁道访问请求，⽽返回时直接快速移动⾄最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应⼀个⽅向上的请求。<br><img data-src="/mybook.github.io/images/3568121535713.png"><br>循环扫描算法相⽐于扫描算法，对于各个位置磁道响应频率相对⽐较平均。</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>一切皆文件</p>
<h2 id="Linux的文件类型"><a href="#Linux的文件类型" class="headerlink" title="Linux的文件类型"></a>Linux的文件类型</h2><ol>
<li>普通文件<br>普通文件根据存放的内容的不同，又分为如下两种：</li>
</ol>
<ul>
<li><p>文本文件<br>存放的都是文字编码，文本编辑器打开后，会将这些文字编码翻译为文字图形，以供人识别。</p>
</li>
<li><p>纯二进制文件（机器码）</p>
</li>
<li><p><input disabled type="checkbox"> 
比如经过编译后得到的可执行文件，里面放的是cpu执行的纯二进制机器码，由于文编编辑器只认识文字编码，所以用文本编辑器打开后，显示的内容无法是错乱的，无法辨识。命令cat就是一个二进制文件</p>
</li>
<li><p><input disabled type="checkbox"> 
其实不管存放的是文字编码，还是机器码，在计算机中存储时，其实都是以二进制形式存放的，只不过我们这里可刻意的把机器码这类非文字编码的数据，特意强调为了二进制数据。</p>
</li>
<li><p><input disabled type="checkbox"> 
对linux内核而言，这两种文件并无区别，至于文件中的数据如何解释，则由处理这些数据的应用程序（比如文本编辑器）来决定。</p>
</li>
<li><p><input disabled type="checkbox"> 
不管是文字编码数据，还是纯二进制数据，应用程序调用read、write读写文件时，没有任何区别。</p>
</li>
</ul>
<ol start="2">
<li>目录文件<br>目录是一种特殊的文件，专门用于管理其它文件。第一个属性为 [d]，例如 [drwxrwxrwx]。</li>
<li>字符设备文件<br>字符设备文件，就是字符设备驱动程序，在上层的表现形式。<br>当应用程序调用底层字符设备驱动程序，实现对某个字符设备进行读写时，上层就需要对接底层的字符驱动程序，字符设备驱动在上层，会以“字符设备文件”的形式表现出来，我们通过open、read、write去读写字符设备文件，就实现了和底层字符设备驱动程序的交互。</li>
<li>块设备文件<br>对应块设备（如磁盘等）。<br>块设备文件，是块设备驱动程序在上层的表现形式。</li>
</ol>
<ul>
<li><mark>字符设备与块设备有什么区别？</mark><br>（a）字符设备<br>以字节为单位来操作数据。<br>比如：键盘、鼠标、显示器都等是字符设备。<br>（b）块设备<br>块设备存储的数据量往往非常大，为了提高读写效率，都是以块（1024字节）为单位来操作数据。<br>比如：电脑硬盘、移动硬盘、u盘等，凡是涉及大量数据存储的，都是以块为单位来操作数据的，都是块设备。</li>
</ul>
<ol start="5">
<li>FIFO（fifo：p）<br>管道文件，用于实现不同进程（程序）之间的通信，管道是OS提供的一种纯代码层面的通信机制。<br>A进程 ————————&gt; 管道文件 ————————&gt;B进程</li>
<li>套接字文件（socket：s）<br>专门用于网络通信的文件。</li>
</ol>
<h2 id="文件的管理"><a href="#文件的管理" class="headerlink" title="文件的管理"></a>文件的管理</h2><p>索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。<br>目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。</strong></p>
<p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，Linux 读写逻辑块，逻辑块大小为 4KB，也就是一次性读写 8 个扇区。</p>
<p><img data-src="/mybook.github.io/images/503013809240452.png"></p>
<p>磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。</p>
<ul>
<li>超级块：用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。当文件系统挂载时进入内存。</li>
<li>索引节点区：用来存储索引节点；当文件被访问时进入内存</li>
<li>数据块区：用来存储文件或目录数据；</li>
</ul>
<h2 id="文件的存放方式"><a href="#文件的存放方式" class="headerlink" title="文件的存放方式"></a>文件的存放方式</h2><p>连续空间存放方式<br>缺陷：「磁盘空间碎片」和「文件长度不易扩展」</p>
<p>非连续空间存放方式：「链表方式」和「索引方式」</p>
<p>「隐式链表」的方式存放<br>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置，</p>
<p><img data-src="/mybook.github.io/images/104654809258878.png"></p>
<p>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间。隐式链接分配的稳定性较差，系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失</p>
<p>「显式链接」的方式存放<br>它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘仅设置一张，每个表项中存放链接指针，指向下一个数据块号。</p>
<p><img data-src="/mybook.github.io/images/280175009246745.png"></p>
<p>缺点是不适用于大磁盘</p>
<p>「索引方式」</p>
<p>单索引</p>
<p><img data-src="/mybook.github.io/images/552165409256135.png"></p>
<p>链表 + 索引</p>
<p><img data-src="/mybook.github.io/images/437125409259580.png"></p>
<p>多级索引块</p>
<p><img data-src="/mybook.github.io/images/60975509251889.png"></p>
<h2 id="Unix和Linux-Ext-2-3"><a href="#Unix和Linux-Ext-2-3" class="headerlink" title="Unix和Linux Ext 2&#x2F;3"></a>Unix和Linux Ext 2&#x2F;3</h2><p><img data-src="/mybook.github.io/images/144745809269769.png"></p>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>适用于建立连续文件</p>
<p><img data-src="/mybook.github.io/images/527295909267373.png"></p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p><img data-src="/mybook.github.io/images/145370110264875.png"></p>
<h3 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h3><p>在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，</p>
<p>「位图 + 数据」<br>每位表示一个数据块，共可以表示 4 * 1024 * 8 &#x3D; 2^15 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 2^15 * 4 * 1024 &#x3D; 2^27 个 byte，也就是 128M。表示的大小过少，Linux使用块组结构</p>
<p><img data-src="/mybook.github.io/images/594342710246116.png"></p>
<ul>
<li>超级块，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</li>
<li>块组描述符，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。</li>
<li>数据位图和 inode 位图， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。</li>
<li>inode 列表，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</li>
<li>数据块，包含文件的有用数据。</li>
</ul>
<p>超级块和块组描述符表，这两个都是全局信息，而且非常的重要，这么做是有两个原因：<br>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。<br>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。</p>
<h2 id="目录的管理"><a href="#目录的管理" class="headerlink" title="目录的管理"></a>目录的管理</h2><p>目录文件的块里面保存的是目录里面一项一项的文件信息。</p>
<p><img data-src="/mybook.github.io/images/301453410268556.png"></p>
<h2 id="软链接-ln-s-和硬链接-ln-d）"><a href="#软链接-ln-s-和硬链接-ln-d）" class="headerlink" title="软链接(ln -s)和硬链接(ln -d）"></a>软链接(ln -s)和硬链接(ln -d）</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p> 多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode。<strong>每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的</strong>。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p>
<p><img data-src="/mybook.github.io/images/366183610263692.png"></p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p>
<p><img data-src="/mybook.github.io/images/234184310240902.png" alt="软链接"></p>
<h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I&#x2F;O"></a><font color="red">文件I&#x2F;O</font></h2><h3 id="缓冲与非缓冲-I-O"><a href="#缓冲与非缓冲-I-O" class="headerlink" title="缓冲与非缓冲 I&#x2F;O"></a>缓冲与非缓冲 I&#x2F;O</h3><p>文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I&#x2F;O 分为缓冲 I&#x2F;O 和非缓冲 I&#x2F;O：</p>
<ul>
<li>缓冲 I&#x2F;O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</li>
<li>非缓冲 I&#x2F;O，直接通过系统调用访问文件，不经过标准库缓存。<br>这里所说的「缓冲」特指标准库内部实现的缓冲。</li>
</ul>
<p>例如，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p>
<h3 id="直接与非直接-I-O"><a href="#直接与非直接-I-O" class="headerlink" title="直接与非直接 I&#x2F;O"></a>直接与非直接 I&#x2F;O</h3><p>我们都知道磁盘 I&#x2F;O 是非常慢的，所以 Linux 内核为了减少磁盘 I&#x2F;O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，<strong>这个内核缓存空间也就是「页缓存」（page cache），只有当缓存满足某些条件的时候，才发起磁盘 I&#x2F;O 的请求。</strong></p>
<p>那么，根据是「否利用操作系统的缓存」，可以把文件 I&#x2F;O 分为直接 I&#x2F;O 与非直接 I&#x2F;O：</p>
<p>直接 I&#x2F;O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。<br>非直接 I&#x2F;O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。</p>
<p><strong>非直接I&#x2F;O下，什么时候刷盘？</strong></p>
<ol>
<li>在调用 write 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上；</li>
<li>用户主动调用 sync，内核缓存会刷到磁盘上；</li>
<li>当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；</li>
<li>内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；</li>
</ol>
<h3 id="阻塞与非阻塞I-O"><a href="#阻塞与非阻塞I-O" class="headerlink" title="阻塞与非阻塞I&#x2F;O"></a>阻塞与非阻塞I&#x2F;O</h3><p>阻塞等待的是<strong>内核数据准备好</strong> 和 <strong>数据从内核态拷贝到用户态</strong>这两个过程</p>
<p><img data-src="/mybook.github.io/images/422510511240452.png"></p>
<p>非阻塞 I&#x2F;O，非阻塞的 read 请求在数据未准备好的情况下<strong>立即返回，可以继续往下执行</strong>，此时应用程序不断<strong>轮询内核</strong>，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。<br>最后一次 read 调用，获取数据的过程，<strong>是一个同步的过程，是需要等待的过程</strong>。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</p>
<p><img data-src="/mybook.github.io/images/253940811258878.png"></p>
<h3 id="同步与异步-I-O"><a href="#同步与异步-I-O" class="headerlink" title="同步与异步 I&#x2F;O"></a>同步与异步 I&#x2F;O</h3><p>使用 select I&#x2F;O 多路复用过程。注意，read 获取数据的过程（数据从内核态拷贝到用户态的过程），也是<strong>一个同步的过程</strong>，需要等待</p>
<p><img data-src="/mybook.github.io/images/375061511246745.png"></p>
<p>是否阻塞一般指的是进程、线程状态，是否异步一般指的是是否依赖其它任务已经完成</p>
<ul>
<li>如果这个进程、线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞；</li>
<li>如果这个进程、线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞；</li>
</ul>
<p>所以，<strong>阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用都是同步调用</strong>。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。</p>
<p>异步I&#x2F;O：</p>
<p><img data-src="/mybook.github.io/images/421221711266911.png"></p>
<h3 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h3><p>信号驱动式I&#x2F;O是指进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。当数据报到达时触发SIGIO信号，该信号通知数据已经到来，并没有将数据都入到应用程序的buffer中。因此，还需要我们在SIGIO信号处理函数中，手动的读取到来的数据，将其存放在buffer中。</p>
<p><img data-src="/mybook.github.io/images/551232711258987.png"></p>
<p><strong>总结</strong></p>
<p><img data-src="/mybook.github.io/images/206442911246854.png"></p>
<h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p>非直接I&#x2F;O中，内核会找个合适的时机，将 page cache 中的数据持久化到磁盘。但是如果 page cache 里的文件数据，在持久化到磁盘化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。</p>
<p>当然， 我们也可以在程序里调用 fsync 函数，在写文文件的时候，立刻将文件数据持久化到磁盘，这样就可以解决系统崩溃导致的文件数据丢失的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/meminfo</span><br><span class="line"></span><br><span class="line">Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached</span><br></pre></td></tr></table></figure>
<p>Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。</p>
<h3 id="文件持久化的一致性-可靠性"><a href="#文件持久化的一致性-可靠性" class="headerlink" title="文件持久化的一致性&amp;可靠性"></a>文件持久化的一致性&amp;可靠性</h3><p>当前 Linux 下以两种方式实现文件一致性：</p>
<p>Write Through（写穿）：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；<br>Write back（写回）：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fsync(intfd)</td>
<td align="center">fsync(fd)：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。</td>
</tr>
<tr>
<td align="center">fdatasync(int fd)</td>
<td align="center">fdatasync(fd)：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息</td>
</tr>
<tr>
<td align="center">sync()</td>
<td align="center">sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中</td>
</tr>
</tbody></table>
<ul>
<li>关于多线程的架构问题，Linux 内核采取了 Lighthttp 的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。</li>
<li>管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。</li>
<li>而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。</li>
</ul>
<p>刷新线程刷新设备上脏页面大致设计如下：<br>每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；</p>
<p>系统中存在多个回写时机:</p>
<ol>
<li>第一是应用程序主动调用回写接口（fsync，fdatasync 以及 sync 等）</li>
<li>第二管理线程周期性地唤醒设备上的回写线程进行回写</li>
<li>第三是某些应用程序&#x2F;内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要。</li>
</ol>
<h2 id="Swap详解"><a href="#Swap详解" class="headerlink" title="Swap详解"></a>Swap详解</h2><p>操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为<strong>缺页中断</strong>，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。</p>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><p><img data-src="/mybook.github.io/images/106675315259580.png"></p>
<h2 id="I-O-控制⽅式"><a href="#I-O-控制⽅式" class="headerlink" title="I&#x2F;O 控制⽅式"></a>I&#x2F;O 控制⽅式</h2><ol>
<li>轮询等待<br>让 CPU ⼀直查寄存器的状态，直到状态标记为完成，很明显，这种⽅式⾮常的傻⽠，它会占⽤ CPU 的全部时间。</li>
<li>中断<br>通知操作系统数据已经准备好了。我们⼀般会有⼀个硬件的中断控制器，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，⼀个中断产⽣了，CPU 需要停下当前⼿⾥的事情来处理中断。<br>另外，中断有两种，⼀种软中断，例如代码调⽤ INT 指令触发，⼀种是硬件中断，就是硬件通过中断控制器触发的。<br>但中断的⽅式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占⽤CPU ⼤量的时间。对于这⼀类设备的问题的解决⽅法是使⽤ DMA功能，它可以使得设备在 CPU 不参与的情况下，能够⾃⾏完成把设备 I&#x2F;O 数据放⼊到内存。那要实现 DMA 功能要有 「DMA 控制器」硬件的⽀持。</li>
</ol>
<h2 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a><font color="red">DMA技术</font></h2><p>实现了文件I&#x2F;O的第一道流程</p>
<p>在进⾏ I&#x2F;O 设备和内存的数据传输的时候，数据搬运的⼯作全部交给 DMA 控制器，⽽ CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</p>
<p><img data-src="/mybook.github.io/images/3320624841468.png"></p>
<ol>
<li>⽤户进程调⽤ read ⽅法，向操作系统发出 I&#x2F;O 请求，请求读取数据到⾃⼰的内存缓冲区中，进程进⼊阻塞状态；</li>
<li>操作系统收到请求后，进⼀步将 I&#x2F;O 请求发送 DMA，然后让 CPU 执⾏其他任务；</li>
<li>DMA 进⼀步将 I&#x2F;O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I&#x2F;O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知⾃⼰缓冲区已满；</li>
<li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷⻉到内核缓冲区中，此时不占⽤CPU，CPU 可以执⾏其他任务；</li>
<li>当 DMA 读取了⾜够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷⻉到⽤户空间，系统调⽤返回；</li>
</ol>
<h2 id="传统文件传输"><a href="#传统文件传输" class="headerlink" title="传统文件传输"></a>传统文件传输</h2><p>两个系统调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span>(file, tmp_buf, len);</span><br><span class="line"><span class="built_in">write</span>(socket, tmp_buf, len);</span><br></pre></td></tr></table></figure>

<p>4 次用户态与内核态的上下文切换， 4 次数据拷贝</p>
<p><img data-src="/mybook.github.io/images/324970016256135.png"></p>
<h2 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a><font color="red">零拷贝技术</font></h2><ul>
<li>要想提⾼⽂件传输的性能，就需要<strong>减少⽤户态与内核态的上下⽂切换</strong>和<strong>内存拷贝</strong>的次数。</li>
</ul>
<ol>
<li>方案一：<br>mmap（见上文共享内存） + write</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">buf = <span class="built_in">mmap</span>(file, len);</span><br><span class="line"><span class="built_in">write</span>(sockfd, buf, len);</span><br></pre></td></tr></table></figure>
<p>mmap() 系统调用函数会直接把内核缓冲区里的数据「映射」到用户空间，可以减少一次数据拷贝，但是需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次，3次数据拷贝</p>
<p><img data-src="/mybook.github.io/images/165871416251889.png"></p>
<ol start="2">
<li>方案二：<br>sendfile();</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">//前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</span></span><br></pre></td></tr></table></figure>
<p>只有 2 次上下文切换，和 3 次数据拷贝</p>
<p><img data-src="/mybook.github.io/images/515381916269769.png"></p>
<ol start="3">
<li>方案三（真正的零拷贝）：<br>网卡需支持SG-DMA技术<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ethtool -k eth0 | grep scatter-gather</span></span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img data-src="/mybook.github.io/images/3305717821354.png"></p>
<ol>
<li>通过 DMA 将磁盘上的数据拷⻉到内核缓冲区⾥；</li>
<li>缓冲区描述符和数据⻓度传到 socket 缓冲区，这样⽹卡的 SG-DMA 控制器就可以<strong>直接将内核缓存中的数据拷⻉到⽹卡的缓冲区⾥</strong>，此过程不需要将数据从操作系统内核缓冲区拷⻉到 socket 缓冲区中，这样就减少了⼀次数据拷⻉；</li>
</ol>
<p><strong>零拷⻉技术的⽂件传输⽅式相⽐传统⽂件传输的⽅式，减少了 2 次上下⽂切换和数据拷⻉次数，只需要 2 次上下⽂切换和数据拷⻉次数，就可以完成⽂件的传输，⽽且 2 次的数据拷⻉过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p><strong>零拷贝技术的应用：Kafka、Nginx、Java NIO 库里的 transferTo方法</strong></p>
<h2 id="理想的文件传输方式"><a href="#理想的文件传输方式" class="headerlink" title="理想的文件传输方式"></a>理想的文件传输方式</h2><p>传输⽂件的时候，我们要根据⽂件的⼤⼩来使⽤不同的⽅式：<br>传输⼤⽂件的时候，使⽤「异步 I&#x2F;O + 直接 I&#x2F;O」；<br>传输⼩⽂件的时候，则使⽤「零拷⻉技术」；</p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 实现多路复⽤的⽅式是，将已连接的 Socket 都放到⼀个⽂件描述符集合，然后调⽤select 函数<mark>将⽂件描述符集合拷⻉到内核⾥</mark>，让内核来检查是否有⽹络事件产⽣，检查的⽅式很粗暴，就是<mark>通过遍历</mark>⽂件描述符集合的⽅式，当检查到有事件产⽣后，将此 Socket 标记为可读或可写， 接着<mark>再把整个⽂件描述符集合拷⻉回⽤户态⾥</mark>，然后⽤户态还需要<mark>再通过遍历</mark>的⽅法找到可读或可写的 Socket，然后再对其处理。</p>
<p>所以，对于 select 这种⽅式，需要进行2 次「遍历」⽂件描述符集合，⼀次是在内核态⾥，⼀个次是在⽤户态⾥ ，⽽且还会发⽣ 2 次「拷⻉」⽂件描述符集合，先从⽤户空间传⼊内核空间，由内核修改后，再传出到⽤户空间中。<br>select 使⽤固定⻓度的 BitsMap，表示⽂件描述符集合，⽽且所⽀持的⽂件描述符的个数是有限制的。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 不再⽤ BitsMap 来存储所关注的⽂件描述符，取⽽代之⽤<mark>动态数组，以链表形式来组织</mark>，突破了 select 的⽂件描述符个数限制，当然还会受到系统⽂件描述符限制。<br>但是 poll 和 select 并没有太⼤的本质区别，都是使⽤<strong>线性结构</strong>存储进程关注的 Socket集合，因此都需要遍历⽂件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，⽽且也需要在⽤户态与内核态之间拷⻉⽂件描述符集合，这种⽅式随着并发数上来，性能的损耗会呈指数级增⻓。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">bind</span>(s, ...);</span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(...);</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">epoll_wait</span>(...);</span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123;</span><br><span class="line">        <span class="comment">//处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表。</p>
<ul>
<li>第⼀点，<mark>epoll 在内核⾥使⽤红⿊树来跟踪进程所有待检测的⽂件描述字</mark>，把需要监控的socket 通过 epoll_ctl() 函数加⼊内核中的红⿊树⾥，红⿊树是个⾼效的数据结构，<mark>增删查⼀般时间复杂度是 O(logn)</mark> ，通过对这棵⿊红树进⾏操作，这样就不需要像 select&#x2F;poll 每次操作时都传⼊整个 socket 集合，只需要传⼊⼀个待检测的 socket，<mark>减少了内核和⽤户空间⼤量的数据拷贝和内存分配</mark></li>
<li>第⼆点， epoll 使⽤事件驱动的机制，内核⾥维护了⼀个链表来记录就绪事件，当某个socket 有事件发⽣时，通过回调函数内核会将其加⼊到这个就绪事件列表中，当⽤户调⽤epoll_wait() 函数时，只会返回有事件发⽣的⽂件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，⼤⼤提⾼了检测的效率。</li>
<li>第三点，使用__put_user 函数，将数据从内核拷贝到用户空间，而非共享内存</li>
</ul>
<p><img data-src="/mybook.github.io/images/118080312240551.png"></p>
<h4 id="两种事件触发模式"><a href="#两种事件触发模式" class="headerlink" title="两种事件触发模式"></a>两种事件触发模式</h4><ul>
<li>边缘触发模式(ET)，当被监控的 Socket 描述符上有可读事件发⽣时，<mark>服务器端只会从epoll_wait 中苏醒⼀次</mark>，即使进程没有调⽤ read 函数从内核读取数据，也依然只苏醒⼀次，因此我们程序要保证⼀次性将内核缓冲区的数据读取完；</li>
<li>⽔平触发模式(LT)，当被监控的 Socket 上有可读事件发⽣时，<mark>服务器端不断地从epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</mark>，⽬的是告诉我们有数据需要读取；</li>
</ul>
<p>如果使⽤边缘触发模式，在收到通知后应尽可能地读写数据，以免错失读写的机会。如果是阻塞的，没有数据可读写时，进程会<mark>阻塞</mark>在读写函数那⾥，程序就没办法继续往下执⾏。<mark>所以，边缘触发模式⼀般和⾮阻塞 I&#x2F;O 搭配使⽤，</mark>程序会⼀直执⾏ I&#x2F;O 操作，直到系统调⽤（如 read 和 write ）返回错误，错误类型为EAGAIN 或 EWOULDBLOCK 。</p>
<p>⼀般来说，边缘触发的效率⽐⽔平触发的效率要⾼,因为边缘触发可以减少 epoll_wait 的系统调⽤次数，系统调⽤也是有⼀定的开销的的，毕竟也存在上下⽂的切换。</p>
<h4 id="ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？"><a href="#ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？" class="headerlink" title="ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？"></a>ET和LT模式各自应用场景是什么？为什么有了高效的ET还需要LT？</h4><ol>
<li>LT的编程更符合用户直觉，业务层逻辑更简单，不易出错，但效率较低；</li>
<li>ET的编程可以做到更加简洁，某些场景下更加高效，但另一方面容易遗漏事件，容易产生bug；</li>
<li>对于nginx这种高性能服务器，ET模式是很好的，Redis使用的是LT，避免使用的过程中出现bug；</li>
<li>当并发量比较小时，比较推荐LT，因为LT模式下应用的读写逻辑比较简单，不容易遗漏事件，代码不易出错好维护，而且性能损失不大。当并发量非常大时，推荐使用ET模式，可以有效提升EPOLL效率。</li>
</ol>
<h1 id="其它知识"><a href="#其它知识" class="headerlink" title="其它知识"></a>其它知识</h1><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><ol>
<li>什么是shell？</li>
</ol>
<ul>
<li>shell是linux的一个外壳，它包在linux内核的外面，为用户和内核之间的交互提供了一个接口。</li>
<li>当用户下达指令给该操作系统的时候，实际上是把指令告诉shell，经过shell解释，处理后让内核做出相应的动作。</li>
<li>系统的回应和输出的信息也由shell处理，然后显示在用户的屏幕上</li>
</ul>
<ol start="2">
<li>为什么使用shell脚本？</li>
</ol>
<ul>
<li>适合处理操作系统底层的业务，有众多系统命令为其做支撑（还有文本处理三兄弟：grep，sed，awk）</li>
<li>适合处理纯文本文件，linux中许多服务配置文件，启动脚本，都是纯文本文件（如：httpd，nfs，mysql，nginx，lvs）</li>
<li>linux系统脚本用shell开发更简单，简言之，shell脚本操作更加方便，快捷，高效。</li>
</ul>
<ol start="3">
<li>shell脚本与编程语言的区别？</li>
</ol>
<ul>
<li>shell脚本是能运行的文本，它包含命令和运行逻辑关系 。与C语言、C++、C#等编程语言不同。</li>
<li>shell脚本不需要编译、连接及生成可执行文件，直接由相应的解释器（最常用的解释器为bash） 解释执行即可。</li>
<li>它的优点是可批量，多次执行（使用）。简言之，shell脚本是解释性语言，而c语言则是编译性语言。</li>
</ul>
<h2 id="Handle"><a href="#Handle" class="headerlink" title="Handle"></a>Handle</h2><p><strong>句柄</strong></p>
<p><img data-src="/mybook.github.io/images/2535111169068.png">       <img data-src="/mybook.github.io/images/3580711156935.png"></p>
<p>Windows是一个以虚拟内存为基础的操作系统，进程的代码和数据并不全部装入内存，进程的某一段装入内存后，还可能被换出到外存，当再次需要时，再装入内存。两次装入的地址绝大多数情况下是不一样的。</p>
<p>系统为每个进程在内存中分配一定的区域，用来存放各个句柄，即一个个无符号整型。每个无符号整型值相当于一个指针，指向内存中的另一个区域A。而区域A中存放的正是对象在内存中的地址。<mark>当对象在内存中的位置发生变化时，区域A的值被更新，变为当前时刻对象在内存中的地址，而在这个过程中，区域A的位置以及对应句柄的值是不发生变化的。</mark></p>
<ol>
<li>所谓“唯一”、“不变”是指在程序的一次运行中。如果本次运行完，关闭程序，再次启动程序运行，那么这次运行中，同一对象的句柄的值和上次运行时比较，一般是不一样的。</li>
<li>句柄是对象生成时系统指定的，属性是只读的，程序员不能修改句柄。</li>
<li>不同的系统中，句柄的大小（字节数）是不同的，可以使用sizeof()来计算句柄的大小。</li>
<li>通过句柄，程序员只能调用系统提供的服务（即API调用），不能像使用指针那样，做其它的事。</li>
</ol>
<h2 id="Linux网络传输"><a href="#Linux网络传输" class="headerlink" title="Linux网络传输"></a>Linux网络传输</h2><h3 id="Linux-接收⽹络包的流程"><a href="#Linux-接收⽹络包的流程" class="headerlink" title="Linux 接收⽹络包的流程"></a>Linux 接收⽹络包的流程</h3><ul>
<li>⽹卡是计算机⾥的⼀个硬件，专⻔负责接收和发送⽹络包，当⽹卡接收到⼀个⽹络包后，会通过 DMA 技术，将⽹络包放⼊到 Ring Buffer，这个是⼀个环形缓冲区。</li>
<li>Linux 内核在 2.6 版本中引⼊了 NAPI 机制，它是混合「中断和轮询」的⽅式来接收⽹络包，它的核⼼概念就是<mark>不采⽤中断的⽅式读取数据</mark>，⽽是⾸先<mark>采⽤中断唤醒数据接收的服务程序</mark>，然后 poll 的⽅法来轮询数据</li>
<li>⽐如，当有⽹络包到达时，⽹卡发起硬件中断，于是会执⾏⽹卡硬件中断处理函数，中断处理函数处理完需要「暂时屏蔽中断」，然后唤醒「软中断」来轮询处理数据，直到没有新数据时才恢复中断，这样⼀次中断处理多个⽹络包，于是就可以降低⽹卡中断带来的性能开销。</li>
</ul>
<h3 id="高性能网络模式：Reactor-和-Proactor"><a href="#高性能网络模式：Reactor-和-Proactor" class="headerlink" title="高性能网络模式：Reactor 和 Proactor"></a>高性能网络模式：Reactor 和 Proactor</h3><h4 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h4><h5 id="1-单-Reactor-单进程-线程"><a href="#1-单-Reactor-单进程-线程" class="headerlink" title="1. 单 Reactor 单进程 &#x2F; 线程"></a>1. 单 Reactor 单进程 &#x2F; 线程</h5><p><img data-src="/mybook.github.io/images/53424515240561.png"></p>
<p>Reactor 对象的作用是监听和分发事件；Acceptor 对象的作用是获取连接；Handler 对象的作用是处理业务；对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。</p>
<ul>
<li>Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch 进⾏分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li>
<li>如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理，Acceptor 对象会通过 accept⽅法 获取连接，并创建⼀个 Handler 对象来处理后续的响应事件；</li>
<li>如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应；Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li>
<li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程</li>
</ul>
<p>但是，这种方案存在 2 个缺点：</p>
<ol>
<li>因为只有一个进程，无法充分利用 多核 CPU 的性能；</li>
<li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟；<br><strong>所以，单 Reactor 单进程的方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景。</strong></li>
</ol>
<h5 id="2-单-Reactor-多线程-多进程"><a href="#2-单-Reactor-多线程-多进程" class="headerlink" title="2. 单 Reactor 多线程 &#x2F; 多进程"></a>2. 单 Reactor 多线程 &#x2F; 多进程</h5><p><img data-src="/mybook.github.io/images/323594515258987.png"></p>
<ul>
<li>Reactor 对象通过 select （IO 多路复⽤接⼝） 监听事件，收到事件后通过 dispatch 进⾏分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</li>
<li>如果是连接建⽴的事件，则交由 Acceptor 对象进⾏处理，Acceptor 对象会通过 accept⽅法 获取连接，并创建⼀个 Handler 对象来处理后续的响应事件；</li>
<li>如果不是连接建⽴事件， 则交由当前连接对应的 Handler 对象来进⾏响应；</li>
<li>Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给⼦线程⾥的 Processor 对象进⾏业务处理；</li>
<li>⼦线程⾥的 Processor 对象就进⾏业务处理，处理完后，将结果发给主线程中的 Handler对象，接着由 Handler 通过 send ⽅法将响应结果发送给 client；</li>
</ul>
<p>「单 Reactor」的模式能够充分利用多核 CPU 的能，但是有个问题，因为⼀个 Reactor 对象承担所有事件的监听和响应，⽽且只在主线程中运⾏，在⾯对瞬间⾼并发的场景时，容易成为性能的瓶颈的地⽅。</p>
<h5 id="3-多-Reactor-多进程-线程"><a href="#3-多-Reactor-多进程-线程" class="headerlink" title="3. 多 Reactor 多进程 &#x2F; 线程"></a>3. 多 Reactor 多进程 &#x2F; 线程</h5><p><img data-src="/mybook.github.io/images/386655415246854.png"></p>
<ul>
<li>主线程中的 MainReactor 对象通过 select 监控连接建⽴事件，收到事件后通过 Acceptor对象中的 accept 获取连接，将新的连接分配给某个⼦线程；</li>
<li>⼦线程中的 SubReactor 对象将 MainReactor 对象分配的连接加⼊ select 继续进⾏监听，并创建⼀个 Handler ⽤于处理连接的响应事件。</li>
<li>如果有新的事件发⽣时，SubReactor 对象会调⽤当前连接对应的 Handler 对象来进⾏响应。</li>
<li>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</li>
<li>主线程和⼦线程分⼯明确，主线程只负责接收新连接，⼦线程负责完成后续的业务处理。</li>
<li>主线程和⼦线程的交互很简单，主线程只需要把新连接传给⼦线程，⼦线程⽆须返回数据，直接就可以在⼦线程将处理结果发送给客户端。</li>
</ul>
<p>Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异</p>
<h4 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h4><ul>
<li>Reactor 是⾮阻塞同步⽹络模式，感知的是就绪可读写事件。在每次感知到有事件发⽣（⽐如可读就绪事件）后，就需要应⽤进程主动调⽤ read ⽅法来完成数据的读取，也就是要应⽤进程主动将 socket 接收缓存中的数据读到应⽤进程内存中，这个过程是同步的，读取完数据后应⽤进程才能处理数据。</li>
<li>Proactor 是异步⽹络模式， 感知的是已完成的读写事件。在发起异步读写请求时，需要传⼊数据缓冲区的地址（⽤来存放结果数据）等信息，这样系统内核才可以⾃动帮我们把数据的读写⼯作完成，这⾥的读写⼯作全程由操作系统来做，并不需要像 Reactor 那样还需要应⽤进程主动发起 read&#x2F;write 来读写数据，操作系统完成读写⼯作后，就会通知应⽤进程直接处理数据。</li>
</ul>
<p><img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/mybook.github.io/2024/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="OSI七层模型-TCP-IP五层网络模型"><a href="#OSI七层模型-TCP-IP五层网络模型" class="headerlink" title="OSI七层模型&amp;TCP&#x2F;IP五层网络模型"></a>OSI七层模型&amp;TCP&#x2F;IP五层网络模型</h1><p><img data-src="/mybook.github.io/images/4214940125131.png"></p>
<p><img data-src="/mybook.github.io/images/399031810246845.png"></p>
<p><strong>传输层，给应⽤数据前⾯增加了 TCP 头；⽹络层，给 TCP 数据包前⾯增加了 IP 头；⽹络接⼝层，给 IP 数据包前后分别增加了帧头和帧尾；</strong><br><strong>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。</strong></p>
<h1 id="输入网址到网页显示，期间发生了什么？"><a href="#输入网址到网页显示，期间发生了什么？" class="headerlink" title="输入网址到网页显示，期间发生了什么？"></a>输入网址到网页显示，期间发生了什么？</h1><p><img data-src="/mybook.github.io/images/520723210259680.png"></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><strong>解析URL</strong><br>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 &#x2F;index.html 或者 &#x2F;default.html</p>
<p><img data-src="/mybook.github.io/images/16953510256235.png"></p>
<p><strong>生成HTTP请求</strong></p>
<p><img data-src="/mybook.github.io/images/398233710251989.png"></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a><span id="target7">DNS</span></h2><p>在这一流程中，<strong>需要查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。在域名中，越靠右的位置表示其层级越高。</p>
<ul>
<li>根 DNS 服务器（.）</li>
<li>顶级域 DNS 服务器（.com）</li>
<li>权威 DNS 服务器（server.com）</li>
</ul>
<p><img data-src="/mybook.github.io/images/186484410269869.png"></p>
<p>DNS 域名解析，只指路不带路。浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。</p>
<p>流程示例：<br>客户端-&gt;缓存-&gt;本地DNS服务器-&gt;根域服务器(.)-&gt;顶级域名服务器(.com)-&gt;权威DNS服务器(server.com)</p>
<p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。</p>
<p><img data-src="/mybook.github.io/images/589825710267473.png"></p>
<h2 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h2><p>如果 HTTP 请求消息比较长，超过了<strong>MSS(TCP 最大报文段长度)</strong> ，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）</p>
<p><img data-src="/mybook.github.io/images/411031010258978.png"></p>
<p>至此，网络报文如图：</p>
<p><img data-src="/mybook.github.io/images/483730811241294.png"></p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><span id="target5"></span><br>网络层负责将数据从一个设备传输到另一个设备，该如何找到对方呢？因此，网络层需要有区分设备的编号。一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。</p>
<p>因此，需要将 IP 地址分成两种意义：</p>
<ul>
<li>一个是网络号，负责标识该 IP 地址是属于哪个「子网」的；</li>
<li>一个是主机号，负责标识同一「子网」下的不同主机；</li>
</ul>
<p>那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。</p>
<p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06（十六进制），表示协议为 TCP</p>
<p><img data-src="/mybook.github.io/images/240855510268045.png"></p>
<p>IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 <strong>MTU(以太网中一般为 1500 字节)</strong> 就会再次进行分片，得到一个即将发送到网络的 IP 报文。</p>
<p><img data-src="/mybook.github.io/images/471094610250257.png"></p>
<p>至此，网络报文如图：</p>
<p><img data-src="/mybook.github.io/images/146291011252832.png"></p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。</p>
<p><img data-src="/mybook.github.io/images/442861411243551.png"></p>
<p>电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</p>
<p>IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，<strong>可以通过 ARP 协议获取对方的 MAC 地址。</strong><span id="target6"></span></p>
<p><img data-src="/mybook.github.io/images/557811511262706.png"></p>
<p>ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p>
<p>操作系统会把本次查询结果放到一块叫做 ARP 缓存的内存空间留着以后用，不过缓存的时间就几分钟。在发包时先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</p>
<p>一般在 TCP&#x2F;IP 通信里，MAC 包头的协议类型只使用：0800 ： IP 协议，0806 ： ARP 协议</p>
<p>至此，网络报文如图：</p>
<p><img data-src="/mybook.github.io/images/189722011242358.png"></p>
<h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，<strong>在末尾加上用于检测错误的帧校验序列</strong>。</p>
<p><img data-src="/mybook.github.io/images/291732611240804.png"></p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为二层网络设备。<strong>交换机的端口不具有 MAC 地址</strong>。交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p>
<p>交换机的 MAC 地址表主要包含两个信息：<br>一个是设备的 MAC 地址，另一个是该设备连接在交换机的哪个端口上。</p>
<p><img data-src="/mybook.github.io/images/352223211270622.png"></p>
<p>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口，如果交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。</p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器是基于 IP 设计的，俗称三层网络设备，<strong>路由器的各个端口都具有 MAC 地址和 IP 地址</strong>；<br>而交换机是基于以太网设计的，俗称二层网络设备，<strong>交换机的端口不具有 MAC 地址</strong>。</p>
<p>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p>
<p><strong>完成包接收操作之后，路由器就会去掉包开头的 MAC 头部</strong>。MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。</p>
<p><img data-src="/mybook.github.io/images/72064011249556.png"></p>
<p>根据路由表的网关列判断对方的地址。<br>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。<br>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。</p>
<p>在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的</strong>，一直变化的是 MAC 地址，<strong>因为需要 MAC 地址在以太网内进行两个设备之间的包传输</strong>。</p>
<h2 id="服务器与客户端"><a href="#服务器与客户端" class="headerlink" title="服务器与客户端"></a>服务器与客户端</h2><p><img data-src="/mybook.github.io/images/322135509240558.png"></p>
<h1 id="远程定位—-IP"><a href="#远程定位—-IP" class="headerlink" title="远程定位—-IP"></a>远程定位—-IP</h1><h2 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h2><p><img data-src="/mybook.github.io/images/159985015260239.png"></p>
<p>A、B、C 分类对应的地址范围、最大主机个数：</p>
<p><img data-src="/mybook.github.io/images/416630416255292.png"></p>
<p>如何计算最大主机个数，就是要看主机号的位数，C类为 2^8 - 2 &#x3D; 254，</p>
<p><img data-src="/mybook.github.io/images/495735315245968.png"></p>
<p>减去两个：主机号全为 1 指定某个网络下的所有主机，用于广播，主机号全为 0 指定某个网络</p>
<p><strong>缺点：</strong></p>
<ol>
<li><p>同一网络下没有地址层次，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。</p>
</li>
<li><p>不能很好的与现实网络匹配。C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</p>
</li>
</ol>
<h2 id="无分类地址CIDR"><a href="#无分类地址CIDR" class="headerlink" title="无分类地址CIDR"></a>无分类地址CIDR</h2><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。<a href="#target5">点击此处跳转到IP地址划分参考</a></p>
<p>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于网络号， x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。比如 10.100.122.2&#x2F;24，这种地址表示形式就是 CIDR，**&#x2F;24 表示前 24 位是网络号，剩余的 8 位是主机号。**</p>
<p><img data-src="/mybook.github.io/images/497681016242390.png"></p>
<h2 id="子网掩码VLSM"><a href="#子网掩码VLSM" class="headerlink" title="子网掩码VLSM"></a>子网掩码VLSM</h2><p>子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。<br>配合子网掩码才能算出 IP 地址 的网络号和主机号。10.100.122.0&#x2F;24，后面的&#x2F;24表示就是 255.255.255.0 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，为了简化子网掩码的表示，用&#x2F;24代替255.255.255.0。将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号</p>
<p><img data-src="/mybook.github.io/images/326012516266188.png"></p>
<p>子网掩码还有一个作用，那就是划分子网。<strong>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</strong></p>
<p><img data-src="/mybook.github.io/images/93032516260433.png"></p>
<p><strong>网络地址 192.168.1.0，使用子网掩码 255.255.255.192 对其进行子网划分。要划分4个子网，且每个子网可容纳55台主机：</strong></p>
<ol>
<li>计算子网号：2^n−2≥55，得n &#x3D; 6 （此时可容纳62台主机，题目只需55台）,从 8 位主机号中借用 2 位作为子网号。</li>
</ol>
<p><img data-src="/mybook.github.io/images/421843316266820.png"></p>
<ol start="2">
<li><p>由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11，具体划分如下图：</p>
</li>
<li><p><img data-src="/mybook.github.io/images/319113416257556.png"></p>
</li>
<li><p>最终结果如图</p>
</li>
</ol>
<p><img data-src="/mybook.github.io/images/45433616250415.png"></p>
<h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><p>IPv4 的地址是 32 位的，大约可以提供 42 亿个地址，但是早在 2011 年 IPv4 地址就已经被分配完了。<br>IPv6 的地址是 128 位的，IPv6 可以保证地球上的每粒沙子都能被分配到一个 IP 地址。</p>
<p><img data-src="/mybook.github.io/images/134550616252059.png"></p>
<p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段</strong>。 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片&#x2F;重新组装相关字段</strong>。 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段</strong>。 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。</li>
</ul>
<h2 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h2><p><a href="#target7">点击此处跳转到DNS</a></p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>ARP ⽤于根据 IP 地址查询相应的以太⽹ MAC 地址。在传输⼀个 IP 数据报的时候，确定了源 IP 地址和⽬标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下⼀跳。然⽽，⽹络层的下⼀层是数据链路层，所以我们还要知道「下⼀跳」的 MAC 地址，所以可以通过 ARP 协议，求得下⼀跳的 MAC 地址。<br><a href="#target6">点击此处跳转到ARP协议</a></p>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>路由器常用</p>
<p><img data-src="/mybook.github.io/images/500414010271844.png"></p>
<p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。可以发现，DHCP 交互中，全程都是使用 UDP 广播通信。</p>
<p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p>
<ul>
<li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li>
<li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li>
</ul>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。<br>普通的 NAT 转换没什么意义。由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。因此，可以把 IP 地址 + 端口号一起进行转换（网络地址与端口转换 NAPT）。</p>
<p><img data-src="/mybook.github.io/images/212873810264333.png"></p>
<p>图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。此时，两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。</p>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>互联⽹控制报⽂协议。ICMP 主要的功能包括：<strong>确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善⽹络设置等。</strong></p>
<p>ICMP ⼤致可以分为两⼤类：</p>
<ol>
<li>⼀类是⽤于诊断的查询消息，也就是「查询报⽂类型」</li>
<li>另⼀类是通知出错原因的错误消息，也就是「差错报⽂类型」</li>
</ol>
<p><img data-src="/mybook.github.io/images/5537494615604.png"></p>
<p>在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。</p>
<p><img data-src="/mybook.github.io/images/153575516269224.png"></p>
<h2 id="ping的工作原理"><a href="#ping的工作原理" class="headerlink" title="ping的工作原理"></a>ping的工作原理</h2><p>ping 命令执⾏的时候，源主机⾸先会构建⼀个 ICMP<br>ICMP 数据包内包含多个字段，最重要的是两个：</p>
<ul>
<li>第⼀个是类型，对于回送请求消息⽽⾔该字段为 8 ；</li>
<li>另外⼀个是序号，主要⽤于区分连续 ping 的时候发出的多个数据包。<br>每发出⼀个请求数据包，序号会⾃动加 1 。为了能够计算往返时间 RTT ，它会在报⽂的数据部分插⼊发送时间。<br><img data-src="/mybook.github.io/images/1489291806710.png"><br><img data-src="/mybook.github.io/images/3501300595802.png"></li>
</ul>
<p><img data-src="/mybook.github.io/images/1454719219187.png"></p>
<h1 id="可靠传输—-TCP和UDP"><a href="#可靠传输—-TCP和UDP" class="headerlink" title="可靠传输—-TCP和UDP"></a>可靠传输—-TCP和UDP</h1><h2 id="UDP与TCP比较"><a href="#UDP与TCP比较" class="headerlink" title="UDP与TCP比较"></a>UDP与TCP比较</h2><table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连接</td>
<td align="center">面向连接</td>
<td align="center">不需要连接，即刻传输</td>
</tr>
<tr>
<td align="center">服务对象</td>
<td align="center">一对一</td>
<td align="center">一对一、一对多、多对多</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">可靠交付数据，数据可以无差错、不丢失、不重复、按序到达</td>
<td align="center">尽最大努力交付数据，不保证可靠交付数据</td>
</tr>
<tr>
<td align="center">拥塞控制、流量控制</td>
<td align="center">有</td>
<td align="center">没有</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">没有使用「选项」字段时是 20 个字节，较长</td>
<td align="center">8 个字节，较小</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">流式传输,保证顺序和可靠</td>
<td align="center">一个包一个包的发送，有边界，可能丢包和乱序</td>
</tr>
<tr>
<td align="center">分片不同</td>
<td align="center">大于MSS大小，在传输层进行分片，丢失了一个分片，只需要传输丢失的这个分片</td>
<td align="center">大于 MTU 大小在IP层进行分片</td>
</tr>
</tbody></table>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><p><img data-src="/mybook.github.io/images/1340921605603.png"></p>
<ol>
<li>⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。</li>
<li>包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。</li>
<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li>
</ol>
<h3 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h3><ol>
<li><strong>面向无连接</strong><br>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了<br>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
<li><strong>有单播，多播，广播的功能</strong><br>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</li>
<li><strong>UDP是面向报文的</strong><br>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</li>
<li><strong>不可靠性</strong><br>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</li>
<li><strong>头部开销小，传输数据报文时是很高效的</strong><br>因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的</li>
</ol>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img data-src="/mybook.github.io/images/2092909816511.png"></p>
<ol>
<li>序列号：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。⽤来解决⽹络包乱序问题。</li>
<li>确认应答号：指下⼀次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。⽤来解决丢包的问题。</li>
<li>头部长度:标识该TCP头部有多少个32bit字(4字节)。4位最大能表示15，所以TCP头部最长是60字节。</li>
<li>窗口大小：是TCP流量控制的一个手段。它告诉对方本段的TCP接受缓冲区的情况，控制对方的发送的速度。</li>
<li>校验和：由发送端填充，接收端对TCP报文端执行CRC算法以校验TCP报文段在传输过程是否损坏。(数据和头部全部校验的。)</li>
<li>紧急指针：发送端向接受端发送紧急数据使用的。</li>
<li>控制位：</li>
</ol>
<ul>
<li>URG：表示紧急指针是否有效</li>
<li>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。</li>
<li>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接</li>
<li>PSH：提示接收端应用程序应该立即从TCP接受缓冲区读走数据，为之后的接受的数据腾出位置。</li>
<li>SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。</li>
<li>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</li>
</ul>
<h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ol>
<li><strong>面向连接</strong><br>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</li>
<li><strong>仅支持单播传输</strong><br>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</li>
<li><strong>面向字节流</strong><br>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。<br>消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃。</li>
<li><strong>可靠传输</strong><br>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</li>
<li><strong>提供拥塞控制</strong><br>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</li>
<li><strong>TCP提供全双工通信</strong><br>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</li>
</ol>
<h3 id="TCP四元组"><a href="#TCP四元组" class="headerlink" title="TCP四元组"></a>TCP四元组</h3><p><strong>TCP 四元组可以唯一的确定一个连接</strong>，四元组包括如下：<br>源地址、源端口、目的地址、目的端口</p>
<p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。<br>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img data-src="/mybook.github.io/images/21412016243506.png"></p>
<ol>
<li>服务端主动监听某个端口，处于 LISTEN 状态</li>
<li>客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。</li>
</ol>
<p><img data-src="/mybook.github.io/images/232160215268656.png"></p>
<ol start="3">
<li>服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。</li>
</ol>
<p><img data-src="/mybook.github.io/images/391953015263792.png"></p>
<ol start="4">
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。</li>
</ol>
<p><img data-src="/mybook.github.io/images/354023115257338.png"></p>
<ol start="5">
<li>服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。</li>
</ol>
<p>从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的。</p>
<h4 id="TCP-半连接和全连接队列"><a href="#TCP-半连接和全连接队列" class="headerlink" title="TCP 半连接和全连接队列"></a>TCP 半连接和全连接队列</h4><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<p>半连接队列，也称 SYN 队列；<br>全连接队列，也称 accept 队列；</p>
<p>服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。</p>
<p><img data-src="/mybook.github.io/images/137551216255655.png"></p>
<h5 id="全连接队列满了会发生什么"><a href="#全连接队列满了会发生什么" class="headerlink" title="全连接队列满了会发生什么"></a>全连接队列满了会发生什么</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ss -lnt</span><br></pre></td></tr></table></figure>

<p>当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。</p>
<p><img data-src="/mybook.github.io/images/473141516248225.png"></p>
<p>实际上，丢弃连接只是 Linux 的默认行为，我们还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_abort_on-overflow</span></span><br><span class="line">0    #默认值为0</span><br></pre></td></tr></table></figure>
<p>0 ：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ；<br>1 ：如果全连接队列满了，server 发送一个 reset 包给 client，表示废掉这个握手过程和这个连接；</p>
<p>如果要想知道客户端连接不上服务端，是不是服务端 TCP 全连接队列满的原因，那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 connection reset by peer 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。</p>
<p><strong>但是通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量</strong>。当 TCP 全连接队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建立好的连接上发送请求。只要服务器没有为请求回复 ACK，请求就会被多次重发。如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，<strong>再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接</strong>。</p>
<p>TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值</p>
<ul>
<li>somaxconn默认值是 128，Linux 内核参数：&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</li>
<li>backlog 是 listen(int sockfd, int backlog) 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度；</li>
</ul>
<h5 id="半连接队列满了会发生什么"><a href="#半连接队列满了会发生什么" class="headerlink" title="半连接队列满了会发生什么"></a>半连接队列满了会发生什么</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -natp | grep SYN_RECV | wc -l</span><br></pre></td></tr></table></figure>









<h4 id="为什么不是两次握手或四次握手？"><a href="#为什么不是两次握手或四次握手？" class="headerlink" title="为什么不是两次握手或四次握手？"></a>为什么不是两次握手或四次握手？</h4><h5 id="防止旧的重复连接初始化造成混乱-主要原因）"><a href="#防止旧的重复连接初始化造成混乱-主要原因）" class="headerlink" title="防止旧的重复连接初始化造成混乱(主要原因）"></a>防止旧的重复连接初始化造成混乱(主要原因）</h5><p>若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。<br>如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 RST 报⽂，以此中⽌历史连接；<br>如果不是历史连接，则第三次发送的报⽂是 ACK 报⽂，通信双⽅就会成功建⽴连接；</p>
<p><img data-src="/mybook.github.io/images/504923715250472.png"></p>
<p>如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。因此，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接:</p>
<p><img data-src="/mybook.github.io/images/334995315241002.png"></p>
<p>如果客户端第三次发送的ACK丢了，会发生什么</p>
<h5 id="同步双⽅的初始序列号"><a href="#同步双⽅的初始序列号" class="headerlink" title="同步双⽅的初始序列号"></a>同步双⽅的初始序列号</h5><p>当客户端发送携带「初始序列号」的 SYN 报⽂的时候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样⼀来⼀回，才能确保双⽅的初始序列号能被可靠的同步。序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；</li>
</ul>
<p><img data-src="/mybook.github.io/images/323262616252453.png"></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<h5 id="可以避免资源浪费"><a href="#可以避免资源浪费" class="headerlink" title="可以避免资源浪费"></a>可以避免资源浪费</h5><p>假设采用“两次握手”，服务端重复接受无用的连接请求 SYN 报文。服务端不清楚客户端是否收到了自己发送的建立连接的 ACK 确认报文，所以每收到一个 SYN 就只能先主动建立一个连接，而造成重复分配资源</p>
<h4 id="第一次握手失败，会发生什么"><a href="#第一次握手失败，会发生什么" class="headerlink" title="第一次握手失败，会发生什么"></a>第一次握手失败，会发生什么</h4><p>如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由 tcp_syn_retries内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_syn_retries</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。</p>
<h4 id="第二次握手丢失了，会发生什么"><a href="#第二次握手丢失了，会发生什么" class="headerlink" title="第二次握手丢失了，会发生什么"></a>第二次握手丢失了，会发生什么</h4><p>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。<br>如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 tcp_synack_retries内核参数决定，默认值是 5。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_synack_retries</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>因此，当第二次握手丢失了，客户端和服务端都会重传</strong></p>
<h4 id="第三次握手丢失了，会发生什么"><a href="#第三次握手丢失了，会发生什么" class="headerlink" title="第三次握手丢失了，会发生什么"></a>第三次握手丢失了，会发生什么</h4><p>第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。<br><strong>注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。</strong></p>
<h4 id="什么是-SYN-攻击？如何避免-SYN-攻击？"><a href="#什么是-SYN-攻击？如何避免-SYN-攻击？" class="headerlink" title="什么是 SYN 攻击？如何避免 SYN 攻击？"></a>什么是 SYN 攻击？如何避免 SYN 攻击？</h4><p><img data-src="/mybook.github.io/images/319484809245340.png"></p>
<p>假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务端不能为正常用户服务。</p>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃，导致客户端无法和服务端建立连接。</p>
<p><strong>避免 SYN 攻击方式：</strong></p>
<ol>
<li><p>无效连接监视释放<br>这种方法不停监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p>
</li>
<li><p>调大 netdev_max_backlog；<br>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.core.netdev_max_backlog = 10000</span><br></pre></td></tr></table></figure></li>
<li><p>增大 TCP 半连接队列；<br>要同时增大下面这三个参数：<br>增大 net.ipv4.tcp_max_syn_backlog<br>增大 listen() 函数中的 backlog<br>增大 net.core.somaxconn</p>
</li>
<li><p><span id="target4">开启 tcp_syncookies，延缓任务控制块（TCB）分配方法</span>；<br>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。0 值，表示关闭该功能；1 值，表示仅当 SYN 半连接队列放不下时，再启用它；2 值，表示无条件开启功能；<br><img data-src="/mybook.github.io/images/385275809245949.png"></p>
</li>
</ol>
<p>当 「 SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，<strong>计算出一个 cookie 值；将 cookie 值放到第二次握手报文的「序列号」里</strong>，然后服务端回第二次握手给客户端；服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「 Accept 队列」。最后应用程序通过调用 accpet() 接口，从「 Accept 队列」取出的连接。</p>
<ol start="5">
<li><p>减少 SYN+ACK 重传次数<br>当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN+ACK ，当重传超过次数达到上限后，就会断开连接。<br>可以减少 SYN-ACK 的重传次数，以加快处于 SYN_REVC 状态的 TCP 连接断开。</p>
</li>
<li><p>使用SYN Proxy防火墙<br>因此很多防火墙中都提供一种SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行。</p>
</li>
</ol>
<h4 id="SYN-报文什么时候情况下会被丢弃"><a href="#SYN-报文什么时候情况下会被丢弃" class="headerlink" title="SYN 报文什么时候情况下会被丢弃?"></a>SYN 报文什么时候情况下会被丢弃?</h4><p>SYN 报文被丢弃的两种场景：</p>
<ol>
<li>开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃</li>
</ol>
<ul>
<li>tcp_timestamps 选项开启之后， PAWS 机制会自动开启，它的作用是防止 TCP 包中的序列号发生绕回。<a href="#target2">点击此处跳转到TCP时间戳和序列号回绕(PAWS)</a></li>
<li><strong>tcp_tw_recycle 在使用了 NAT 的网络下是不安全的</strong>！对于服务器来说，如果同时开启了recycle 和 timestamps 选项，则会开启一种称之为「 per-host 的 PAWS 机制」。per-host 是对「对端 IP 做 PAWS 检查」，而非对「IP + 端口」四元组做 PAWS 检查。</li>
<li>如果客户端网络环境是用了 NAT 网关，那么<strong>客户端环境的每一台机器通过 NAT 网关后，都会是相同的 IP 地址</strong>，在服务端看来，就好像只是在跟一个客户端打交道一样，无法区分出来。当客户端 A 通过 NAT 网关和服务器建立 TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，客户端 B 也通过 NAT 网关和服务器建立 TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT 网关，所以是用相同的 IP 地址与服务端建立 TCP 连接，<strong>如果客户端 B 的 timestamp 比 客户端 A 的 timestamp 小，那么由于服务端的 per-host 的 PAWS 机制的作用，服务端就会丢弃客户端主机 B 发来的 SYN 包。tcp_tw_recycle 在 Linux 4.12 版本后，直接取消了这一参数。</strong></li>
</ul>
<ol start="2">
<li>TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃</li>
</ol>
<h4 id="已建立连接的TCP，收到SYN会发生什么？"><a href="#已建立连接的TCP，收到SYN会发生什么？" class="headerlink" title="已建立连接的TCP，收到SYN会发生什么？"></a>已建立连接的TCP，收到SYN会发生什么？</h4><p>如果客户端掉线了，服务器不知道，客户端再上线的时候发起了SYN握手，服务器如何应对？</p>
<ol>
<li><p>客户端的 SYN 报文里的端口号与历史连接不相同<br>此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。那旧连接里处于 Established 状态的服务端最后会怎么样呢？<br>如果服务端发送了数据包给客户端，由于客户端的连接已经被关闭了，此时客户的内核就会回 RST 报文，服务端收到后就会释放连接。如果服务端一直没有发送数据包给客户端，在超过一段时间后，TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</p>
</li>
<li><p>客户端的 SYN 报文里的端口号与历史连接相同<br><strong>处于 Established 状态的服务端，如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接</strong>。<br>RFC 793 文档里的第 34 页里，有说到这个例子。</p>
</li>
</ol>
<p><img data-src="/mybook.github.io/images/58691818266061.png"></p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img data-src="/mybook.github.io/images/584384110255117.png"></p>
<p><img data-src="/mybook.github.io/images/513040811240805.png"></p>
<p>服务端在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，<strong>这个 EOF 会被放在已排队等候的其他已接收的数据之后</strong>，所以必须要得继续 read 接收缓冲区已接收的数据；</p>
<p>当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，这时服务端就会发一个 FIN 包</strong>，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；</p>
<p><strong>是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序</strong>，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，</p>
<h4 id="为什么挥手需要四次？"><a href="#为什么挥手需要四次？" class="headerlink" title="为什么挥手需要四次？"></a>为什么挥手需要四次？</h4><ul>
<li>关闭连接时，客户端向服务端发送 FIN 时，<strong>仅仅表示客户端不再发送数据了但是还能接收数据</strong>。</li>
<li>服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<h5 id="可以变成三次挥手吗？"><a href="#可以变成三次挥手吗？" class="headerlink" title="可以变成三次挥手吗？"></a>可以变成三次挥手吗？</h5><p><strong>但是在特定情况下，四次挥手是可以变成三次挥手的</strong>，能不能把第二次的 ACK 报文， 放到第三次 FIN 报文一起发送？</p>
<p><img data-src="/mybook.github.io/images/236384910244415.png"></p>
<p>「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</p>
<h5 id="TCP延迟确认"><a href="#TCP延迟确认" class="headerlink" title="TCP延迟确认"></a>TCP延迟确认</h5><ul>
<li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li>
<li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li>
<li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li>
</ul>
<p><img data-src="/mybook.github.io/images/333440611240666.png"></p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_DELACK_MAX	((unsigned)(HZ/5))	<span class="comment">/* maximal time to delay before sending an ACK */</span></span></span><br><span class="line"><span class="built_in">static_assert</span>((<span class="number">1</span> &lt;&lt; ATO_BITS) &gt; TCP_DELACK_MAX);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HZ &gt;= 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_DELACK_MIN	((unsigned)(HZ/25))	<span class="comment">/* minimal time to delay before sending an ACK */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lepos@apptest132 boot]$ cat /boot/config-3.10.0-693.el7.x86_64 | grep &#x27;CONFIG_HZ=&#x27;</span><br><span class="line">CONFIG_HZ=1000</span><br></pre></td></tr></table></figure>
<p>最大延迟确认时间是 200 ms，最短延迟确认时间是 40 ms</p>
<p>如果要关闭 TCP 延迟确认机制，可以在 Socket 设置里启用 TCP_QUICKACK。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 表示开启 TCP_QUICKACK，即关闭 TCP 延迟确认机制</span></span><br><span class="line"><span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(socketfd, IPPROTO_TCP, TCP_QUICKACK, (<span class="type">char</span>*)&amp; value, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>


<h4 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h4><p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 tcp_orphan_retries 参数控制。</p>
<ul>
<li><font color="BlueGreen">当客户端超时重传已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</font></li>
</ul>
<h4 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h4><p><strong>ACK 报文是不会重传的</strong>，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<ul>
<li><font color="BlueGreen">当客户端超时重传已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</font></li>
</ul>
<h4 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h4><p>内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<ul>
<li><font color="YellowGreen">服务端重传第三次挥手报文的次数达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</font></li>
<li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout （默认值是 60 秒）时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</li>
</ul>
<h4 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h4><p><strong>ACK 报文是不会重传的</strong>，如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。</p>
<ul>
<li><font color="YellowGreen">服务端重传第三次挥手报文的次数达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</font></li>
<li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，<strong>当等待 2MSL 时长后，客户端就会断开连接</strong>。</li>
</ul>
<h4 id="粗暴关闭vs优雅关闭"><a href="#粗暴关闭vs优雅关闭" class="headerlink" title="粗暴关闭vs优雅关闭"></a>粗暴关闭vs优雅关闭</h4><h5 id="close函数–粗暴关闭"><a href="#close函数–粗暴关闭" class="headerlink" title="close函数–粗暴关闭"></a>close函数–粗暴关闭</h5><p>同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</p>
<p>如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，<strong>这时就不会经历完成的 TCP 四次挥手，所以调用 close 是粗暴的关闭</strong>。<br>当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p>
<ul>
<li>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。</li>
<li>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</li>
</ul>
<p><img data-src="/mybook.github.io/images/185051015257934.png"></p>
<h5 id="shutdown函数–优雅关闭"><a href="#shutdown函数–优雅关闭" class="headerlink" title="shutdown函数–优雅关闭"></a>shutdown函数–优雅关闭</h5><p>可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程&#x2F;多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。<br>shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，<strong>然后就会经历完整的 TCP 四次挥手，所以调用 shutdown 是优雅的关闭</strong>。</p>
<p><img data-src="/mybook.github.io/images/11861215259229.png"></p>
<h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>MSL(最大分段生存期)，指明TCP报文在Internet上最长生存时间，每个具体的TCP实现都必须选择一个确定的MSL值</p>
<p>因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。<br><strong>MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡</strong>。TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着<strong>Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT </span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    state, about 60 seconds  */</span></span></span><br></pre></td></tr></table></figure>
<h5 id="TIME-WAIT的作用"><a href="#TIME-WAIT的作用" class="headerlink" title="TIME_WAIT的作用"></a>TIME_WAIT的作用</h5><ol>
<li>保证「被动关闭连接」的一方，能被正确的关闭<br>如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会触发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。<br>2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端⼜接收到了服务端重发的 FIN 报⽂，那么 2MSL 时间将重新计时。<strong>可以看到 2MSL时长，这其实是相当于至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<br>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。</li>
</ol>
<p><img data-src="/mybook.github.io/images/597362314252895.png"></p>
<ol start="2">
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收<br>在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身 ，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，<strong>因为TIME_WAIT状态持续2MSL，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong><br>例如：服务端在关闭连接之前发送的 SEQ &#x3D; 301 报文，被网络延迟了。接着，服务端以相同的四元组重新打开了新连接，前面被延迟的 SEQ &#x3D; 301 这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。</li>
</ol>
<h5 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h5><p>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；第二是占用端口资源</p>
<h5 id="如何解决客户端-TCP-连接-TIME-WAIT-过多，导致无法与同一个服务器建立连接的问题？"><a href="#如何解决客户端-TCP-连接-TIME-WAIT-过多，导致无法与同一个服务器建立连接的问题？" class="headerlink" title="如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？"></a>如何解决客户端 TCP 连接 TIME_WAIT 过多，导致无法与同一个服务器建立连接的问题？</h5><p>如果客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。</p>
<h6 id="net-ipv4-tcp-tw-reuse"><a href="#net-ipv4-tcp-tw-reuse" class="headerlink" title="net.ipv4.tcp_tw_reuse"></a>net.ipv4.tcp_tw_reuse</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br></pre></td></tr></table></figure>
<p>开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。该选项只适用于连接发起方</p>
<p>举个例子，假设客户端已经与服务器建立了一个 TCP 连接，并且这个状态处于 TIME_WAIT 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">客户端地址:端口           服务端地址:端口         TCP 连接状态</span><br><span class="line">192.168.1.100:2222      172.19.11.21:8888     TIME_WAIT</span><br></pre></td></tr></table></figure>

<p>然后客户端又与该服务器（172.19.11.21:8888）发起了连接，在调用 connect 函数时，内核刚好选择了 2222 端口，接着发现已经被相同四元组的连接占用了：</p>
<ul>
<li>如果没有开启 net.ipv4.tcp_tw_reuse 内核参数，那么内核就会选择下一个端口，然后继续判断，直到找到一个没有被相同四元组的连接使用的端口， 如果端口资源耗尽还是没找到，那么 connect 函数就会返回错误。</li>
<li>如果开启了 net.ipv4.tcp_tw_reuse 内核参数，就会判断该四元组的连接状态是否处于 TIME_WAIT 状态，如果连接处于 TIME_WAIT 状态并且该状态持续的时间超过了 1 秒，那么就会重用该连接，于是就可以使用 2222 端口了，这时 connect 就会返回成功。</li>
</ul>
<p>再次提醒一次，开启了 net.ipv4.tcp_tw_reuse 内核参数，<strong>是客户端（连接发起方） 在调用 connect() 函数时才起作用</strong>，所以在服务端开启这个参数是没有效果的。</p>
<h6 id="net-ipv4-tcp-tw-recycle"><a href="#net-ipv4-tcp-tw-recycle" class="headerlink" title="net.ipv4.tcp_tw_recycle"></a>net.ipv4.tcp_tw_recycle</h6><p>如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收；<strong>慎用，NAT环境下会导致SYN被丢弃，且不安全</strong></p>
<p>要使得上面两个选项生效，有一个前提条件，就是要打开 TCP 时间戳，即 net.ipv4.tcp_timestamps&#x3D;1（默认即为 1)）。</p>
<h6 id="net-ipv4-tcp-max-tw-buckets"><a href="#net-ipv4-tcp-max-tw-buckets" class="headerlink" title="net.ipv4.tcp_max_tw_buckets"></a>net.ipv4.tcp_max_tw_buckets</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_max_tw_buckets</span><br></pre></td></tr></table></figure>
<p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置，这个方法比较暴力。</p>
<h6 id="程序中使用-SO-LINGER"><a href="#程序中使用-SO-LINGER" class="headerlink" title="程序中使用 SO_LINGER"></a>程序中使用 SO_LINGER</h6><p>设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">linger</span> so_linger;</span><br><span class="line">so_linger.l_onoff = <span class="number">1</span>;</span><br><span class="line">so_linger.l_linger = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="built_in">sizeof</span>(so_linger));</span><br></pre></td></tr></table></figure>
<p>如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。</p>
<p>《UNIX网络编程》：<strong>TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它。如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT。</strong></p>
<h5 id="服务器出现大量-TIME-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-TIME-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 TIME_WAIT 状态的原因有哪些？"></a>服务器出现大量 TIME_WAIT 状态的原因有哪些？</h5><p>什么场景下服务端会主动断开连接呢？</p>
<ol>
<li>HTTP 没有使用长连接（Keep-Alive）：<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p><strong>客户端禁用了 HTTP Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？</strong><br>当客户端禁用了 HTTP Keep-Alive，这时候 HTTP 请求的 header 就会有 Connection:close 信息，这时服务端在发完 HTTP 响应后，就会主动关闭连接。为什么要这么设计呢？HTTP 是请求-响应模型，发起方一直是客户端，HTTP Keep-Alive 的初衷是为客户端后续的请求重用连接，如果我们在某次 HTTP 请求-响应模型中，请求的 header 定义了 connection：close 信息，那不再重用这个连接的时机就只有在服务端了，所以我们在 HTTP 请求-响应这个周期的「末端」关闭连接是合理的。</p>
</li>
<li><p><strong>客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？</strong><br>当客户端开启了 HTTP Keep-Alive，而服务端禁用了 HTTP Keep-Alive，这时服务端在发完 HTTP 响应后，服务端也会主动关闭连接。为什么要这么设计呢？在服务端主动关闭连接的情况下，只要调用一次 close() 就可以释放连接，剩下的工作由内核 TCP 栈直接进行了处理，整个过程只有一次 syscall；<strong>如果是要求客户端关闭，则服务端在写完最后一个 response 之后需要把这个 socket 放入 readable 队列，调用 select &#x2F; epoll 去等待事件；然后调用一次 read() 才能知道连接已经被关闭，这其中是两次 syscall</strong>，多一次用户态程序被激活执行，而且 socket 保持时间也会更长。</p>
</li>
</ul>
<p>所以，根据大多数 Web 服务的实现，不管哪一方禁用了 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。都是由服务端主动关闭连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
<ol start="2">
<li><p>HTTP 长连接超时<br>为了避免资源浪费的情况，web 服务软件一般都会提供一个参数，用来指定 HTTP 长连接的超时时间，如 nginx 提供的 keepalive_timeout 参数。<br>假设设置了 HTTP 长连接的超时时间是 60 秒，nginx 就会启动一个「定时器」，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间一到，nginx 就会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。</p>
</li>
<li><p>HTTP 长连接的请求数量达到上限<br>Web 服务端通常会有个参数，来定义一条 HTTP 长连接上最大能处理的请求数量，当超过最大限制时，就会主动关闭连接。<br>比如 nginx 的 keepalive_requests 这个参数，这个参数是指一个 HTTP 长连接建立之后，nginx 就会为这个连接设置一个计数器，记录这个 HTTP 长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则 nginx 会主动关闭这个长连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接。<br>对于一些 QPS 比较高的场景，比如超过 10000 QPS，甚至达到 30000 , 50000 甚至更高，如果 keepalive_requests 参数值是 100，这时候<strong>nginx 就会很频繁地关闭连接，那么此时服务端上就会出大量的 TIME_WAIT 状态</strong>。</p>
</li>
</ol>
<h5 id="服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"><a href="#服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="headerlink" title="服务器出现大量 CLOSE_WAIT 状态的原因有哪些？"></a>服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h5><p>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。需要排查代码</p>
<p>一个普通的 TCP 服务端的流程：</p>
<ol>
<li>创建服务端 socket，bind 绑定端口、listen 监听端口</li>
<li>将服务端 socket 注册到 epoll</li>
<li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li>
<li>将已连接的 socket 注册到 epoll</li>
<li>epoll_wait 等待事件发生</li>
<li>对方连接关闭时，我方调用 close</li>
</ol>
<ul>
<li>第一个原因：第 2 步没有做，没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。不过这种原因发生的概率比较小，这种属于明显的代码逻辑 bug，在前期 read view 阶段就能发现的了。</li>
<li>第二个原因： 第 3 步没有做，有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。发生这种情况可能是因为服务端在执行 accpet 函数之前，代码卡在某一个逻辑或者提前抛出了异常。</li>
<li>第三个原因：第 4 步没有做，通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。发生这种情况可能是因为服务端在将已连接的 socket 注册到 epoll 之前，代码卡在某一个逻辑或者提前抛出了异常。</li>
<li>第四个原因：第 6 步没有做，当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</li>
</ul>
<h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h5><p>客户端的主机发生了宕机。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 ESTABLISH 状态，占用着系统资源。</p>
<p>为了避免这种情况，TCP使用保活机制：<br>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用。每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=<span class="number">7200</span> <span class="comment">//表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl=<span class="number">75</span>  <span class="comment">//表示每次检测间隔 75 秒</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes=<span class="number">9</span>  <span class="comment">//表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</span></span><br></pre></td></tr></table></figure>

<p>在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。我们可以自己在应用层实现一个心跳机制<br>tcp_keepalive_time + （tcp_keepalive_intvl * tcp_keepalive_probes）</p>
<p>如果开启了 TCP 保活，需要考虑以下几种情况：</p>
<ol>
<li>对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li>
<li>对端主机宕机并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产生一个 RST 报文，这样很快就会发现 TCP 连接已经被重置。</li>
<li>是对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</li>
</ol>
<h5 id="如果已经建立了连接，但是服务端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是服务端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是服务端突然出现故障了怎么办？"></a>如果已经建立了连接，但是服务端突然出现故障了怎么办？</h5><p>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</p>
<h4 id="四次挥手中收到乱序的-FIN-包会如何处理？"><a href="#四次挥手中收到乱序的-FIN-包会如何处理？" class="headerlink" title="四次挥手中收到乱序的 FIN 包会如何处理？"></a>四次挥手中收到乱序的 FIN 包会如何处理？</h4><p>客户端只调用shutdown关闭写的情况下，假如服务端二三次挥手之间发送的数据被阻塞了，导致FIN先到达客户端，会发生什么？</p>
<p>在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，<strong>那么就被会加入到「乱序队列」，这个队列的数据结构是红黑树</strong>，并不会进入到 TIME_WAIT 状态。</p>
<p>等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。</p>
<p><img data-src="/mybook.github.io/images/395313709268159.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_v4_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//根据四元组查找相应连接的socket结构</span></span><br><span class="line">	sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);</span><br><span class="line">	<span class="keyword">if</span> (!sk)</span><br><span class="line">		<span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//判断socket是否被user占用，如果没有占用，调用tcp_v4_do_rcv()</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">sock_owned_by_user</span>(sk)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">tcp_prequeue</span>(sk, skb))</span><br><span class="line">			ret = <span class="built_in">tcp_v4_do_rcv</span>(sk, skb);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//为了避免并发操作socket，将数据包放入backlog队列，放入失败或已满，丢弃数据包</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">unlikely</span>(<span class="built_in">sk_add_backlog</span>(sk, skb,</span><br><span class="line">					   sk-&gt;sk_rcvbuf + sk-&gt;sk_sndbuf))) &#123;</span><br><span class="line">		<span class="built_in">bh_unlock_sock</span>(sk);</span><br><span class="line">		<span class="built_in">NET_INC_STATS_BH</span>(net, LINUX_MIB_TCPBACKLOGDROP);</span><br><span class="line">		<span class="keyword">goto</span> discard_and_relse;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_v4_do_rcv</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">tcp_rcv_state_process</span>(sk, skb, <span class="built_in">tcp_hdr</span>(skb), skb-&gt;len)) &#123;</span><br><span class="line">		rsk = sk;</span><br><span class="line">		<span class="keyword">goto</span> reset;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shutdown 只关闭了写方向，所以会继续往下调用 tcp_data_queue 函数（因为 case TCP_FIN_WAIT2 代码块里并没有 break 语句，所以会走到该函数）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span></span><br><span class="line"><span class="params"><span class="function">			  <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">case</span> TCP_FIN_WAIT2:</span><br><span class="line">		<span class="comment">/* RFC 793 says to queue data in these states,</span></span><br><span class="line"><span class="comment">		 * RFC 1122 says we MUST send a reset.</span></span><br><span class="line"><span class="comment">		 * BSD 4.4 also does reset.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">TCP_SKB_CB</span>(skb)-&gt;end_seq != <span class="built_in">TCP_SKB_CB</span>(skb)-&gt;seq &amp;&amp;</span><br><span class="line">			    <span class="built_in">after</span>(<span class="built_in">TCP_SKB_CB</span>(skb)-&gt;end_seq - th-&gt;fin, tp-&gt;rcv_nxt)) &#123;</span><br><span class="line">				<span class="built_in">NET_INC_STATS_BH</span>(<span class="built_in">sock_net</span>(sk), LINUX_MIB_TCPABORTONDATA);</span><br><span class="line">				<span class="built_in">tcp_reset</span>(sk);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Fall through */</span></span><br><span class="line">	<span class="keyword">case</span> TCP_ESTABLISHED:</span><br><span class="line">		<span class="built_in">tcp_data_queue</span>(sk, skb);</span><br><span class="line">		queued = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tcp_data could move socket to TIME-WAIT */</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE) &#123;</span><br><span class="line">		<span class="built_in">tcp_data_snd_check</span>(sk);</span><br><span class="line">		<span class="built_in">tcp_ack_snd_check</span>(sk);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">tcp_data_queue</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">/*  Queue data for delivery to the user.</span></span><br><span class="line"><span class="comment">	 *  Packets in sequence go to the receive queue.</span></span><br><span class="line"><span class="comment">	 *  Out of sequence packets to the out_of_order_queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//如果报文的序列号是有序的</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">TCP_SKB_CB</span>(skb)-&gt;seq == tp-&gt;rcv_nxt) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">tcp_receive_window</span>(tp) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_of_window;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Ok. In sequence. In window. */</span></span><br><span class="line">		<span class="keyword">if</span> (tp-&gt;ucopy.task == current &amp;&amp;</span><br><span class="line">		    tp-&gt;copied_seq == tp-&gt;rcv_nxt &amp;&amp; tp-&gt;ucopy.len &amp;&amp;</span><br><span class="line">		    <span class="built_in">sock_owned_by_user</span>(sk) &amp;&amp; !tp-&gt;urg_data) &#123;</span><br><span class="line">			<span class="type">int</span> chunk = <span class="built_in">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, skb-&gt;len,</span><br><span class="line">					  tp-&gt;ucopy.len);</span><br><span class="line"></span><br><span class="line">			__set_current_state(TASK_RUNNING);</span><br><span class="line">...</span><br><span class="line">        <span class="comment">//如果有fin标识，会调用tcp_fin()</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">TCP_SKB_CB</span>(skb)-&gt;tcp_flags &amp; TCPHDR_FIN)</span><br><span class="line">			<span class="built_in">tcp_fin</span>(sk);</span><br><span class="line">        <span class="comment">//检查乱序队列有没有数据</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">skb_queue_empty</span>(&amp;tp-&gt;out_of_order_queue)) &#123;</span><br><span class="line">		    <span class="comment">//检查乱序队列中是否有数据包可用，即是否在乱序队列中找到与当前数据包保持序列号连续的数据包</span></span><br><span class="line">			<span class="built_in">tcp_ofo_queue</span>(sk);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* RFC2581. 4.2. SHOULD send immediate ACK, when</span></span><br><span class="line"><span class="comment">			 * gap in queue is filled.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">skb_queue_empty</span>(&amp;tp-&gt;out_of_order_queue))</span><br><span class="line">				<span class="built_in">inet_csk</span>(sk)-&gt;icsk_ack.pingpong = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">...</span><br><span class="line">		<span class="comment">/* If window is closed, drop tail of packet. But after</span></span><br><span class="line"><span class="comment">		 * remembering D-SACK for its head made in previous line.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">tcp_receive_window</span>(tp))</span><br><span class="line">			<span class="keyword">goto</span> out_of_window;</span><br><span class="line">		<span class="keyword">goto</span> queue_and_out;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果是乱序的，通过此函数加入乱序队列</span></span><br><span class="line">	<span class="built_in">tcp_data_queue_ofo</span>(sk, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://elixir.bootlin.com/linux/v3.19.8/source/net/ipv4/tcp_input.c#L4214">tcp_input.c&#x2F;tcp_data_queue_ofo()</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    //红黑树结构，有点复杂，自己研究</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在TIME-WAIT状态的-TCP-连接，收到-SYN-后会发生什么？"><a href="#在TIME-WAIT状态的-TCP-连接，收到-SYN-后会发生什么？" class="headerlink" title="在TIME_WAIT状态的 TCP 连接，收到 SYN 后会发生什么？"></a>在TIME_WAIT状态的 TCP 连接，收到 SYN 后会发生什么？</h4><p>在 TCP 正常挥手过程中，处于 TIME_WAIT 状态的连接，收到相同四元组的 SYN 后会发生什么？</p>
<p>针对这个问题，<strong>关键是要看 SYN 的「序列号和时间戳」是否合法</strong><br>合法 SYN：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要大，并且 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要大。<br>非法 SYN：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要小，或者 SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要小。</p>
<p><a href="#target2">点击此处跳转到TCP时间戳和序列号回绕(PAWS)</a></p>
<p>如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，<strong>就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态</strong>，接着就能进行建立连接过程。<br>如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，<strong>就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号，就回 RST 报文给服务端</strong>。</p>
<p>那么处于 TIME_WAIT 状态的连接，收到 RST 会断开连接吗？</p>
<p>net.ipv4.tcp_rfc1337 这个内核参数（默认情况是为 0）：<br>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。<br>如果这个参数设置为 1， 就会丢掉 RST 报文。</p>
<h3 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h3><p>TCP保活(KeepAlive)功能工作过程中，开启该功能的一端会发现对方处于以下四种状态之一：</p>
<ol>
<li><p>对方主机仍在工作，并且可以到达。此时请求端将保活计时器重置。如果在计时器超时之前应用程序通过该连接传输数据，计时器再次被设定为保活时间值。</p>
</li>
<li><p>对方主机已经崩溃，包括已经关闭或者正在重新启动。这时对方的TCP将不会响应。请求端不会接收到响应报文，并在经过保活时间间隔指定的时间后超时。超时前，请求端会持续发送探测报文，一共发送保活探测数指定次数的探测报文，如果请求端没有收到任何探测报文的响应，那么它将认为对方主机已经关闭，连接也将被断开。</p>
</li>
<li><p>客户主机崩溃并且已重启。在这种情况下，请求端会收到一个对其保活探测报文的响应，但这个响应是一个重置报文段RST，请求端将会断开连接。</p>
</li>
<li><p>对方主机仍在工作，但是由于某些原因不能到达请求端（例如网络无法传输，而且可能使用ICMP通知也可能不通知对方这一事实）。这种情况与状态2相同，因为TCP不能区分状态2与状态4，结果是都没有收到探测报文的响应。</p>
</li>
</ol>
<p>其存在以下两点主要弊端：</p>
<ol>
<li>在出现短暂的网络错误的时候，保活机制会使一个好的连接断开；</li>
<li>保活机制会占用不必要的带宽；</li>
</ol>
<h4 id="应用层自己实现的心跳包"><a href="#应用层自己实现的心跳包" class="headerlink" title="应用层自己实现的心跳包"></a>应用层自己实现的心跳包</h4><p>由应用程序自己发送心跳包来检测连接是否正常，大致的方法是：服务器在一个 Timer事件中定时 向客户端发送一个短小精悍的数据包，然后启动一个低级别的线程，在该线程中不断检测客户端的回应， 如果在一定时间内没有收到客户端的回应，即认为客户端已经掉线；同样，如果客户端在一定时间内没 有收到服务器的心跳包，则认为连接不可用。</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ol>
<li><p>TCP自带的KeepAlive使用简单，发送的数据包相比应用层心跳检测包更小，仅提供检测连接功能</p>
</li>
<li><p>应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用</p>
</li>
<li><p>应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息</p>
</li>
<li><p>KeepAlive仅代表连接保持着，而心跳包往往还代表客户端可正常工作</p>
</li>
</ol>
<h3 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h3><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p><img data-src="/mybook.github.io/images/289163016260231.png"></p>
<p>当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；<br>当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。<br>精确的测量超时时间 RTO 的值是非常重要的，这可让重传机制更高效。超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</p>
<p> Linux 是如何计算 RTO 的呢？估计往返时间，通常需要采样以下两个：</p>
<ol>
<li>需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。</li>
<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。</li>
</ol>
<p>RFC6289 建议使用以下的公式计算 RTO：</p>
<p><img data-src="/mybook.github.io/images/589313816260408.png"></p>
<p>其中 SRTT 是计算平滑的RTT ，DevRTR 是计算平滑的RTT 与 最新 RTT 的差距。<br>在 Linux 下，α &#x3D; 0.125，β &#x3D; 0.25， μ &#x3D; 1，∂ &#x3D; 4。别问怎么来的，问就是大量实验中调出来的。<br>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a><span id="target1">快速重传</span></h4><p>快速重传机制，它不以时间为驱动，而是以数据驱动重传。</p>
<p><img data-src="/mybook.github.io/images/53474316245960.png"></p>
<ul>
<li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li>
<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li>
<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li>
<li>发送端收到了三个 Ack &#x3D; 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</li>
<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>
</ul>
<p>此时会引出一个问题：只丢Seq2和Seq2、Seq3都丢失了，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢</p>
<h4 id="SACK-选择性确认"><a href="#SACK-选择性确认" class="headerlink" title="SACK(选择性确认)"></a>SACK(选择性确认)</h4><p>需要在 TCP 头部「选项」字段里加一个 SACK 的东西，<strong>它可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。<br>发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>
<p><img data-src="/mybook.github.io/images/95104917262239.png"></p>
<p>如果要支持 SACK，必须双方都要支持。在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h4 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h4><p>Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</p>
<ul>
<li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li>
<li>于是「接收方」发现数据是重复收到的，于是回了一个 SACK &#x3D; 3000<del>3500，告诉「发送方」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。</li>
<li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li>
</ul>
<p><img data-src="/mybook.github.io/images/154375917255284.png"></p>
<ul>
<li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li>
<li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li>
<li>所以「接收方」回了一个 SACK&#x3D;1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</li>
<li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li>
</ul>
<p><img data-src="/mybook.github.io/images/511880018252051.png"></p>
<p>D-SACK 有这么几个好处：</p>
<ol>
<li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li>
<li>可以知道是不是「发送方」的数据包被网络延迟了;</li>
<li>可以知道网络中是不是把「发送方」的数据包给复制了;</li>
</ol>
<p>在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启&#x2F;关闭这个功能（Linux 2.4 后默认打开）。</p>
<h4 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h4><p>发送方：在发送数据之前计算检验和，并进行校验和的填充。<br>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。<br>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p>
<p><img data-src="/mybook.github.io/images/1864845172004.png"></p>
<h4 id="停止等待"><a href="#停止等待" class="headerlink" title="停止等待"></a>停止等待</h4><p>停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组<br>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p>
<p><img data-src="/mybook.github.io/images/2651946189884.png"></p>
<h4 id="确认迟到"><a href="#确认迟到" class="headerlink" title="确认迟到"></a>确认迟到</h4><p><img data-src="/mybook.github.io/images/5192010194990.png"></p>
<ul>
<li>A收到重复的确认后，直接丢弃。</li>
<li>B收到重复的M1后，也直接丢弃重复的M1</li>
</ul>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。<strong>通常窗口的大小是由接收方的窗口大小来决定的</strong>。</p>
<h5 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h5><p>假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p>
<p><img data-src="/mybook.github.io/images/301740718242382.png"></p>
<h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><p><strong>发送方：#2 和 #3就是发送方的滑动窗口</strong><br>#1 是已发送并收到 ACK确认的数据<br>#2 是已发送但未收到 ACK确认的数据<br>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）<br>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）<br><strong>滑动窗口在被连续确认后才进行滑动</strong>，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则滑动窗口往右边移动5个字节，接下来 52</del>56 字节又变成了可用窗口，那么后续也就可以发送这5个字节的数据了。</p>
<p><img data-src="/mybook.github.io/images/450811110266181.png"></p>
<ul>
<li>SND.WND：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li>SND.UNA：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li>SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。<br>那么可用窗口大小的计算就可以是：<strong>可用窗口大小 &#x3D; SND.WND -（SND.NXT - SND.UNA）</strong></li>
</ul>
<p><strong>接收方：#2就是接收窗口</strong><br>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；<br>#3 是未收到数据但可以接收的数据；<br>#4 未收到数据并不可以接收的数据；</p>
<p><img data-src="/mybook.github.io/images/576241410266813.png"></p>
<ul>
<li>RCV.WND：表示接收窗口的大小，它会通告给发送方。</li>
<li>RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li>
</ul>
<p><img data-src="/mybook.github.io/images/341123510257549.png"></p>
<p><strong>思考丢包的情形？</strong><br><strong>为了防止丢包的情况产生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p>
<h6 id="TCP的”死锁”"><a href="#TCP的”死锁”" class="headerlink" title="TCP的”死锁”"></a>TCP的”死锁”</h6><p>当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p>
<p>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。<strong>如果持续计时器超时，就会发送窗口探测报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<h5 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h5><p>如果发送端为产生数据很慢的应用程序服务，例如一次产生一个字节。这个应用程序一次将一个字节的数据写入发送端的TCP的缓存。如果发送端的TCP没有特定的指令，它就产生只包括一个字节数据的报文段。结果有很多41字节的IP数据报就在互连网中传来传去。(大车拉少人)</p>
<p>就要同时解决两个问题就可以了：</p>
<ol>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ol>
<p>接收方策略如下:<br>当「窗口大小」小于 MSS 与 1&#x2F;2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。</p>
<p>发送方策略如下:<br>防止发送端的TCP逐个字节地发送数据。必须强迫发送端的TCP收集数据，然后用一个更大的数据块来发送。发送端的TCP要等待多长时间呢？如果它等待过长，它就会使整个的过程产生较长的时延。如果它的等待时间不够长，它就可能发送较小的报文段。</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</p>
<p>条件一：要等到窗口大小 &gt;&#x3D; MSS 并且 数据大小 &gt;&#x3D; MSS；<br>条件二：收到之前发送数据的 ack 回包；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 有数据要发送 &#123;</span><br><span class="line">    <span class="keyword">if</span> 可用窗口大小 &gt;= MSS <span class="keyword">and</span> 可发送的数据 &gt;= MSS &#123;</span><br><span class="line">    	立刻发送MSS大小的数据</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> 有未确认的数据 &#123;</span><br><span class="line">            将数据放入缓存等待接收ACK</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            立刻发送数据</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果接收方不能满足「不通告小窗口给发送方」，那么即使开了 Nagle 算法，也无法避免糊涂窗口综合症，因为如果对端 ACK 回复很快的话（达到 Nagle 算法的条件二），Nagle 算法就不会拼接太多的数据包，这种情况下依然会有小数据包的传输，网络总体的利用率依然很低。所以，<strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h5 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h5><p>拥塞窗口cwnd，发送窗口swnd<br>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。</p>
<p><img data-src="/mybook.github.io/images/520560911250408.png"></p>
<p>慢启动门限ssthresh状态变量。<br>当 cwnd &lt; ssthresh 时，使用慢启动算法。<br>当 cwnd &gt;&#x3D; ssthresh 时，就会使用「拥塞避免算法」。</p>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个<strong>拥塞窗口的阈值</strong>，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。<br>在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1</p>
<p><img data-src="/mybook.github.io/images/578581711264325.png"></p>
<h5 id="快速重传-1"><a href="#快速重传-1" class="headerlink" title="快速重传"></a>快速重传</h5><p><a href="#target1">点击此处跳转到快速重传</a></p>
<h5 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h5><p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。</p>
<p><img data-src="/mybook.github.io/images/208812611270847.png"></p>
<h3 id="高性能TCP"><a href="#高性能TCP" class="headerlink" title="高性能TCP"></a>高性能TCP</h3><h4 id="TCP快速连接"><a href="#TCP快速连接" class="headerlink" title="TCP快速连接"></a>TCP快速连接</h4><p>客户端在向服务端发起 HTTP GET 请求时，一个完整的交互过程，需要 2.5 个 RTT 的时延。<strong>由于第三次握手是可以携带数据的</strong>，这时如果在第三次握手发起 HTTP GET 请求，需要 2 个 RTT 的时延。</p>
<p><img data-src="/mybook.github.io/images/8723711258187.png"></p>
<p>在 Linux 3.7 内核版本中，提供了 TCP Fast Open 功能，内核参数：net.ipv4.tcp_fastopen，0-关闭；1-作为客户端使用 Fast Open 功能；2-作为服务端使用 Fast Open 功能；3-无论作为客户端还是服务器，都可以使用 Fast Open 功能这个功能可以减少 TCP 连接建立的时延。</p>
<p><img data-src="/mybook.github.io/images/591953711245178.png"></p>
<p>在第一次建立连接的时候，服务端在第二次握手产生一个 Cookie （已加密）并通过 SYN、ACK 包一起发给客户端，在下次请求的时候，<strong>客户端在 SYN 包带上 Cookie 发给服务端，就提前可以跳过三次握手的过程</strong>，因为 Cookie 中维护了一些信息，服务端可以从 Cookie 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；</p>
<h4 id="如何理解是-TCP-面向字节流协议"><a href="#如何理解是-TCP-面向字节流协议" class="headerlink" title="如何理解是 TCP 面向字节流协议"></a>如何理解是 TCP 面向字节流协议</h4><p>当消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是每个 UDP 报文就是一个用户消息的边界，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。<br>操作系统在收到 UDP 报文后，会将其插入到队列里，队列里的每一个元素就是一个 UDP 报文，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。</p>
<p><img data-src="/mybook.github.io/images/263713616268767.png"></p>
<p>当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。例如：”Hello World”、”Hello” + “ World”、”He”+”llo World”等各种情况，所以，我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议。</p>
<h4 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h4><p>如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这时接收方不知道消息的边界的话，是无法读出有效的消息。</p>
<h5 id="TCP发生粘包和拆包原因"><a href="#TCP发生粘包和拆包原因" class="headerlink" title="TCP发生粘包和拆包原因"></a>TCP发生粘包和拆包原因</h5><ol>
<li>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</li>
<li>待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</li>
<li>要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包</li>
</ol>
<h5 id="粘包的解决办法"><a href="#粘包的解决办法" class="headerlink" title="粘包的解决办法"></a>粘包的解决办法</h5><p>解决问题的关键在于<strong>如何给每个数据包添加边界信息</strong>，常用的方法有如下几个：</p>
<p>一般有三种方式分包的方式：</p>
<ol>
<li>固定长度的消息<br>规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。但是这种方式灵活性不高，实际中很少用。</li>
<li>特殊字符作为边界<br>HTTP 是一个非常好的例子。</li>
</ol>
<p><img data-src="/mybook.github.io/images/409224516247382.png"></p>
<ol start="3">
<li><p>自定义消息结构。<br>首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123; </span><br><span class="line">    <span class="type">u_int32_t</span> message_length; </span><br><span class="line">    <span class="type">char</span> message_data[]; </span><br><span class="line">&#125; message;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p>
</li>
</ol>
<h5 id="UDP协议是否会发生粘包问题"><a href="#UDP协议是否会发生粘包问题" class="headerlink" title="UDP协议是否会发生粘包问题"></a>UDP协议是否会发生粘包问题</h5><p>不会。UDP是基于报文发送的，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p>
<h4 id="有一个-IP-的服务端监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#有一个-IP-的服务端监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？"></a>有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？</h4><p>客户端 IP 和端口是可变的，最大TCP连接数 &#x3D; 客户端的 IP 数 * 客户端的端口数</p>
<p>对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，所以，服务端单机最大 TCP 连接数，约为 2 的 48 次方。</p>
<p>服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：</p>
<ul>
<li>文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<br>系统级：当前系统可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max 查看；<br>用户级：指定用户可打开的最大数量，通过 cat &#x2F;etc&#x2F;security&#x2F;limits.conf 查看；<br>进程级：单个进程可打开的最大数量，通过 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open 查看；</li>
<li>内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。</li>
</ul>
<h4 id="TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗？"></a>TCP 和 UDP 可以同时绑定相同的端口吗？</h4><p>可以，<strong>在操作系统的协议栈中，TCP和UDP是两个不同的模块</strong>，当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP&#x2F;UDP，所以可以根据这个信息确定送给哪个模块（TCP&#x2F;UDP）处理，送给 TCP&#x2F;UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<p><img data-src="/mybook.github.io/images/406574211246216.png"></p>
<h4 id="多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗？"></a>多个 TCP 服务进程可以绑定同一个端口吗？</h4><p><strong>如果两个 TCP 服务进程同时绑定的 IP 地址和端口都相同，那么执行 bind() 时候就会出错，错误是“Address already in use”。</strong></p>
<p>注意，如果 TCP 服务进程 A 绑定的地址是 0.0.0.0 和端口 8888，而如果 TCP 服务进程 B 绑定的地址是 192.168.1.100 地址（或者其他地址）和端口 8888，那么执行 bind() 时候也会出错。这是因为 0.0.0.0 地址比较特殊，代表任意地址，意味着绑定了 0.0.0.0 地址，相当于把主机上的所有 IP 地址都绑定了。</p>
<h4 id="重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？"><a href="#重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？" class="headerlink" title="重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？"></a>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</h4><p>TCP四次挥手后，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。</p>
<p>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。</p>
<p>如何解决：<br>对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="built_in">sizeof</span>(on));</span><br></pre></td></tr></table></figure>
<p>如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功。</p>
<h4 id="客户端的端口可以重复使用吗？"><a href="#客户端的端口可以重复使用吗？" class="headerlink" title="客户端的端口可以重复使用吗？"></a>客户端的端口可以重复使用吗？</h4><p>TCP 连接是由四元组（源IP地址，源端口，目的IP地址，目的端口）唯一确认的，那么<strong>只要四元组中其中一个元素发生了变化，那么就表示不同的 TCP 连接的</strong>。所以如果客户端已使用端口 64992 与服务端 A 建立了连接，那么客户端要与服务端 B 建立连接，还是可以使用端口 64992 的，因为内核是通过四元祖信息来定位一个 TCP 连接的，并不会因为客户端的端口号相同，而导致连接冲突的问题。</p>
<h4 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h4><ol>
<li><p>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；<br>如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。</p>
<p> <strong>已经有了TIME_WAIT 状态且持续 2 MSL 时长，历史报文不是早就消散了吗?</strong></p>
<blockquote>
<p>思考下面这种情况：</p>
</blockquote>
<p> 客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</p>
</li>
</ol>
<p>如果每次建立连接客户端和服务端的初始化序列号都「不一样」，<strong>就有大概率因为历史报文的序列号「不在」对方接收窗口</strong>，从而很大程度上避免了历史报文，如果每次的初始化序列号一样，在对方接收窗口的概率就会变大。而且TCP产生的随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<hr>
<p><span id="target2"><strong>但是也不是完全避免：</strong></span></p>
<blockquote>
<ul>
<li>序列号(SEQ)，是 TCP 一个头部字段，标识了 TCP 发送端到 TCP 接收端的数据流的一个字节，因为 TCP 是面向字节流的可靠协议，为了保证消息的顺序性和可靠性，TCP 为每个传输方向上的每个字节都赋予了一个编号，以便于传输成功后确认、丢失后重传以及在接收端保证不会乱序。序列号是一个 32 位的无符号数，<strong>因此在到达 4G 之后再循环回到 0</strong>。</li>
<li>初始序列号(ISN)，在 TCP 建立连接的时候，客户端和服务端都会各自生成一个初始序列号，它是基于时钟生成的一个随机数，来保证每个连接都拥有不同的初始序列号。初始化序列号可被视为一个 32 位的计数器，该计数器的数值每 4 微秒加 1，<strong>循环一次需要 4.55 小时</strong>。</li>
</ul>
</blockquote>
<p><strong>序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况</strong>，这意味着无法根据序列号来判断新老数据。为了解决这个问题，就需要有 TCP 时间戳。tcp_timestamps 参数是默认开启的，开启了 tcp_timestamps 参数，TCP 头部就会使用时间戳选项，它有两个好处，<strong>一个是便于精确计算 RTT ，另一个是能防止序列号回绕（PAWS）</strong>。<br>在开启 tcp_timestamps 选项情况下，一台机器发的所有 TCP 包都会带上发送时的时间戳，PAWS 要求连接双方维护最近一次收到的数据包的时间戳（Recent TSval），每收到一个新数据包都会读取数据包中的时间戳值跟 Recent TSval 值做比较，<strong>如果发现收到的数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包</strong>。</p>
<ol start="2">
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ol>
<h4 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</h4><p><img data-src="/mybook.github.io/images/444213610272904.png"></p>
<p>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。<strong>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</strong><br>为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，<strong>当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</strong><br>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</p>
<p><strong>UDP层的分片</strong></p>
<blockquote>
<ol>
<li>由于UDP是不需要保证可靠性的，那么它就不会保存发送的数据包，TCP之所以保存发送的数据包是因为要进行重传。所以UDP本身是没有像TCP一样的发送缓冲区的。这就导致了对UDP进行write系统调用的时候，实际上应用层的数据是直接传输到IP层，由于IP层本身也不会有缓冲区，数据就会直接写到链路层的输出队列中。</li>
<li>在这种情况下，IP层会不会对来自UDP的数据进行分片呢？这个取决于UDP数据报的大小。如果UDP数据报的大小大于链路层的MTU，那么IP层就会直接进行分片，然后在发送到链路层的输出队列中，反之，则不会进行分片，直接加上IP头部发送到链路层的输出队列中。</li>
</ol>
</blockquote>
<p><img data-src="/mybook.github.io/images/2871612129098.png"></p>
<h4 id="TCP-连接，一端断电和进程崩溃有什么区别？"><a href="#TCP-连接，一端断电和进程崩溃有什么区别？" class="headerlink" title="TCP 连接，一端断电和进程崩溃有什么区别？"></a>TCP 连接，一端断电和进程崩溃有什么区别？</h4><p>在没有开启 TCP keepalive，且双方一直没有数据交互的情况下，如果客户端的「主机崩溃」了，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p>
<p>进程崩溃，在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手。</p>
<p>有数据传输的场景：</p>
<ol>
<li>客户端主机宕机，又迅速重启<br>只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。</li>
<li>客户端主机宕机，一直没有重启<br>这种情况，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/net/ipv4/tcp_retries2</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>内核会根据 tcp_retries2 设置的值，计算出一个 timeout，如果重传间隔超过这个 timeout，则认为超过了阈值，就会停止重传，然后就会断开 TCP 连接。</p>
<h4 id="拔掉网线后，-原本的-TCP-连接还存在吗？"><a href="#拔掉网线后，-原本的-TCP-连接还存在吗？" class="headerlink" title="拔掉网线后， 原本的 TCP 连接还存在吗？"></a>拔掉网线后， 原本的 TCP 连接还存在吗？</h4><p>存在，TCP在内核中以struct socket结构体存在，当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。所以拔网线的动作不会影响TCP的状态<br>后续：</p>
<ol>
<li><p>拔掉网线后，有数据传输，触发超时重传机制<br>如果在服务端重传报文的过程中，客户端刚好把网线插回去了，无事发生。<br>如果在服务端重传报文的过程中，客户端一直没有将网线插回去，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。而等客户端插回网线后，如果客户端向服务端发送了数据，由于服务端已经没有与客户端相同四元祖的 TCP 连接了，因此服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。</p>
</li>
<li><p>拔掉网线后，没有数据传输<br>如果没有开启 TCP keepalive 机制，在客户端拔掉网线后，那么客户端和服务端的 TCP 连接将会一直保持存在。<br>如果开启了 TCP keepalive 机制，对端主机宕机，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，没有响应连续几次，达到保活探测次数后，TCP 会报告该连接已经死亡。</p>
</li>
</ol>
<h4 id="为什么-tcp-tw-reuse-默认是关闭的？"><a href="#为什么-tcp-tw-reuse-默认是关闭的？" class="headerlink" title="为什么 tcp_tw_reuse 默认是关闭的？"></a>为什么 tcp_tw_reuse 默认是关闭的？</h4><p>问题一：因为快速复用 TIME_WAIT 状态的端口，导致新连接可能<strong>被回绕序列号的 RST 报文断开了</strong>，而如果不跳过 TIME_WAIT 状态，而是停留 2MSL 时长，那么这个 RST 报文就不会出现下一个新的连接。</p>
<p><img data-src="/mybook.github.io/images/225572615273177.png"></p>
<p>前面被网络延迟 RST 报文这时抵达了客户端，而且 RST 报文的序列号在客户端的接收窗口内，由于防回绕序列号算法不会防止过期的 RST，所以 RST 报文会被客户端接受了，于是客户端的连接就断开了。</p>
<p>问题二：如果第四次挥手的 ACK 报文丢失了，服务端会触发超时重传，重传第三次挥手报文，处于 syn_sent 状态的客户端收到服务端重传第三次挥手报文，则会回 RST 给服务端。</p>
<p><img data-src="/mybook.github.io/images/347242915273272.png"></p>
<p>如果 TIME_WAIT 状态被快速复用后，刚好第四次挥手的 ACK 报文丢失了，那客户端复用 TIME_WAIT 状态后发送的 SYN 报文被处于 last_ack 状态的服务端收到了会发生什么呢？</p>
<p>处于 last_ack 状态的服务端收到了 SYN 报文后，会回复确认号与服务端上一次发送 ACK 报文一样的 ACK 报文，这个 ACK 报文称为 Challenge ACK ，并不是确认收到 SYN 报文。处于 syn_sent 状态的客户端收到服务端的 Challenge ACK 后，发现不是自己期望收到的确认号，于是就会回复 RST 报文，服务端收到后，就会断开连接。</p>
<h4 id="没有listen，能建立TCP连接吗？"><a href="#没有listen，能建立TCP连接吗？" class="headerlink" title="没有listen，能建立TCP连接吗？"></a>没有listen，能建立TCP连接吗？</h4><p>答案，是可以的，<strong>客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开）</strong>，这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。</p>
<p>执行 listen 方法时，会创建半连接队列和全连接队列。但是客户端没有listen方法，是如何做到的？<br>内核还有个全局 hash 表，可以用于存放 sock 连接的信息。这个全局 hash 表其实还细分为 ehash，bhash和listen_hash等。在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL_IP_ADDR		(0x7F000001) <span class="comment">// IP 127.0.0.1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCAL_TCP_PORT		(34567) <span class="comment">// 端口</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> local, peer;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;local, <span class="number">0</span>, <span class="built_in">sizeof</span>(local));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;peer, <span class="number">0</span>, <span class="built_in">sizeof</span>(peer));</span><br><span class="line"></span><br><span class="line">	local.sin_family = AF_INET;</span><br><span class="line">	local.sin_port = <span class="built_in">htons</span>(LOCAL_TCP_PORT);</span><br><span class="line">	local.sin_addr.s_addr = <span class="built_in">htonl</span>(LOCAL_IP_ADDR);</span><br><span class="line"></span><br><span class="line">	peer = local;	</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(sock, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Fail to setsocket SO_REUSEADDR: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">bind</span>(sock, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;local, <span class="built_in">sizeof</span>(local));</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Fail to bind: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ret = <span class="built_in">connect</span>(sock, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;peer, <span class="built_in">sizeof</span>(peer));</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Fail to connect myself: %s\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Connect to myself successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buf, <span class="string">&quot;Hello, myself~&quot;</span>);</span><br><span class="line">	<span class="built_in">send</span>(sock, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//接收数据</span></span><br><span class="line">	<span class="built_in">recv</span>(sock, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Recv the msg: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	<span class="built_in">close</span>(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 TCP socket 成功的“连接”了自己，并发送和接收了数据包，netstat 的输出更证明了 TCP 的两端地址和端口是完全相同的。<br><img data-src="/mybook.github.io/images/245001518260552.png"></p>
<h4 id="没有accept，能建立TCP连接吗？"><a href="#没有accept，能建立TCP连接吗？" class="headerlink" title="没有accept，能建立TCP连接吗？"></a>没有accept，能建立TCP连接吗？</h4><p>可以，建立连接的过程中根本不需要accept()参与， 执行accept()只是为了从全连接队列里取出一条连接。</p>
<p><img data-src="/mybook.github.io/images/389671918249238.png"></p>
<p>虽然都叫队列，但其实全连接队列<code>icsk_accept_queue</code>是个链表，而半连接队列<code>syn_table</code>是个哈希表。思考为什么这么设计？</p>
<p>补充：前面提到了预防SYN攻击可以开启 syncookies 功能：<a href="#target4">点击此处跳转到syncookies功能</a>，那么，会有一个cookies队列吗？<br>不会，如果有这样一个队列的话，碰到SYN攻击也会被打满，它是通过通信双方的IP地址端口、时间戳、MSS等信息<strong>进行实时计算</strong>的，保存在TCP报头的seq里。</p>
<h5 id="cookies方案为什么不直接取代半连接队列？"><a href="#cookies方案为什么不直接取代半连接队列？" class="headerlink" title="cookies方案为什么不直接取代半连接队列？"></a>cookies方案为什么不直接取代半连接队列？</h5><ol>
<li><p>因为cookies方案服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</p>
</li>
<li><p>编码解码cookies，都是比较耗CPU的，利用这一点，如果此时攻击者构造大量的第三次握手包（ACK包），进行ACK攻击(通过构造大量ACK包去消耗服务端资源的攻击)，同时带上各种瞎编的cookies信息，服务端收到ACK包后以为是正经cookies，憨憨地跑去解码（耗CPU），最后发现不是正经数据包后才丢弃。</p>
</li>
</ol>
<h4 id="TCP-序列号和确认号是如何变化的？"><a href="#TCP-序列号和确认号是如何变化的？" class="headerlink" title="TCP 序列号和确认号是如何变化的？"></a>TCP 序列号和确认号是如何变化的？</h4><p>万能公式<br>公式一：序列号 &#x3D; 上一次发送的序列号 + len（数据长度）。特殊情况，如果上一次发送的报文是 SYN 报文或者 FIN 报文，则改为 上一次发送的序列号 + 1。<br>公式二：确认号 &#x3D; 上一次收到的报文中的序列号 + len（数据长度）。特殊情况，如果收到的是 SYN 报文或者 FIN 报文，则改为上一次收到的报文中的序列号 + 1。</p>
<h3 id="TCP的缺陷"><a href="#TCP的缺陷" class="headerlink" title="TCP的缺陷"></a>TCP的缺陷</h3><h4 id="升级困难"><a href="#升级困难" class="headerlink" title="升级困难"></a>升级困难</h4><p>存在与操作系统内核的协议栈，升级新的TCP需要升级内核，很麻烦</p>
<h4 id="建立连接的延迟"><a href="#建立连接的延迟" class="headerlink" title="建立连接的延迟"></a>建立连接的延迟</h4><p>现在大多数网站都是使用 HTTPS 的，这意味着在 TCP 三次握手之后，还需要经过 TLS 四次握手后，才能进行 HTTP 数据的传输，这在一定程序上增加了数据传输的延迟。</p>
<h4 id="存在队头阻塞问题"><a href="#存在队头阻塞问题" class="headerlink" title="存在队头阻塞问题"></a>存在队头阻塞问题</h4><p>TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据。</p>
<h4 id="网络迁移需要重新建立-TCP-连接"><a href="#网络迁移需要重新建立-TCP-连接" class="headerlink" title="网络迁移需要重新建立 TCP 连接"></a>网络迁移需要重新建立 TCP 连接</h4><p>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立 TCP 连接</p>
<h3 id="TCP一定可靠吗？"><a href="#TCP一定可靠吗？" class="headerlink" title="TCP一定可靠吗？"></a>TCP一定可靠吗？</h3><h4 id="数据包的发送流程"><a href="#数据包的发送流程" class="headerlink" title="数据包的发送流程"></a>数据包的发送流程</h4><ol>
<li><p>为了发送数据包，两端首先会通过三次握手，建立TCP连接。</p>
</li>
<li><p>一个数据包，从聊天框里发出，消息会从聊天软件所在的<strong>用户空间拷贝到内核空间的发送缓冲区</strong>（send buffer），数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡</strong>。数据就这样顺着网卡发到了纷繁复杂的网络世界里。这里头数据会经过n多个路由器和交换机之间的跳转，<strong>最后到达目的机器的网卡处</strong>。</p>
</li>
<li><p>此时目的机器的网卡会<strong>通知DMA将数据包信息放到RingBuffer中</strong>，再触发一个硬中断给CPU，<strong>CPU触发软中断让ksoftirqd去RingBuffer收包</strong>，于是一个数据包就这样顺着物理层，数据链路层，网络层，传输层，<strong>最后从内核空间拷贝到用户空间里的聊天软件里</strong>。</p>
</li>
</ol>
<h4 id="何时会丢包？"><a href="#何时会丢包？" class="headerlink" title="何时会丢包？"></a>何时会丢包？</h4><h5 id="建立连接时丢包"><a href="#建立连接时丢包" class="headerlink" title="建立连接时丢包"></a>建立连接时丢包</h5><p>半连接队列和全连接队列已满，那新来的包就会被丢弃。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全连接队列溢出次数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netstat -s | grep overflowed</span></span><br><span class="line">    4343 times the listen queue of a socket overflowed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">半连接队列溢出次数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">netstat -s | grep -i <span class="string">&quot;SYNs to LISTEN sockets dropped&quot;</span></span></span><br><span class="line">    109 times the listen queue of a socket overflowed </span><br></pre></td></tr></table></figure>

<h5 id="流量控制丢包"><a href="#流量控制丢包" class="headerlink" title="流量控制丢包"></a>流量控制丢包</h5><p>如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，让数据按一定的规则排个队依次处理，也就是所谓的qdisc(Queueing Disciplines，排队规则)，这也是我们常说的流量控制机制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig eth0</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.21.66.69  netmask 255.255.240.0  broadcast 172.21.79.255</span><br><span class="line">        inet6 fe80::216:3eff:fe25:269f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3e:25:26:9f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 6962682  bytes 1119047079 (1.0 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 9688919  bytes 2072511384 (1.9 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>txqueuelen后面的数字1000，其实就是流控队列的长度。当发送数据过快，流控队列长度txqueuelen又不够大时，就容易出现丢包现象。查看TX下的dropped字段，当它大于0时，则有可能是发生了流控丢包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig eth0 txqueuelen 1500 //流控队列长度从1000提升为1500.</span></span><br></pre></td></tr></table></figure>


<h5 id="网卡丢包"><a href="#网卡丢包" class="headerlink" title="网卡丢包"></a>网卡丢包</h5><ol>
<li><p>网线质量差，接触不良等</p>
</li>
<li><p>RingBuffer过小导致丢包<br>上面提到，在接收数据时，会将数据暂存到RingBuffer接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个缓冲区过小，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生丢包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ifconfig</span></span><br><span class="line">eth0:  RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">//查看上面的overruns指标，它记录了由于RingBuffer长度不足导致的溢出次数。</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ethtool -g eth0</span></span><br><span class="line">Ring parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:        4096</span><br><span class="line">RX Mini:    0</span><br><span class="line">RX Jumbo:    0</span><br><span class="line">TX:        4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:        1024</span><br><span class="line">RX Mini:    0</span><br><span class="line">RX Jumbo:    0</span><br><span class="line">TX:        1024</span><br><span class="line"></span><br><span class="line">//RingBuffer最大支持4096的长度，但现在实际只用了1024。想要修改这个长度可以执行ethtool -G eth1 rx 4096 tx 4096将发送和接收RingBuffer的长度都改为4096。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>网卡性能不足</li>
</ol>
<h5 id="接收缓冲区丢包"><a href="#接收缓冲区丢包" class="headerlink" title="接收缓冲区丢包"></a>接收缓冲区丢包</h5><p>使用TCP socket进行网络编程的时候，内核都会分配一个发送缓冲区和一个接收缓冲区。不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的最小值，默认值和最大值 （min、default、max）。缓冲区会在min和max之间动态调整。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看接收缓冲区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl net.ipv4.tcp_rmem</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096    87380   6291456</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看发送缓冲区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl net.ipv4.tcp_wmem</span></span><br><span class="line">net.ipv4.tcp_wmem = 4096    16384   4194304</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当发送缓冲区满了，如果是阻塞调用，那就会等，等到缓冲区有空位可以发数据。如果是非阻塞调用，就会立刻返回一个 EAGAIN 错误信息，意思是 Try again。让应用程序下次再重试。这种情况下一般不会发生丢包。</li>
<li>当接受缓冲区满了，它的TCP接收窗口会变为0，也就是所谓的零窗口，并且会通过数据包里的win&#x3D;0，告诉发送端。一般这种情况下，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生丢包。</li>
</ul>
<h5 id="两端之间的网络丢包"><a href="#两端之间的网络丢包" class="headerlink" title="两端之间的网络丢包"></a>两端之间的网络丢包</h5><p>路由器和交换机还有光缆啥的</p>
<h1 id="灵活应用—-HTTP和HTTPS"><a href="#灵活应用—-HTTP和HTTPS" class="headerlink" title="灵活应用—-HTTP和HTTPS"></a>灵活应用—-HTTP和HTTPS</h1><p>到目前为止，HTTP 常见到版本有 HTTP&#x2F;1.1，HTTP&#x2F;2.0，HTTP&#x2F;3.0，不同版本的 HTTP 特性是不一样的。</p>
<p>HTTP 是超⽂本传输协议，也就是HyperText Transfer Protocol。HTTP 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。</p>
<h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。</strong></p>
<p><img data-src="/mybook.github.io/images/562873316267020.png"></p>
<p>Get请求例子，使用Charles抓取的request：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /562f25980001b1b106000338.jpg HTTP/1.1</span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure>


<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>用来说明请求方法，要访问的资源以及所使用的HTTP版本。GET说明请求方法为GET，jpg为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>
<h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><h5 id="1-GET"><a href="#1-GET" class="headerlink" title="1. GET"></a>1. GET</h5><p>传递参数长度受限制，因为传递的参数是直接表示在地址栏中，而特定浏览器和服务器对url的长度是有限制的。因此，GET不适合用来传递私密数据，也不适合拿来传递大量数据。一般的HTTP请求大多都是GET。</p>
<h5 id="2-POST"><a href="#2-POST" class="headerlink" title="2. POST"></a>2. POST</h5><p>POST把传递的数据封装在HTTP请求数据中，以名称&#x2F;值的形式出现，可以传输大量数据，对数据量没有限制，也不会显示在URL中。表单的提交用的是POST。</p>
<h5 id="GET和POST的区别："><a href="#GET和POST的区别：" class="headerlink" title="GET和POST的区别："></a>GET和POST的区别：</h5><ul>
<li><p>GET 的语义是从服务器获取指定的资源⽅法，GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</p>
</li>
<li><p>GET是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</strong></p>
</li>
<li><p>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p>
</li>
<li><p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。<strong>所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</strong></p>
</li>
</ul>
<p><strong>3. HEAD</strong><br>HEAD跟GET相似，不过服务端接收到HEAD请求时只返回响应头，不发送响应内容。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。<br><strong>4. DELETE</strong><br>删除某一个资源。<br><strong>5. OPTIONS</strong><br>用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。<br><strong>6. PUT</strong><br>把一个资源存放在指定的位置上。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。<br><strong>7. TRACE</strong><br>回显服务器收到的请求，主要用于测试或诊断。<br><strong>8. CONNECT</strong><br>CONNECT方法是HTTP&#x2F;1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。</p>
<h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部由关键字&#x2F;值对组成，每行一对<br>User-Agent : 产生请求的浏览器类型<br>Accept : 客户端希望接受的数据类型，比如 Accept：text&#x2F;xml（application&#x2F;json）表示希望接受到的是xml（json）类型<br>Content-Type：发送端发送的实体数据的数据类型。比如，Content-Type：text&#x2F;html（application&#x2F;json）表示发送的是html类型。<br>Host : 请求的主机名，允许多个域名同处一个IP地址，即虚拟主机<br>Referer：表示当前请求是从哪个资源发起的；或者是请求的上一步的地址。<br>Referer是常用于网站的访问统计，比如我在很多地方都做了广告链接到我网站的主页，这时候我就可以通过Referer来查看哪些地方跳转过来的人多，就说广告的效果好。</p>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>请求头部后面的空行是必须的，即使第四部分的请求数据为空，也必须有空行。</p>
<h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p>请求数据也叫主体，可以添加任意的其他数据。</p>
<h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p><img data-src="/mybook.github.io/images/288873416259689.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 22 May 2009 06:07:21 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">      &lt;head&gt;&lt;/head&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">            &lt;!--body goes here--&gt;</span><br><span class="line">      &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>由HTTP协议版本号， 状态码， 状态消息 三部分组成。（HTTP&#x2F;1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><img data-src="/mybook.github.io/images/3665347114429.png"></p>
<h5 id="1xx-类状态码"><a href="#1xx-类状态码" class="headerlink" title="1xx 类状态码"></a>1xx 类状态码</h5><p>属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p>
<h5 id="2xx-类状态码"><a href="#2xx-类状态码" class="headerlink" title="2xx 类状态码"></a>2xx 类状态码</h5><p>表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<h5 id="3xx-类状态码"><a href="#3xx-类状态码" class="headerlink" title="3xx 类状态码"></a>3xx 类状态码</h5><p>表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p>
<ul>
<li><p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
</li>
<li><p>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
<blockquote>
<p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
</blockquote>
</li>
<li><p>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</p>
</li>
</ul>
<h5 id="4xx-类状态码"><a href="#4xx-类状态码" class="headerlink" title="4xx 类状态码"></a>4xx 类状态码</h5><p>表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<h5 id="5xx-类状态码"><a href="#5xx-类状态码" class="headerlink" title="5xx 类状态码"></a>5xx 类状态码</h5><p>表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p>
<ul>
<li>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>用来说明客户端要使用的一些附加信息<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text&#x2F;html),编码类型是UTF-8</p>
<h3 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h3><p>第三部分：空行，消息报头后面的空行是必须的</p>
<h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>服务器返回给客户端的文本信息。空行后面的html部分为响应正文。</p>
<h2 id="HTTP缓存技术"><a href="#HTTP缓存技术" class="headerlink" title="HTTP缓存技术"></a>HTTP缓存技术</h2><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。</p>
<p><img data-src="/mybook.github.io/images/404601918267482.png"></p>
<ul>
<li>Cache-Control， 是一个相对时间；</li>
<li>Expires，是一个绝对时间；</li>
</ul>
<p>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；</strong></li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>某些请求的响应码是 304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p>
<p><img data-src="/mybook.github.io/images/198132218264984.png"></p>
<p><strong>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</strong>，协商缓存可以基于两种头部来实现。</p>
<p>第一种：</p>
<ul>
<li>响应头部中的 Last-Modified：标示这个响应资源的最后修改时间；</li>
<li>请求头部中的 If-Modified-Since：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</li>
</ul>
<p>第二种：</p>
<ul>
<li>响应头部中 Etag：唯一标识响应资源；</li>
<li>请求头部中的 If-None-Match：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</li>
</ul>
<p>第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。</p>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h2><h3 id="HTTP-1-1优点"><a href="#HTTP-1-1优点" class="headerlink" title="HTTP&#x2F;1.1优点"></a>HTTP&#x2F;1.1优点</h3><ol>
<li>简单<br>HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解</li>
<li>灵活和易于扩展<br>HTTP协议⾥的各类请求⽅法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。</li>
<li>应⽤⼴泛和跨平台</li>
</ol>
<h3 id="HTTP-1-1缺点"><a href="#HTTP-1-1缺点" class="headerlink" title="HTTP&#x2F;1.1缺点"></a>HTTP&#x2F;1.1缺点</h3><ol>
<li>⽆状态</li>
</ol>
<ul>
<li>好处：因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。</li>
<li>坏处：既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。</li>
</ul>
<ol start="2">
<li>不安全</li>
</ol>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装。</li>
<li>无法证明报文的完整性，所以有可能已遭篡改。</li>
</ul>
<h3 id="HTTP-1-1特点"><a href="#HTTP-1-1特点" class="headerlink" title="HTTP&#x2F;1.1特点"></a>HTTP&#x2F;1.1特点</h3><ol>
<li>⻓连接</li>
</ol>
<ul>
<li>早期 HTTP&#x2F;1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。</li>
<li>为了解决上述 TCP 连接问题，HTTP&#x2F;1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了TCP 连接的复建⽴和断开所造成的额外开销，减轻了服务器端的负载。<strong>持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。</strong></li>
</ul>
<ol start="2">
<li>管道⽹络传输</li>
</ol>
<ul>
<li>HTTP&#x2F;1.1 采⽤了⻓连接的⽅式，这使得管道⽹络传输成为了可能。即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，<strong>可以减少整体的响应时间。</strong></li>
<li>管道机制则是允许浏览器同时发出 A 请求和 B 请求。但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。</li>
</ul>
<ol start="3">
<li>队头阻塞</li>
</ol>
<ul>
<li>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等着。这称为「队头堵塞」。</li>
<li>「请求 - 应答」的模式加剧了 HTTP 的性能问题。因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据，这也就是「队头阻塞」。<strong>HTTP&#x2F;1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong></li>
</ul>
<h3 id="HTTP-1-1-相⽐-HTTP-1-0-性能上的改进："><a href="#HTTP-1-1-相⽐-HTTP-1-0-性能上的改进：" class="headerlink" title="HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 性能上的改进："></a>HTTP&#x2F;1.1 相⽐ HTTP&#x2F;1.0 性能上的改进：</h3><ol>
<li>使⽤ TCP ⻓连接的⽅式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li>
<li>⽀持管道⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。</li>
</ol>
<h3 id="HTTP-1-1性能瓶颈"><a href="#HTTP-1-1性能瓶颈" class="headerlink" title="HTTP&#x2F;1.1性能瓶颈"></a>HTTP&#x2F;1.1性能瓶颈</h3><ol>
<li>请求 &#x2F; 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；</li>
<li>发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多；</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；</li>
<li>没有请求优先级控制；</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ol>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h2><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p>
<p><img data-src="/mybook.github.io/images/469225416256244.png"></p>
<h3 id="HTTP-2做了哪些优化"><a href="#HTTP-2做了哪些优化" class="headerlink" title="HTTP&#x2F;2做了哪些优化"></a>HTTP&#x2F;2做了哪些优化</h3><ol>
<li>头部压缩<br>HTTP&#x2F;2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，<strong>协议会帮你消除重复的部分</strong>。这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。<br>为高频出现在头部的字符串和字段建立了一张静态表：</li>
</ol>
<p><img data-src="/mybook.github.io/images/10224215259237.png"></p>
<ol start="2">
<li><p>⼆进制格式<br>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧：头信息帧和数据帧。<strong>增加了传输效率</strong></p>
</li>
<li><p>并发传输<br>HTTP&#x2F;2引出了 Stream 概念，多个 Stream 复用在一条 TCP 连接。</p>
</li>
</ol>
<p><img data-src="/mybook.github.io/images/538245916251998.png"></p>
<p>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP&#x2F;2 可以并行交错地发送请求和响应。</p>
<ol start="4">
<li>服务器主动推送</li>
</ol>
<ul>
<li>HTTP&#x2F;2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送。</li>
<li>客户端和服务器双方都可以建立 Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li>
</ul>
<h3 id="HTTP-2存在的问题"><a href="#HTTP-2存在的问题" class="headerlink" title="HTTP&#x2F;2存在的问题"></a>HTTP&#x2F;2存在的问题</h3><p>TCP的队头阻塞：HTTP&#x2F;2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，<strong>后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据</strong>，这就是 HTTP&#x2F;2 队头阻塞问题。</p>
<p><img data-src="/mybook.github.io/images/466970617269878.png"></p>
<p>所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p>
<h2 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h2><h3 id="HTTP-3做了哪些优化"><a href="#HTTP-3做了哪些优化" class="headerlink" title="HTTP&#x2F;3做了哪些优化"></a>HTTP&#x2F;3做了哪些优化</h3><p><strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP,基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。</strong></p>
<ul>
<li>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，<mark>只会阻塞这个流，其他流不会受到影响。</mark></li>
<li>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。</li>
<li>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS&#x2F;1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS&#x2F;1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li>
</ul>
<p><img data-src="/mybook.github.io/images/3227683816513.png"></p>
<p>QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 在 TCP 三次握手之后，还需进行 SSL&#x2F;TLS 的握手过程，才可进入加密报文传输。两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。很好的解决了<strong>窃听⻛险，篡改⻛险，冒充⻛险</strong>。</p>
<ol>
<li>混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。</li>
<li>摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。</li>
<li>将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。</li>
</ol>
<h3 id="HTTPS的特点"><a href="#HTTPS的特点" class="headerlink" title="HTTPS的特点"></a>HTTPS的特点</h3><h4 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h4><p>客户端在发送明⽂之前会通过摘要算法（哈希函数）算出内容的哈希值，这个哈希值是唯一的，且无法通过哈希值推导出内容。发送的时候把「哈希值 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「哈希值」和当前算出的「哈希值」做⽐较，若「哈希值」相同，说明数据是完整的。</p>
<p><img data-src="/mybook.github.io/images/25951248990.png"></p>
<p><strong>通过哈希算法可以确保内容不会被篡改，但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明</strong>。为了避免这种情况，用非对称加密算法来解决</p>
<h4 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h4><p>HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式：</p>
<ul>
<li>在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。</li>
<li>在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。</li>
</ul>
<p><strong>采⽤「混合加密」方式的原因：</strong></p>
<ul>
<li>对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。</li>
<li>⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。</li>
</ul>
<p>流程的不同，意味着目的也不相同：<br>公钥加密，私钥解密。这个目的是<strong>为了保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<br>私钥加密，公钥解密。这个目的是<strong>为了保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</p>
<p>但是一般不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。而是对内容的哈希值加密。</p>
<p><img data-src="/mybook.github.io/images/204515509246226.png"></p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。一个数字证书通常包含了：</p>
<ol>
<li>公钥；</li>
<li>持有者信息；</li>
<li>证书认证机构（CA）的信息；</li>
<li>CA 对这份文件的数字签名及使用的算法；</li>
<li>证书有效期；</li>
<li>还有一些其他额外信息；</li>
</ol>
<h3 id="SSL-TLS-协议基本流程"><a href="#SSL-TLS-协议基本流程" class="headerlink" title="SSL&#x2F;TLS 协议基本流程"></a>SSL&#x2F;TLS 协议基本流程</h3><p>TLS 的「握手阶段」涉及四次通信，一般位于TCP和HTTP之间，在三次握手之后</p>
<p><img data-src="/mybook.github.io/images/256104010263802.png"></p>
<ol>
<li>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。涉及以下信息：<blockquote>
<p><strong>①TLS 协议版本</strong><br><strong>②随机数(Client Random)，后面用于生成「会话秘钥」条件之一</strong><br><strong>③支持的密码套件列表，如 RSA 加密算法</strong></p>
</blockquote>
</li>
</ol>
<p><img data-src="/mybook.github.io/images/426134610257348.png"></p>
<ol start="2">
<li>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello + Server Certificate + Server Hello Done。回应的内容：<blockquote>
<p><strong>①确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信</strong><br><strong>②随机数(Server Random)，也是后面用于生产「会话秘钥」条件之一</strong><br><strong>③确认的密码套件列表，如 RSA 加密算法。</strong><br><strong>④服务器的数字证书</strong></p>
</blockquote>
</li>
</ol>
<p><img data-src="/mybook.github.io/images/69494710250482.png" alt="Server Hello"></p>
<p><img data-src="/mybook.github.io/images/574544810241012.png" alt="Server Certificate"></p>
<p><img data-src="/mybook.github.io/images/84844910243516.png" alt="Server Hello Done"></p>
<ol start="3">
<li>客户端收到服务器的回应之后，发送响应：Client Key Exchange + Change Cipher Spec + Encrypted Handshake Message（Finishd）<br>首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，<strong>客户端会从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：<blockquote>
<p><strong>①一个随机数(pre-master key)。该随机数会被服务器公钥加密</strong><br><strong>②加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信</strong><br><strong>③客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验</strong></p>
</blockquote>
</li>
</ol>
<p><img data-src="/mybook.github.io/images/186055410252463.png" alt="Client Key Exchange"></p>
<p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</p>
<p>生成完「会话密钥」后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。</p>
<p><img data-src="/mybook.github.io/images/75415610245348.png" alt="Change Cipher Spec"></p>
<p>然后，客户端再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。</p>
<p><img data-src="/mybook.github.io/images/402781011245957.png" alt="Encrypted Handshake Message"></p>
<ol start="4">
<li>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：<blockquote>
<p><strong>①加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信</strong><br><strong>②服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验</strong></p>
</blockquote>
</li>
</ol>
<p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>
<h3 id="HTTPS一定安全？"><a href="#HTTPS一定安全？" class="headerlink" title="HTTPS一定安全？"></a>HTTPS一定安全？</h3><p>HTTPS本身是安全的</p>
<p><img data-src="/mybook.github.io/images/96472810268666.png"></p>
<p>中间人服务器与客户端在 TLS 握手过程中，<strong>实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的</strong>，于是就会提醒用户该证书存在问题。如果你<strong>无视风险，继续访问</strong>，那就是不安全的</p>
<h3 id="密匙交换算法"><a href="#密匙交换算法" class="headerlink" title="密匙交换算法"></a>密匙交换算法</h3><p>使⽤⾮对称加密的⽅式来保护对称加密密钥的协商，这个⼯作就是密钥交换算法负责的。</p>
<h4 id="RSA-算法"><a href="#RSA-算法" class="headerlink" title="RSA 算法"></a>RSA 算法</h4><ul>
<li>传统的 TLS 握⼿基本都是使⽤ RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书⽂件中包含⼀对公私钥，其中公钥会在 TLS 握⼿阶段传递给客户端，私钥则⼀直留在服务端，⼀定要确保私钥不能被窃取。</li>
<li>在 RSA 密钥协商算法中，客户端会⽣成随机密钥，并使⽤服务端的公钥加密后再传给服务端。根据⾮对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双⽅就得到了相同的密钥，再⽤它加密应⽤消息。</li>
</ul>
<p><strong>缺陷：</strong><br><strong>不⽀持前向保密</strong>。因为客户端传递随机数（⽤于⽣成对称加密密钥的条件之⼀）给服务端时使⽤的是公钥加密的，服务端收到到后，会⽤私钥解密得到随机数。所以⼀旦服务端的私钥泄漏了，过去被第三⽅截获的所有 TLS 通讯密⽂都会被破解。</p>
<h4 id="ECDHE-算法"><a href="#ECDHE-算法" class="headerlink" title="ECDHE 算法"></a>ECDHE 算法</h4><p>ECDHE 密钥协商算法是 DH 算法演进过来的，先从 DH 算法说起。</p>
<h5 id="DH-算法"><a href="#DH-算法" class="headerlink" title="DH 算法"></a>DH 算法</h5><p>该算法的核心数学思想是离散对数。离散对数是在对数运算的基础上加了「模运算」，也就说取余数，也可以用 mod 表示。</p>
<p><img data-src="/mybook.github.io/images/293411411272912.png"></p>
<p>底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。<strong>知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。</strong></p>
<p>现假设⼩红和⼩明约定使⽤ DH 算法来交换密钥，那么基于离散对数，需要先确定模数和底数作为算法的参数，这两个参数是公开的，⽤ P 和 G 来代称。然后⼩红和⼩明各⾃⽣成⼀个随机整数作为私钥，⼩红的私钥⽤ a 代称，⼩明的私钥⽤ b 代称。</p>
<p>现在⼩红和⼩明双⽅都有了 P 和 G 以及各⾃的私钥，于是就可以计算出公钥：<br>⼩红的公钥记作 A，A &#x3D; G ^ a ( mod P )；<br>⼩明的公钥记作 B，B &#x3D; G ^ b ( mod P )；</p>
<ul>
<li>A 和 B 也是公开的，因为根据离散对数的原理，从真数（A 和 B）反向计算对数 a 和 b 是⾮常困难的</li>
<li>双⽅交换各⾃ DH 公钥后，⼩红⼿上共有 5 个数：P、G、a、A、B，⼩明⼿上也同样共有 5 个数：P、G、b、B、A。</li>
<li>⼩红执⾏运算： B ^ a ( mod P )，其结果为 K，<strong>因为离散对数的幂运算有交换律</strong>，所以⼩明执⾏运算： A ^ b (mod P )，得到的结果也是 K。</li>
<li>这个 K 就是⼩红和⼩明之间⽤的对称加密密钥，可以作为会话密钥使⽤。</li>
</ul>
<p><img data-src="/mybook.github.io/images/3347520485606.png"></p>
<p>可以看到，整个密钥协商过程中，⼩红和⼩明公开了 4 个信息：P、G、A、B，其中 P、G 是算法的参数，A 和 B是公钥，⽽ a、b 是双⽅各⾃保管的私钥，⿊客⽆法获取这 2 个私钥，因此⿊客只能从公开的 P、G、A、B ⼊⼿，计算出离散对数（私钥）。如果 P 是⼀个⼤数，在现有的计算机的计算能⼒是很难破解出 私钥 a、b的，破解不出私钥，也就⽆法计算出会话密钥，因此 DH 密钥交换是安全的。</p>
<p><strong>缺陷：</strong></p>
<ul>
<li><strong>不具备前向安全性</strong>。DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即小红的私钥 a 不变，客户端的私钥则是随机生成的。于是，DH 交换密钥时就只有客户端（小明）的公钥是变化，而服务端（小红）公钥是不变的，</li>
<li>那么随着时间延长，因为密钥协商的过程有些数据是公开的，黑客就会截获海量的密钥协商过程的数据，暴力破解出服务器的私钥，然后就可以计算出会话密钥了，于是之前截获的加密数据会被破解</li>
</ul>
<h5 id="DHE算法"><a href="#DHE算法" class="headerlink" title="DHE算法"></a>DHE算法</h5><p>让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。</p>
<p><strong>缺陷：</strong><br>计算性能不佳，因为需要做大量的乘法</p>
<h5 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h5><p>ECDHE 算法是在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p>
<h6 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h6><p>什么是椭圆曲线？椭圆曲线有两个特点：</p>
<ul>
<li>如果你在上方随便画一个点，那么下方也一定有一个对称的点，上下方距离水平线X轴是相同的。</li>
<li>随便在图形上画两个点，让这两个点连成线然后延长会经过第三个点，当然除了垂直线以外。</li>
</ul>
<ol>
<li>如果有A，B两个点，延长以后会经过第三个点，而这第三个点以X轴为中心是会有一个点与其对称，把这个对称的点称为C点。A和B得出C，把运算过程称为 “点运算”，A点B得到C，这个 “点运算”其实就是椭园曲线上的加法运算。</li>
<li>现在把A和C进行连线，同样经过了第三个点，第三个点也有一个对称的点，这里称为D点，也就是A点C得到D，</li>
<li>再把A和D连线，也经过了第三个点，第三个点也有一个对称的点，这里称为E点，也就是A点D得到E。</li>
</ol>
<p><img data-src="/mybook.github.io/images/352361615252903.png"></p>
<p>问题：已知起点是A，终点是E，请问起点A经过多少次点运算得到E？很难知道经过了多少次，这就很符合我们前面说的公钥加密的特点：正向简单，逆向困难</p>
<p><img data-src="/mybook.github.io/images/99411015240674.png"></p>
<h6 id="ECDHE密钥交换过程"><a href="#ECDHE密钥交换过程" class="headerlink" title="ECDHE密钥交换过程"></a>ECDHE密钥交换过程</h6><p>Alice和Bob使用 ECDHE 密钥交换算法的过程：</p>
<p><img data-src="/mybook.github.io/images/491822515257942.png"></p>
<ol>
<li>双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；</li>
<li>Alice随机生成一个随机数作为私钥a，并与基点G相乘得到公钥A（A &#x3D; a * G，就是G这个点进行点运算，次数是a，也就是G点G点G点…一共a次），此时Alice的公私钥为 A 和 a，把大A和G发送给Bob</li>
<li>Bob收到后，也生成了一个私钥b，然后生成椭圆曲线上的一个新点，公钥B（B &#x3D; b * G，就是G点进行小b次运算得到的，也就是G点G点G点…一共b次），此时Bob的公私钥为 B 和 b，把生成的大B发送给Alice，别人知道 B 和 G 也很难得到 b</li>
<li>最后Alice计算点（x1，y1） &#x3D; B * a，Bob计算点（x2，y2）&#x3D; A * b，<strong>由于椭圆曲线上是可以满足乘法交换和结合律</strong>，所以 B * a &#x3D; G * a * b &#x3D; A * b（假设a&#x3D;3，b&#x3D;2） ，因此双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥。</li>
</ol>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="请求转发和请求重定向的异同"><a href="#请求转发和请求重定向的异同" class="headerlink" title="请求转发和请求重定向的异同"></a>请求转发和请求重定向的异同</h2><ol>
<li><p>跳转机制：<br>请求转发（Forward）：是服务器内部的行为，当服务器收到客户端的请求后，会将请求转发给目标地址，并将目标地址的响应结果返回给客户端。在整个过程中，客户端对服务器内部的转发过程毫不知情，只感知到一次请求和响应。<br>请求重定向（Redirect）：是客户端的行为，服务器在接收到客户端的请求后，返回一个临时响应头，其中包含客户端需要再次发送请求的URL地址。客户端在收到这个地址后，会向新的地址发送请求，从而实现页面的跳转。这个过程对客户端来说是两次独立的请求和响应。</p>
</li>
<li><p>数据共享：<br>请求转发：由于是服务器内部操作，整个交互过程中使用的是同一个Request对象和一个Response对象，因此请求和返回的数据是共享的。<br>请求重定向：客户端发送两次完全不同的请求，因此两次请求中的数据是不同的。</p>
</li>
<li><p>URL地址的改变：<br>请求转发：浏览器上的地址不会改变，因为服务器内部的处理对客户端来说是透明的。<br>请求重定向：浏览器上的地址会改变，因为客户端会看到一个不同的URL地址被加载。</p>
</li>
<li><p>效率：<br>请求转发：因为只涉及一次请求和响应，所以效率更高。<br>请求重定向：涉及两次请求和响应，所以效率相对较低。</p>
</li>
<li><p>数据传递：<br>请求转发：可以使用Request对象在多个页面间传递参数。<br>请求重定向：通常不使用Request对象传递参数，但可以通过URL参数或会话(Session)等方式传递。</p>
</li>
<li><p>表单重复提交：<br>请求转发：可能造成表单的重复提交，因为表单提交后的行为发生在服务器内部，无法直接感知到表单提交的结果。<br>请求重定向：不会造成表单的重复提交，因为表单提交后会触发浏览器的跳转，从而避免了重复提交的问题。</p>
</li>
<li><p>目标服务器：<br>请求转发：只能在服务器内部转发，不能跳转到其他服务器。<br>请求重定向：可以跳转到其他服务器进行转发。</p>
</li>
</ol>
<h2 id="Cookie与Session"><a href="#Cookie与Session" class="headerlink" title="Cookie与Session"></a>Cookie与Session</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>在客户端第⼀次请求后，服务器会下发⼀个装有客户信息的「⼩贴纸」，后续客户端请求服务器的时候，带上「⼩贴纸」，服务器就能认得了，Cookie具有不可跨域名性</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul>
<li><strong>Session机制是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表。</strong></li>
<li>Session机制决定了当前客户只会获取到自己的Session，而不会获取到别人的Session。各客户的Session也彼此独立，互不可见。</li>
<li><strong>Session对象是在客户端第一次请求服务器的时候创建的</strong>。Session也是一种key-value的属性对，通过getAttribute(Stringkey)和setAttribute(String key，Objectvalue)方法读写客户状态信息。Servlet里通过request.getSession()方法获取该客户的Session，</li>
<li>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><strong>cookie数据存放在客户的浏览器上，session数据放在服务器上。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</strong></li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE</li>
<li>将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</li>
<li>两者最大的区别在于生存周期，一个是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)</li>
</ol>
<p> <img data-src="/mybook.github.io/images/donate_jpg.jpg"></p>
<link rel="stylesheet" href="/mybook.github.io/css/spoiler.css" type="text/css"><script src="/mybook.github.io/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
</search>
